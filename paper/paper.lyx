#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass ulb_thesis
\begin_preamble
\usepackage[american,francais,english]{babel}
\usepackage{breakcites}
\usepackage{algorithmic,tikz, pgf, pgfplots}
\usetikzlibrary{automata,graphs,positioning,shadows}
\usetikzlibrary{arrows,backgrounds,plotmarks}
\pgfplotsset{width=7cm,compat=newest}
\pgfplotsset{plot coordinates/math parser=false}
\end_preamble
\options draftfoot
\use_default_options false
\maintain_unincluded_children false
\language american
\language_package none
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename PageDeGarde.pdf

\end_inset


\end_layout

\begin_layout Dedication
To Attilio and Magda.
\end_layout

\begin_layout Acknowledgments
I am very grateful to my advisor prof.
 Stijn Vansummeren, for his constant attention to my work, his willingness
 and his valuable comments and inputs.
 I am equally grateful to my supervisor Martin Ugarte, that helped me considerab
ly throughout my efforts by following my progress closely, reasoning with
 me on every issue that I met and always providing useful suggestions, validatin
g my results and scrupulously reviewing this document.
\end_layout

\begin_layout Acknowledgments
Finally, I would like to thank Attilio, Magda, Andrea, Sara, Isabella, Cecilia,
 Nicolas and Thu Minh for their precious support.
 Without you this thesis would not be possible.
\end_layout

\begin_layout Standard
\begin_inset VSpace 4cm*
\end_inset


\end_layout

\begin_layout Standard

\emph on
\begin_inset Quotes eld
\end_inset


\emph default
Your task is not to foresee the future, but to enable it.
\begin_inset Quotes erd
\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\align right
Antoine de Saint Exupéry
\end_layout

\begin_layout Abstract
Information Extraction addresses the task of extracting information from
 unstructured text automatically.
 Traditionally, IE systems focus on the accuracy of extraction tasks.
 However, the problem of the 
\emph on
scalability
\emph default
 of these tasks has recently began to receive attention.
 SystemT is an IE system that successfully addresses this concern.
 This success stimulated many studies related to SystemT.
 One of the most prominent introduces a formal model that delineates a new
 approach to extraction tasks, considerably different from that of SystemT.
 According to this formal model, an extraction task is executed by first
 obtaining basic elements from the input text, and then combining these
 elements by means of algebraic operators to obtain the desired results.
 In this dissertation, I embark on the task of defining and implementing
 a new 
\emph on
runtime system
\emph default
 that allows for efficiently obtaining the desired results without the necessity
 to apply algebraic operators over basic elements.
 To this end, I first introduce a computational model (namely 
\emph on
eVset-automata
\emph default
), that is based on a previous model (
\emph on
vset-automata
\emph default
), used for extracting basic elements from text, and I show that the two
 models are equivalent in expressive power.
 Moreover, I prove that under the proposed model there are 
\emph on
polynomial time constructions
\emph default
 that allow for directly evaluating the algebraic operators, without the
 need for obtaining the basic elements first.
 This represents an improvement over the previous approach (vset-automata),
 under which constructions for the same purpose existed but resulted in
 exponentially larger computations.
 Then, I discuss the results of a series of experiments executed on a corpus
 of real-life blog posts, that compare the performance of the runtime system
 with that of a subsystem that uses the same approach of SystemT.
 The experiments show that the runtime system is better than the subsystem
 in many cases.
 However, the subsystem is naturally capable of reusing partial results
 to reduce its workload, which can sometimes be advantageous.
 Finally, I lay the foundations for further improvements of the runtime
 system.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{abstractf}
\end_layout

\end_inset

La discipline nommé 
\emph on
Information Extraction
\emph default
 traite de la tâche d'extraire des informations de texte non structuré automatiq
uement.
 Traditionnellement, les systèmes IE mettent l'accent sur la précision des
 tâches d'extraction.
 Cependant, le problème de l'évolutivité de ces tâches a récemment commencé
 à recevoir une attention.
 SystemT est un système IE qui répond avec succès à cette préoccupation.
 Ce succès a stimulé de nombreuses études liées à SystemT.
 L'un des plus importants introduit un modèle formel qui définit une nouvelle
 approche pour les tâches d'extraction, considérablement différente de celle
 de SystemT.
 Selon ce modèle formel, une tâche d'extraction est exécutée en obtenant
 d'abord les éléments de base du texte d'entrée, puis en combinant ces éléments
 au moyen d'opérateurs algébriques afin d'obtenir les résultats souhaités.
 Dans cette thèse, je me embarque sur la tâche de définir et mettre en œuvre
 un nouveau 
\emph on
système d'exécution
\emph default
 qui permet d'obtenir efficacement les résultats souhaités sans la nécessité
 d'appliquer les opérateurs algébriques sur les éléments de base.
 À cette fin, je présente d'abord un modèle de calcul (à savoir 
\emph on
eVset-automata
\emph default
), qui est basé sur un modèle précédent (
\emph on
vset-automata
\emph default
), utilisé pour extraire les éléments de base à partir du texte, et je montre
 que les deux modèles sont équivalents en puissance expressive.
 De plus, je montre que selon le modèle proposé il y a des 
\emph on
constructions polynomiaux
\emph default
 qui permettent d'évaluer directement les opérateurs algébriques, sans la
 nécessité d'obtenir des éléments de base en premier.
 Cela représente une amélioration par rapport à l'approche précédente (
\emph on
vset-automata
\emph default
), dans laquelle des constructions pour le même but existaient mais ils
 entraînaient des exponentiellement plus grands calculs.
 Ensuite, je discute les résultats d'une série d'expériences réalisées sur
 un corpus de blogs réelles, qui comparent les performances du système d'exécuti
on à celui d'un sous-système qui utilise la même approche de SystemT.
 Les expériences montrent que le système d'exécution est meilleur que le
 sous-système dans de nombreux cas.
 Toutefois, le sous-système est naturellement capable de réutiliser les
 résultats partiels pour réduire sa charge de travail, ce qui peut parfois
 être avantageux.
 Enfin, je pose les bases d'autres améliorations du système d'exécution.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{abstractf}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mainmatter
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand include
filename "intro.lyx"

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:IE"

\end_inset

Information Extraction
\end_layout

\begin_layout Standard
In this chapter, I give a generic introduction to Information Extraction.
 This chapter is a re-elaboration of 
\begin_inset CommandInset citation
LatexCommand cite
key "Sarawagi:2008:IE:1498844.1498845"

\end_inset

.
 Refer to the original source for a more comprehensive and detailed overview.
 The figures and examples appearing in this chapter are original.
 The chapter is structured as follows: Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:IE-def"

\end_inset

 contains a general definition of Information Extraction; in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:IE-examples"

\end_inset

, a series of application domains where Information Extraction can be applied
 are reviewed; Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:IE-Issues"

\end_inset

 is a discussion of the main challenges that are met in extraction tasks;
 finally, Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:IE-Entity"

\end_inset

 and Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:IE-Relationship"

\end_inset

 contain high-level descriptions of the two main subtasks of Information
 Extraction: Entity Extraction and Relationship Extraction, respectively.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:IE-def"

\end_inset

Definition
\end_layout

\begin_layout Standard
Information Extraction (IE) is the discipline that addresses the task of
 extracting structured information from unstructured sources automatically.
 Sources usually take the form of text documents.
 The most explored aspect of IE is the extraction of 
\emph on
named entities.

\emph default
 Another main topic, that has become object of research only in recent years,
 is the extraction of 
\emph on
relationships
\emph default
 between entities.
 IE is a field with contributions from many different communities: Machine
 Learning, Information Retrieval, Database, Web, Document Analysis.
 The interest towards it is motivated by the constantly increasing amount
 of data that is generated by our society.
 IE promises to bring value to many application domains, most notably the
 enterprise world and the Web.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
There are two prominent approaches to IE: 
\end_layout

\begin_layout Description

\emph on
rule-based
\emph default
 which defines a set of rules that the output has to respect.
 The rules can be manually coded or learned from examples;
\end_layout

\begin_layout Description

\emph on
statistical
\emph default
 which seeks to identify a decomposition of unstructured text and to label
 its components.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:IE-examples"

\end_inset

Example Applications
\end_layout

\begin_layout Standard
IE can serve for a large variety of tasks.
 What follows is a review of some of the most common ones.
\end_layout

\begin_layout Paragraph
News Tracking
\end_layout

\begin_layout Standard
The activity of tracking events in news articles.
 It can result in a lot of useful services, like automatic creation of multimedi
a news, linking articles to information pages on the entities found, etc.
\end_layout

\begin_layout Example
Google Alerts
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.google.com/alerts
\end_layout

\end_inset


\end_layout

\end_inset

 lets the user specify a subject of interest and it offers a series of news
 articles related to that subject.
\end_layout

\begin_layout Paragraph
Data Cleaning
\end_layout

\begin_layout Standard
Extracting structured forms from flat data strings (containing, e.g., addresses).
 It allows more effective deduplication of information, among the other
 things.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikz[level distance=3.6cm] 
\backslash
node{ 	
\backslash
begin{tikzpicture} 		
\backslash
matrix[row sep=0.2cm]{ 
\end_layout

\begin_layout Plain Layout

			
\backslash
node[rectangle, draw] {Stationsstraat, 336, 5032, Isnes}; 
\backslash

\backslash
  			
\backslash
node[rectangle, draw] {Sreet: Herentalsebaan, Nr: 219,  ZIP: 3800, City:
 Brustem}; 
\backslash

\backslash
 			
\backslash
node[rectangle, draw] {Sreet: Stationsstraat, Nr: 336,  ZIP: 5032, City:
 Isnes}; 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		}; 	
\backslash
end{tikzpicture}  } child{ 	node{
\backslash
begin{tabular}{|l|l|l|l|}     	    
\backslash
hline 	    
\backslash
textbf{Street}	& 
\backslash
textbf{Nr}	& 
\backslash
textbf{ZIP}	& 
\backslash
textbf{City} 	    
\backslash

\backslash
 
\backslash
hline 	    Stationsstraat      & 336 		& 5032  	& Isnes     
\backslash

\backslash
 
\backslash
hline 	    Herentalsebaan      & 219 		& 3800  	& Brustem   
\backslash

\backslash
 
\backslash
hline 	    Stationsstraat      & 336 		& 5032  	& Isnes     
\backslash

\backslash
 
\backslash
hline 	  
\backslash
end{tabular} 	} 	child{ 		node{
\backslash
begin{tabular}{|l|l|l|l|} 	    	    
\backslash
hline 	    	    
\backslash
textbf{Street}	& 
\backslash
textbf{Nr}	& 
\backslash
textbf{ZIP}	& 
\backslash
textbf{City} 	    
\backslash

\backslash
 
\backslash
hline 		    Stationsstraat      & 336 		& 5032  	& Isnes     
\backslash

\backslash
 
\backslash
hline 		    Herentalsebaan      & 219 		& 3800  	& Brustem   
\backslash

\backslash
 
\backslash
hline 		  
\backslash
end{tabular} 		} 		edge from parent[draw=none] node {$
\backslash
downarrow$} 	} 	edge from parent[draw=none] node {$
\backslash
downarrow$} };
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:ex-cleaning"

\end_inset

Extraction of structured addresses from flat strings (with deduplication).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ex-cleaning"

\end_inset

 illustrates an example data cleaning task.
 A structured table of addresses is obtained from a set of flat address
 strings.
 Subsequently, duplicates are removed from the table.
\end_layout

\begin_layout Paragraph
Citation Databases
\end_layout

\begin_layout Standard
Articles, conference sites, individual research sites and similar are explored
 to obtain formatted citations of publications, later stored in publicly
 accessible databases.
 The latter are capable to forward references and may provide aggregate
 statistics and scoring information.
\end_layout

\begin_layout Example
The citation database Google Scholar
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://scholar.google.com/
\end_layout

\end_inset


\end_layout

\end_inset

 automatically maintains, for each paper registered, a list of papers that
 refer to it.
 The user can, in turn, consult the citations of these papers too, and so
 on.
\end_layout

\begin_layout Paragraph
Relationship Web Search
\end_layout

\begin_layout Standard
Relationship extraction would be a very useful feature to integrate into
 web search engines, as the keyword search that they offer at present time
 is only good for entity identification.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
As the reader can see, IE can be used for a variety of diversified data
 analysis tasks.
 Nonetheless, the criteria that we use to measure the quality of an IE system
 are always the same.
 The next section is a review of the most important issues that a developer
 of an IE system has take care of, in order to obtain satisfactory results.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:IE-Issues"

\end_inset

Issues
\end_layout

\begin_layout Standard
The main issues that have to be dealt with when performing IE can be divided
 in two categories: 
\emph on
accuracy
\emph default
 and 
\emph on
running time
\emph default
.
\end_layout

\begin_layout Subsection
Accuracy
\end_layout

\begin_layout Standard
Only the main metrics for entity extraction are reported here.
 Those for relationship extraction are similar.
 We measure the accuracy of an entity extraction task with two quantities:
\end_layout

\begin_layout Itemize

\emph on
precision
\emph default
: the percentage of correctly extracted entities among the extracted entities;
\end_layout

\begin_layout Itemize

\emph on
recall
\emph default
: the percentage of entities extracted among all the existing entities in
 the input source.
\end_layout

\begin_layout Standard
The main difficulties to achieving a good level of accuracy are:
\end_layout

\begin_layout Itemize
the availability of a great set of clues that might be very different in
 nature (e.
 g., orthographic properties, part of speech, typical words, etc.) and that
 might be difficult to combine;
\end_layout

\begin_layout Itemize
the difficulty of identifying missed extractions;
\end_layout

\begin_layout Itemize
the fact that with the advancement of research the extracted data structures
 keep increasing in complexity (for instance, it is becoming more difficult
 to identify the boundaries of an entity in a text).
\end_layout

\begin_layout Standard
While it is possible to reach a very good level of accuracy for entity extractio
n (
\begin_inset Formula $90\%$
\end_inset

), relationship extraction is still quite unreliable (
\begin_inset Formula $50-70\%$
\end_inset

 accuracy), mainly due to its intrinsic complexity.
\end_layout

\begin_layout Subsection
Running Time
\end_layout

\begin_layout Standard
Nowadays companies need to process enormous amounts of data on a regular
 basis.
 Hence, they have an increasing interest in IE.
 Since their datasets keep growing in size,
\emph on
 scalability
\emph default
 has become a central issue in the field of IE.
 
\end_layout

\begin_layout Standard
This trend has appeared only in recent years, while, historically, this
 discipline has always been confined to the domain of theoretical research.
 As a consequence many IE systems don't address the problem of efficiently
 carrying out extraction tasks with sufficient attention.
\end_layout

\begin_layout Standard
The overall efficiency of an extraction task is influenced most notably
 by the efficiency of the following tasks:
\end_layout

\begin_layout Itemize
filtering documents in order to actually examine only the ones that have
 good chances to contain the desired information;
\end_layout

\begin_layout Itemize
focusing on the parts of a document that contain relevant information;
\end_layout

\begin_layout Itemize
processing steps, like database querying, that are typically very expensive
 and that might have to be performed on the selected pieces of input.
\end_layout

\begin_layout Standard
Recently, many solutions have been proposed to target the scalability issue;
 one of these is SystemT.
 It is a system for rule-based Information Extraction developed at IBM research
 laboratories, that is based on an innovative approach to defining and executing
 extraction task: the so-called 
\begin_inset Quotes eld
\end_inset

algebraic approach
\begin_inset Quotes erd
\end_inset

.
 SystemT is a promising solution, since it has been shown that it can achieve
 great performance improvements over classical systems (see 
\begin_inset CommandInset citation
LatexCommand cite
key "4497502,Krishnamurthy:2009:SSD:1519103.1519105"

\end_inset

).
 SystemT will be discussed in detail in the next chapter.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:IE-Entity"

\end_inset

Entity Extraction
\begin_inset CommandInset label
LatexCommand label
name "sec:Entity-Extraction"

\end_inset


\end_layout

\begin_layout Standard
Named entities are elements of interest in a text.
 Example of entities are person names, street addresses, institutions, countries
, and so on.
 In this section and in the next one, I assume that the output of an extraction
 task is a series of labels inserted into an input text document (that becomes
 
\emph on
annotated
\emph default
), although there are other possible output formats.
\end_layout

\begin_layout Subsection
Rule-based Methods
\end_layout

\begin_layout Standard
Rule-based methods employ sets of predicates that are 
\begin_inset Quotes eld
\end_inset

fired
\begin_inset Quotes erd
\end_inset

 independently.
 When a portion of input text satisfies a predicate, the action associated
 with the predicate is executed.
 A predicate can be represented in the following generic form:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\textrm{"Contextual Pattern}\longrightarrow\textrm{Action"}
\end{equation}

\end_inset

Contextual patterns are a way to identify entities by exploiting their propertie
s or the context in which they are usually met.
 The most common way to express them is the specification of 
\emph on
regular expressions
\emph default
 over tokens of the input.
 Actions mark the entities that have been identified, and might consist
 in storing them in a database or adding delimiters directly in the text.
\end_layout

\begin_layout Standard
Most systems in this category present a 
\emph on
cascaded structure
\emph default
: an input document goes through a series of processing phases, and the
 output of a phase is the input of the next one.
 A famous example is that of 
\emph on
cascading grammars
\emph default
: formal grammars are evaluated in sequence on the input.
\end_layout

\begin_layout Standard
As mentioned before, a contextual pattern seeks for (groups of) tokens that
 have certain 
\emph on
features
\emph default
.
 In the case of entity extraction, features can be classified in the following
 categories:
\end_layout

\begin_layout Itemize
string representation;
\end_layout

\begin_layout Itemize
orthography (e.g., small case, mixed case, number, etc.);
\end_layout

\begin_layout Itemize
part of speech;
\end_layout

\begin_layout Itemize
list of dictionaries they're contained into;
\end_layout

\begin_layout Itemize
annotations obtained in previous phases.
\end_layout

\begin_layout Standard
Rules can be hand-coded by experts or learned through learning algorithms.
 In the second case the goal is to cover each of the entities of interest
 in the training set with at least one rule.
 The obtained rules should have good recall and precision on new input.
 Moreover, when learning a set of rules, we would like to achieve a good
 level of 
\emph on
generalizability
\emph default
, that is: we would like to find the minimum set of rules accounting for
 the maximum portion of training data, with high precision.
 There are two main strategies for rule learning: 
\emph on
bottom-up
\emph default
 (start from very specific rules and make them more and more general) and
 
\emph on
top-down
\emph default
 (start with rules covering all existing instances, then specialize them).
\end_layout

\begin_layout Subsubsection
Example Rules
\end_layout

\begin_layout Standard
For these examples, I use an abstract syntax, which is the same used in
 
\begin_inset CommandInset citation
LatexCommand cite
key "Sarawagi:2008:IE:1498844.1498845"

\end_inset

.
\end_layout

\begin_layout Example
Consider the task of identifying all mentions of ISO standards in a text.
 A rule for this purpose could be:
\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em
\end_layout

\end_inset


\begin_inset Formula 
\begin{multline}
\left(\left\{ \textrm{String}=\textrm{"ISO"}\right\} \left\{ \textrm{String}=\textrm{"/IEC"}\right\} \left\{ \textrm{?}\right\} \left\{ \textrm{String}=\textrm{"/ASTM"}\right\} \left\{ \textrm{?}\right\} \right.\\
\left.\left\{ \textrm{Orthography type}=\textrm{number}\right\} \left\{ \left\{ \textrm{String}=\textrm{":"}\right\} \left\{ \textrm{Orthography type}=\textrm{number}\right\} \right\} \left\{ \textrm{?}\right\} \right)\\
\longrightarrow\textrm{ISO Standards}
\end{multline}

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\end_layout

\begin_layout Example
This rule matches all strings starting with a substring equal to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Quotes eld
\end_inset

ISO
\begin_inset Quotes erd
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, followed by an optional (because of the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left\{ \textrm{?}\right\} $
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

modifier) substring equal to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Quotes eld
\end_inset

/IEC
\begin_inset Quotes erd
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, then a number identifying the particular standard and finally an optional
 number, separated by a colon from the previous one.
 A matched string is added to a set of matches with name 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Quotes eld
\end_inset

ISO Standards
\begin_inset Quotes erd
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Example
Multiple entities can be matched at once.
 Imagine we need to find mentions of (simple) street addresses in a text
 consisting of a street name and a street number.
 A rule that matches the name and number separately could be:
\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula 
\begin{multline}
\left(\left\{ \textrm{Orthography type}=\textrm{mixed case word}\right\} \left\{ \textrm{*}\right\} \right)\textrm{: Name\,}\left(\left\{ \textrm{String}=\textrm{","}\right\} \right)\\
\left(\left\{ \textrm{Orthography type}=\textrm{number}\right\} \right)\textrm{: Number}\\
\longrightarrow\textrm{Street Name}=:\textrm{Name, }\textrm{Street Number}=:\textrm{Number}
\end{multline}

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Statistical Methods
\end_layout

\begin_layout Standard
Statistical methods aim to decompose the source, assigning a label to each
 element in the decomposition.
 We distinguish between three types of statistical models:
\end_layout

\begin_layout Itemize

\emph on
Token-level models
\emph default
: they assign a label to each token of the source.
 Since entities are usually comprised of multiple adjacent tokens, the tags
 used are of the forms 
\begin_inset Quotes eld
\end_inset

entity_begin
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

entity_continue
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

entity_end
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Itemize

\emph on
Segment-level models
\emph default
: they try to find the best segmentation of the source text;
\end_layout

\begin_layout Itemize

\emph on
Grammar-based models: 
\emph default
they use formal grammars, outputting parse trees.
 All the valid parses are considered for an input document, assigning a
 score to each.
 The parse with the highest score is retained.
\end_layout

\begin_layout Standard
I now give a brief description of Token-level Models and Segment-level Models.
 In the following the term 'clue' is used as a synonym of 'feature'.
\end_layout

\begin_layout Subsubsection
Token-Level Models
\begin_inset CommandInset label
LatexCommand label
name "subsec:Token-Level-Models"

\end_inset


\end_layout

\begin_layout Paragraph
Features
\end_layout

\begin_layout Standard
The features that these models exploit are of the form 
\begin_inset Formula 
\begin{equation}
f:\left(\mathbf{x},y,i\right)\longmapsto\mathbb{R}
\end{equation}

\end_inset

where 
\begin_inset Formula $\mathbf{x}$
\end_inset

 is a sequence of tokens, 
\begin_inset Formula $i$
\end_inset

 is a position in 
\begin_inset Formula $\mathbf{x}$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 is a candidate label for the token at 
\begin_inset Formula $i$
\end_inset

.
 We distinguish between these types of features:
\end_layout

\begin_layout Itemize

\emph on
word features
\emph default
;
\end_layout

\begin_layout Itemize

\emph on
orthographic features;
\end_layout

\begin_layout Itemize

\emph on
dictionary lookup features.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\end_inset

Yesterday I watched a movie called 
\begin_inset Quotes eld
\end_inset

The Matrix
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="11">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yesterday
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
watched
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
movie
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
called
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Matrix
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y_{5}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y_{6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y_{7}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y_{8}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y_{9}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y_{10}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:tokenization"

\end_inset

Decomposition of a sentence into a sequence of tokens.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
Consider the sentence shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:tokenization"

\end_inset

 and its corresponding decomposition.
 An example of word feature at position 
\begin_inset Formula $9$
\end_inset

 is
\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula 
\[
f_{1}\left(y,\mathbf{x},i\right)=\left\llbracket x_{i}\textrm{ equals "Matrix"}\right\rrbracket \cdot\left\llbracket y=\textrm{Movie}\right\rrbracket 
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

where 
\begin_inset Formula $\left\llbracket P\right\rrbracket =1$
\end_inset

 if predicate 
\begin_inset Formula $P$
\end_inset

 is true, and 
\begin_inset Formula $0$
\end_inset

 otherwise.
 An orthographic feature might be
\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula 
\[
f_{2}\left(y,\mathbf{x},i\right)=\left\llbracket x_{i}x_{i+1}\textrm{ matches INITIAL\_QUOTE CapsWord}\right\rrbracket \cdot\left\llbracket y=\textrm{Movie}\right\rrbracket .
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\end_layout

\begin_layout Example
Finally, an example of dictionary lookup feature is
\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula 
\[
f_{3}\left(y,\mathbf{x},i\right)=\left\llbracket x_{i}\textrm{ in Movie\_dictionary}\right\rrbracket \cdot\left\llbracket y=\textrm{Movie}\right\rrbracket .
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Models for Labeling Tokens
\end_layout

\begin_layout Standard
The best models are the ones that take into account dependencies between
 tokens, among which we may find:
\end_layout

\begin_layout Itemize

\emph on
ordered classifiers
\emph default
;
\end_layout

\begin_layout Itemize

\emph on
Hidden Markov models;
\end_layout

\begin_layout Itemize

\emph on
Maximum Entropy Taggers;
\end_layout

\begin_layout Itemize

\emph on
Conditional Markov Models;
\end_layout

\begin_layout Itemize

\emph on
Conditional Random Fields 
\emph default
(the state of the art).
\end_layout

\begin_layout Subsubsection
Segment-Level Models
\end_layout

\begin_layout Paragraph
Features
\end_layout

\begin_layout Standard
In these models the label for a segment depends on the properties of its
 tokens and on the previous segment.
 We can describe a segment 
\begin_inset Formula $s_{j}$
\end_inset

 as:
\begin_inset Formula 
\begin{equation}
s_{j}=\left(y_{i},l_{j},u_{j}\right)\label{eq:segment}
\end{equation}

\end_inset

where 
\begin_inset Formula $y_{i}$
\end_inset

 is the proposed label for 
\begin_inset Formula $s_{j}$
\end_inset

 and 
\begin_inset Formula $l_{j},u_{j}$
\end_inset

 are the start and end positions of 
\begin_inset Formula $s_{j}$
\end_inset

.
 Therefore, a feature is of the form:
\begin_inset Formula 
\begin{equation}
f\left(y_{i},y_{i-1},\mathbf{x},l_{j},u_{j}\right)
\end{equation}

\end_inset

where 
\begin_inset Formula $\mathbf{x}$
\end_inset

 is the input sequence of tokens, 
\begin_inset Formula $y_{i-1}$
\end_inset

 is the proposed label for the previous segment and the other symbols are
 defined as for Equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:segment"

\end_inset

.
 Besides token-level features (see Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Token-Level-Models"

\end_inset

), we can exploit the following feature types:
\end_layout

\begin_layout Itemize

\emph on
Similarity to an entity in a database;
\end_layout

\begin_layout Itemize

\emph on
Length of the segment.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\end_inset


\begin_inset Quotes eld
\end_inset

The Matrix
\begin_inset Quotes erd
\end_inset

 by The Wachowski Brothers
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

The Matrix
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
by
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The Wachowski Brothers
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(l_{j},u_{j},y_{i}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1,4,M$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $5,5,O$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $6,8,D$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:segmentation2"

\end_inset

Segmentation of a sentence.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
Consider the sentence in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:segmentation2"

\end_inset

 and its corresponding segmentation, which identifies a movie and a director.
 A basic similarity feature for the director could be:
\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula 
\[
f\left(y_{i},y_{i-1},\mathbf{x},6,8\right)=\left\llbracket x_{6}x_{7}x_{8}\textrm{ appears in a list of movie directors}\right\rrbracket \cdot\left\llbracket y_{i}=\textrm{Director}\right\rrbracket .
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\end_layout

\begin_layout Example
A more realistic feature would make use of some similarity function, rather
 than requiring an exact match.
 An example of length feature is
\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula 
\[
f\left(y_{i},y_{i-1},\mathbf{x},l,u\right)=\left\llbracket u-l=3\right\rrbracket \cdot\left\llbracket y_{i}=\textrm{Director}\right\rrbracket .
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\end_layout

\begin_layout Example
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
There exist also global segmentation models, that try to find the best segmentat
ion of a token sequence by maximizing a target function.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:IE-Relationship"

\end_inset

Relationship Extraction
\end_layout

\begin_layout Standard
When extracting relationships between entities, we might face three types
 of specific tasks:
\end_layout

\begin_layout Enumerate
given a pair of entities, find the relationship between them;
\end_layout

\begin_layout Enumerate
given an entity 
\begin_inset Formula $e$
\end_inset

 and a relationship 
\begin_inset Formula $r$
\end_inset

, find all the other entities 
\begin_inset Formula $e'$
\end_inset

 such that 
\begin_inset Formula $\left(e,e'\right)\in r$
\end_inset

;
\end_layout

\begin_layout Enumerate
given a big and open-ended input and a relationship 
\begin_inset Formula $r$
\end_inset

 find all pairs of entities 
\begin_inset Formula $e',e''$
\end_inset

 such that 
\begin_inset Formula $\left(e',e''\right)\in r$
\end_inset

.
\end_layout

\begin_layout Subsection
Predicting the Relationship Between a Pair of Entities
\end_layout

\begin_layout Standard
For the first task, we can exploit the following resources:
\end_layout

\begin_layout Itemize

\emph on
surface tokens
\emph default
: tokens that are usually placed between entities, which are strong clues;
\end_layout

\begin_layout Itemize

\emph on
part of speech tags 
\emph default
(the most important being 
\emph on
verbs
\emph default
);
\end_layout

\begin_layout Itemize

\emph on
syntactic parse tree
\emph default
: allows grouping words in phrase types, e.g., noun phrases, propositional
 phrases, and so on;
\end_layout

\begin_layout Itemize

\emph on
dependency graph
\emph default
: it is a less expensive structure to compute than the parse tree and it
 links a word to those that depend on it.
\end_layout

\begin_layout Standard
The main methods available to carry out the task are:
\end_layout

\begin_layout Itemize

\emph on
Feature-based methods
\emph default
, that simply transform the clues mentioned above for usage by conventional
 classifier models;
\end_layout

\begin_layout Itemize

\emph on
Kernel-based methods
\emph default
, that use kernel functions to encode the similarity between two graphs;
\end_layout

\begin_layout Itemize

\emph on
Rule-based methods
\emph default
, creating rules over structures around pairs of entities.
\end_layout

\begin_layout Standard
The second task is a special case of the third, and will not be treated
 here.
\end_layout

\begin_layout Subsection
Finding All Possible Entity Pairs Belonging to a Relationship
\end_layout

\begin_layout Standard
The third task can be met especially when dealing with the Web.
 Usually we can exploit the following resources to fulfill it:
\end_layout

\begin_layout Itemize
the 
\emph on
types of arguments
\emph default
 of 
\begin_inset Formula $r$
\end_inset

 (that might need specific recognition patterns);
\end_layout

\begin_layout Itemize
a 
\emph on
seed database
\emph default
 of pairs of entities belonging to 
\begin_inset Formula $r$
\end_inset

;
\end_layout

\begin_layout Itemize

\emph on
manually coded patterns
\emph default
.
\end_layout

\begin_layout Standard
The generic procedure that is used in this case can be described with these
 steps:
\end_layout

\begin_layout Enumerate
Use the seed database to learn the relevant extraction patterns;
\end_layout

\begin_layout Enumerate
Use the obtained patterns to define candidate triples of the form 
\begin_inset Formula $\left(e',e'',r\right)$
\end_inset

;
\end_layout

\begin_layout Enumerate
Retain a subset of the candidate triples, using a statistical test.
\end_layout

\begin_layout Standard
There exist also rule-based methods for the task.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
In this chapter, a high-level introduction to Information Extraction was
 given.
 Examples of applicability were mentioned, the main challenges were highlighted,
 and the two prominent approaches to extraction tasks were described.
\end_layout

\begin_layout Standard
The next chapter focuses on SystemT, a concrete system for rule-based informatio
n extraction.
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:SystemT-and-AQL"

\end_inset

SystemT and AQL
\end_layout

\begin_layout Standard
This chapter contains a description of 
\emph on
SystemT
\emph default
 and its extraction rule language 
\emph on
AQL
\emph default
 (Annotation Query Language), followed by a description of a new formal
 model capable of capturing the core of AQL.
 The model is focused on the concept of 
\emph on
document spanner
\emph default
.
 A document spanner provides a basis for a mathematical description of an
 AQL query.
 Spanners can be associated with formal representations, for which execution
 models can be defined easily.
 This new model is the foundation for the runtime system for the core of
 AQL developed in this thesis.
 This chapter is a re-elaboration from 
\begin_inset CommandInset citation
LatexCommand cite
key "4497502,Krishnamurthy:2009:SSD:1519103.1519105,Fagin:2015:DSF:2772377.2699442"

\end_inset

.
 In particular, the mathematical statements from 
\begin_inset CommandInset ref
LatexCommand ref
reference "first-stat"

\end_inset

 to 
\begin_inset CommandInset ref
LatexCommand ref
reference ".last-stat"

\end_inset

 are taken or adapted from 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

, except for Remarks 
\begin_inset CommandInset ref
LatexCommand ref
reference "first-rem"

\end_inset

 to 
\begin_inset CommandInset ref
LatexCommand ref
reference "last-rem"

\end_inset

, that come from 
\begin_inset CommandInset citation
LatexCommand cite
key "4497502"

\end_inset

.
 Refer to the original sources for more details on the topics that I treat
 in this chapter.
 The figures and examples appearing in this chapter are original, except
 when I explicitly state otherwise.
 The outline of the chapter is as follows.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:AQL-SystemT"

\end_inset

 is a general description of SystemT: its architecture, data model, execution
 model, query operators and optimization techniques are presented.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:AQL-aql"

\end_inset

 contains a brief overview of AQL.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:AQL-vset"

\end_inset

 is an extensive description of the new model: the concept of document spanner
 is defined, then three primitive spanner representations, originally defined
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

, are presented.
 These representations are 
\emph on
regex formulas, variable stack automata, 
\emph default
and 
\emph on
variable set automata.

\emph default
 Subsequently, a series of operators for composing spanners is introduced.
 Finally, some interesting classes of spanners are described.
 These classes are based on the aforementioned primitive spanner representations.
 The spanner class that models the core of AQL is identified, along with
 some convenient classes of spanner representations that can model it.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:AQL-SystemT"

\end_inset

SystemT
\end_layout

\begin_layout Standard
As mentioned in the previous chapter, scalability is now a main concern
 in IE.
 Companies rely on IE for many tasks; a prominent example is 
\emph on
Business Intelligence
\emph default
.
 Unfortunately, many systems developed in the past don't address this issue
 correctly.
 Traditionally, most rule-based system rely on cascading grammars: formal
 grammars are executed in sequence on the input, each grammar representing
 a stage that takes as input the output of the previous one.
 Rules in such grammars are matched using regular expressions: if a part
 of the input text satisfies the regular expression associated with a rule,
 that rule is activated (i.e., 
\begin_inset Quotes eld
\end_inset

fires
\begin_inset Quotes erd
\end_inset

) and the corresponding action is executed.
 Evaluating a grammar on a document tends to be costly, because simply evaluatin
g a single rule might require scanning the whole document.
 On large datasets, the running time becomes enormous (see, for instance,
 
\begin_inset CommandInset citation
LatexCommand cite
key "4497502"

\end_inset

).
 Moreover, these kind of systems are not able to fulfill the expressivity
 requirements of complex extraction tasks.
\end_layout

\begin_layout Standard
SystemT was developed at IBM to address these issues.
 It is based on a new approach to extraction rules: the 
\emph on
algebraic approach
\emph default
.
 According to this approach, data manipulations are viewed as operations
 in a (relational) algebra.
 Extraction tasks are defined using 
\emph on
annotators
\emph default
 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Entity-Extraction"

\end_inset

) whose rules are conceived as 
\emph on
queries
\emph default
 on input documents, that act as virtual databases.
 Complex annotators are obtained by combining simpler ones, using 
\emph on
relational operators
\emph default
.
 By doing so, all the optimization techniques that are typical of relational
 databases become available, but new techniques are possible too, due to
 the characteristics of text documents.
 Another advantage of SystemT is that it is capable of handling 
\emph on
overlapping rule matchings
\emph default
, which are difficult to resolve in cascading grammars, where they typically
 require disambiguation policies that solve the problem only in part.
\end_layout

\begin_layout Standard
I now give an overview of the high-level structure of SystemT.
 Then, I talk about its data model, execution model and algebra.
 For more information on SystemT and AQL, refer to 
\begin_inset CommandInset citation
LatexCommand cite
key "4497502,Krishnamurthy:2009:SSD:1519103.1519105"

\end_inset

.
\end_layout

\begin_layout Subsection
Architecture
\end_layout

\begin_layout Standard
These are the main components of SystemT:
\end_layout

\begin_layout Description
Development
\begin_inset space ~
\end_inset

Environment: allows constructing annotators for extraction tasks.
 Rules are expressed in AQL, and compiled into an algebra.
 It supports an iterative development process.
\end_layout

\begin_layout Description
Optimizer: seeks for the best query plan for an extraction task, evaluating
 the most convenient optimization techniques in a cost-based manner.
\end_layout

\begin_layout Description
Runtime
\begin_inset space ~
\end_inset

Environment: given a query plan, it instantiates the physical operators
 corresponding to the logical ones in the plan, then it proceeds evaluating
 the latter on input documents.
\end_layout

\begin_layout Standard
Once the development of an annotator is complete, it is 
\emph on
published
\emph default
 to the optimizer and runtime.
 After optimization, the runtime evaluates it on a continuous stream of
 documents.
\end_layout

\begin_layout Subsection
Data Model
\begin_inset CommandInset label
LatexCommand label
name "subsec:Data-Model"

\end_inset


\end_layout

\begin_layout Standard
SystemT uses an 
\emph on
object-relational
\emph default
 data model for annotations on a text document, that allows applying logical
 operators over it.
 Operators can be composed.
 There is an important assumption to mention before continuing: an extraction
 task over a set of documents is performed on one document at a time.
 This means that any relationships between entities in different documents
 are disregarded.
 This assumption is crucial to some optimization techniques that SystemT
 uses.
 While there exist tasks where considering these relationships would be
 useful (think of the Web), still a large number of relevant tasks can be
 carried out this way.
 In the following, I report the definitions of the basic data types in the
 data model of SystemT.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\Sigma$
\end_inset

 be a finite alphabet of symbols (characters).
 
\begin_inset Formula $\Sigma^{*}$
\end_inset

 denotes the set of all strings of finite length over 
\begin_inset Formula $\Sigma$
\end_inset

.
 A document is modeled as one such string.
 
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "first-stat"

\end_inset

A document is a string 
\begin_inset Formula $\mathbf{s}\in\Sigma^{*}$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
The most basic data type is the 
\emph on
span
\emph default
.
\end_layout

\begin_layout Definition
Given a string 
\begin_inset Formula $\mathbf{s}=\sigma_{1}...\sigma_{n}$
\end_inset

 where 
\begin_inset Formula $\forall i$
\end_inset

, 
\begin_inset Formula $\sigma_{i}\in\Sigma$
\end_inset

, with length 
\begin_inset Formula $\left|\mathbf{s}\right|=n$
\end_inset

 and whose characters are indexed in the natural way, a span of 
\begin_inset Formula $\mathbf{s}$
\end_inset

 is an interval 
\begin_inset Formula $\left[i,j\right\rangle $
\end_inset

, where 
\begin_inset Formula $i$
\end_inset

, 
\begin_inset Formula $j$
\end_inset

 are indices of 
\begin_inset Formula $\mathbf{s}$
\end_inset

 satisfying 
\begin_inset Formula $1\leq i\leq j\leq n+1$
\end_inset

.
 The substring of 
\begin_inset Formula $\mathbf{s}$
\end_inset

 beginning at 
\begin_inset Formula $i$
\end_inset

 and ending at 
\begin_inset Formula $j-1$
\end_inset

 is denoted as 
\begin_inset Formula $\mathbf{s}_{\left[i,j\right\rangle }$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Spans can be aggregated in 
\emph on
tuples
\emph default
, which are finite sequences of spans
\emph on
.
 
\emph default
To formally define a tuple, we need to introduce some additional concepts
 and notation.
 The first concept is that of 
\emph on
span variable.

\emph default
 A span variable is simply a variable which can be assigned a span.
 Now, let us denote by 
\begin_inset Formula $\textrm{SVars}$
\end_inset

 an infinite set of span variables.
 A tuple is always parametrized by a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

 and a finite subset 
\begin_inset Formula $V$
\end_inset

 of 
\begin_inset Formula $\textrm{SVars}$
\end_inset

.
 We stress this fact by calling a tuple a 
\begin_inset Formula $\left(V,\mathbf{s}\right)$
\end_inset

-tuple.
 Let 
\begin_inset Formula $\textrm{Spans}\left(\mathbf{s}\right)$
\end_inset

 be the set of all possible spans of a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

.
 A 
\begin_inset Formula $\left(V,\mathbf{s}\right)$
\end_inset

-tuple is defined as follows:
\end_layout

\begin_layout Definition
Given a finite set 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $V\subseteq\textrm{SVars}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, and a string 
\begin_inset Formula $\mathbf{s}\in\Sigma^{*}$
\end_inset

, a 
\begin_inset Formula $\left(V,\mathbf{s}\right)$
\end_inset

-tuple is a mapping 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\mu:V\longmapsto\textrm{Spans}\left(\mathbf{s}\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
 When 
\begin_inset Formula $V$
\end_inset

 is clear from the context, we might call 
\begin_inset Formula $\mu$
\end_inset

 simply a 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuple.
\end_layout

\begin_layout Standard
\noindent
In general, a set of tuples is called a 
\emph on
relation.
 
\emph default
Here, we focus on 
\emph on
span relations
\emph default
, which are formally defined as 
\begin_inset Formula $\left(V,\mathbf{s}\right)$
\end_inset

-relations.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "span-relation"

\end_inset

A 
\begin_inset Formula $\left(V,\mathbf{s}\right)$
\end_inset

-relation is a set of 
\begin_inset Formula $\left(V,\mathbf{s}\right)$
\end_inset

-tuples.
 As before, we can speak of 
\begin_inset Formula $\mathbf{s}$
\end_inset

-relation when 
\begin_inset Formula $V$
\end_inset

 is clear.
\end_layout

\begin_layout Standard
\noindent
Each operator in the algebra of SystemT takes one or more span relations
 as input and outputs a single span relation.
\end_layout

\begin_layout Subsection
Execution Model
\begin_inset CommandInset label
LatexCommand label
name "subsec:Execution-Model"

\end_inset


\end_layout

\begin_layout Standard
A single document is conceived as a 
\emph on
local annotation database
\emph default
, to which annotators are applied in order to build 
\emph on
views
\emph default
.
 In general, a local database fits into main memory.
 Local databases are contained in a 
\emph on
global annotation database
\emph default
.
 The runtime of SystemT takes a global database and it annotates its local
 databases.
 The procedure is described by Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Annotating-all-local"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $E\longleftarrow\left\{ \textrm{algebra expression}\right\} $
\end_inset


\end_layout

\begin_layout Plain Layout
for localDB in globalDB do
\end_layout

\begin_layout Plain Layout
begin
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left\{ \textrm{Read localDB into main memory}\right\} $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $R\longleftarrow E\left(\textrm{localDB}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left\{ \textrm{Add \ensuremath{R} to localDB}\right\} $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left\{ \textrm{Write modified localDB to disk}\right\} $
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Annotating-all-local"

\end_inset

Annotating all local databases in a global database (taken from 
\begin_inset CommandInset citation
LatexCommand cite
key "4497502"

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Algebra of Operators 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Algebra-of-Operators"

\end_inset


\end_layout

\begin_layout Standard
The operators of the algebra of SystemT can be classified in three groups:
\end_layout

\begin_layout Itemize

\emph on
relational operators;
\end_layout

\begin_layout Itemize

\emph on
span extraction operators;
\end_layout

\begin_layout Itemize

\emph on
span aggregation operators.
\end_layout

\begin_layout Standard
In addition, there exist some 
\emph on
span selection predicates
\emph default
 that are used for span selection.
\end_layout

\begin_layout Subsubsection
Relational Operators
\end_layout

\begin_layout Standard
Relational operators are the usual operators of relational algebra that
 appear in classical database query plans.
 Important examples are:
\end_layout

\begin_layout Itemize

\emph on
selection
\emph default
 (
\begin_inset Formula $\sigma$
\end_inset

);
\end_layout

\begin_layout Itemize

\emph on
projection 
\emph default
(
\begin_inset Formula $\pi$
\end_inset

);
\end_layout

\begin_layout Itemize

\emph on
Cartesian product 
\emph default
(
\begin_inset Formula $\times$
\end_inset

);
\end_layout

\begin_layout Itemize
Join (
\begin_inset Formula $\bowtie$
\end_inset

);
\end_layout

\begin_layout Itemize

\emph on
Union
\emph default
 (
\begin_inset Formula $\cup$
\end_inset

);
\end_layout

\begin_layout Itemize

\emph on
Intersection
\emph default
 (
\begin_inset Formula $\cap$
\end_inset

).
\end_layout

\begin_layout Subsubsection*
Span Extraction Operators
\end_layout

\begin_layout Standard
Loosely speaking, span extraction operators take a pattern and a document
 as input and output a maximal set of spans that match that pattern.
 There are two main span extraction operators:
\end_layout

\begin_layout Itemize
\noindent
\align left

\emph on
standard
\begin_inset space ~
\end_inset

regular
\begin_inset space ~
\end_inset

expression
\begin_inset space ~
\end_inset

matcher
\begin_inset space ~
\end_inset

(
\begin_inset Formula $\varepsilon_{re}$
\end_inset

)
\emph default
: this operator takes a regular expression 
\begin_inset Formula $r$
\end_inset

 as input and it identifies all non-overlapping matchings of 
\begin_inset Formula $r$
\end_inset

 in the current document, from left to right;
\end_layout

\begin_layout Itemize

\emph on
dictionary
\begin_inset space ~
\end_inset

matcher
\begin_inset space ~
\end_inset

(
\begin_inset Formula $\varepsilon_{d}$
\end_inset

)
\emph default
:
\emph on
 
\emph default
this operator outputs all the spans that match some entry in a given dictionary.
\end_layout

\begin_layout Standard
Although the dictionary matcher might seem useless since there is a regular
 expression matcher, it has some advantages over the latter, as the fact
 that it can find overlapping matchings or that it enforces the semantics
 of word boundaries.
\end_layout

\begin_layout Subsubsection*
Span Aggregation Operators
\end_layout

\begin_layout Standard
Span aggregation operators are used to aggregate spans in a meaningful way.
 They are of two types:
\end_layout

\begin_layout Itemize

\emph on
Consolidation
\emph default
: they are used to coalesce overlapping spans that were matched using patterns
 for the same concept.
 They are: 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000

\emph on
containment
\begin_inset space ~
\end_inset

consolidation
\begin_inset space ~
\end_inset

(
\begin_inset Formula $\varOmega_{c}$
\end_inset

)
\emph default
:
\emph on
 
\emph default
discards a span fully contained into another one.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\emph on
overlap
\begin_inset space ~
\end_inset

consolidation
\begin_inset space ~
\end_inset

(
\begin_inset Formula $\varOmega_{o}$
\end_inset

)
\emph default
: merges any sequence of overlapping spans into a single span.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Block (
\begin_inset Formula $\beta$
\end_inset

)
\emph default
: it matches a series of spans, each at a distance from its neighbor span(s)
 that is not superior to a threshold.
 It is thought to identify regularity, and it is tuned by two parameters:
 a 
\emph on
distance constraint
\emph default
 to control regularity and a 
\emph on
count constraint 
\emph default
that establishes the minimum number of spans in a block.
\end_layout

\begin_layout Subsubsection
Span Selection Predicates
\end_layout

\begin_layout Standard
\noindent
Consider two spans 
\begin_inset Formula $s_{1},s_{2}$
\end_inset

.
 The main span predicates that may be used for selection are the following:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\noindent
\begin_inset Formula $s_{1}\preceq_{d}s_{2}$
\end_inset

 when 
\begin_inset Formula $s_{1},s_{2}$
\end_inset

 do not overlap, 
\begin_inset Formula $s_{1}$
\end_inset

 precedes 
\begin_inset Formula $s_{2}$
\end_inset

 and there are less than 
\begin_inset Formula $d$
\end_inset

 characters between them;
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $s_{1}\simeq s_{2}$
\end_inset

 when the two spans overlap;
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $s_{1}\subset s_{2}$
\end_inset

 when 
\begin_inset Formula $s_{1}$
\end_inset

 is strictly contained in 
\begin_inset Formula $s_{2}$
\end_inset

;
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $s_{1}\subseteq s_{2}$
\end_inset

 when 
\begin_inset Formula $s_{1}$
\end_inset

 is contained in or equals 
\begin_inset Formula $s_{2}$
\end_inset

;
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $s_{1}=s_{2}$
\end_inset

 when 
\begin_inset Formula $s_{1}$
\end_inset

 equals 
\begin_inset Formula $s_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hrule
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Plain Layout

\size tiny
\begin_inset Quotes eld
\end_inset

Yesterday I 
\series bold
watched 'Annie Hall'
\series default
.
 It is about the relationship between a TV writer and his girlfriend, who
 wants to become an actress.
 I really 
\series bold
loved this movie
\series default
.
 Although the 
\series bold
acting wasn't very good 
\series default
sometimes, the 
\series bold
dialogues were smart
\series default
.
 I'd recommend it to anyone.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hrule
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikz[level distance=2cm]  	
\backslash
node[rectangle, draw, align=center] {ReviewInstance 
\backslash

\backslash
 Aggregator}  		child { node[rectangle, draw, align=center] {ReviewPart
 
\backslash

\backslash
 Extractor}  			edge from parent [<-] node[right=1.6cm, pos=1.5, draw=none,
 font=
\backslash
tiny, align=left] {"watched 'Annie Hall'" 
\backslash

\backslash
 "loved this movie" 
\backslash

\backslash
 "acting wasn't very good" 
\backslash

\backslash
 "dialogues were smart"} 			edge from parent [<-] node[right=1.6cm, pos=-0.7,
 draw=none, font=
\backslash
tiny, align=left] {"
\backslash
textbf{watched 'Annie Hall'}.
 
\backslash

\backslash
 It is about...
 
\backslash
textbf{loved this} 
\backslash

\backslash
 
\backslash
textbf{movie}.
 Altough the 
\backslash
textbf{acting} 
\backslash

\backslash
 
\backslash
textbf{wasn't very good}...
 
\backslash

\backslash
 
\backslash
textbf{dialogues were smart}"}  		};
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:high-level"

\end_inset

High-level structure.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikz [level distance=1.6cm, level 3/.style={sibling distance=6em}, level 4/.style={
sibling distance=2em}] 	
\backslash
node {$
\backslash
varOmega_{c}$} 			child { node {$
\backslash
beta$} 				child { node {$
\backslash
cup$} 					child { node {$
\backslash
bowtie_{
\backslash
preceq_{10}}$} 						child { node {$
\backslash
varepsilon_{d}$} edge from parent [<-] node[left,draw=none, font=
\backslash
tiny] {Action} } 						child { node {$
\backslash
varepsilon_{re}$} edge from parent [<-] node[right,draw=none, font=
\backslash
tiny] {Title} } 						edge from parent [<-] node[left, draw=none, font=
\backslash
tiny] {ReviewPart} 					} 					child { node {$
\backslash
bowtie_{
\backslash
preceq_{30}}$} 						child { node {$
\backslash
varepsilon_{d}$} edge from parent [<-] node[left,draw=none, font=
\backslash
tiny] {Aspect} } 						child { node {$
\backslash
varepsilon_{d}$} edge from parent [<-] node[right,draw=none, font=
\backslash
tiny] {Attribute} } 						edge from parent [<-] node[right, draw=none, font=
\backslash
tiny] {ReviewPart} 					} 					child { node {.
 .
 .
 .} edge from parent[draw=none]} 					child { node {$
\backslash
bowtie_{
\backslash
preceq_{30}}$} 						child { node {$
\backslash
varepsilon_{d}$}  edge from parent [<-] node[left,draw=none, font=
\backslash
tiny] {Sentiment} } 						child { node {$
\backslash
varepsilon_{d}$}  edge from parent [<-] node[right,draw=none, font=
\backslash
tiny] {MovieKeyword} } 						edge from parent [<-] node[right, draw=none,
 font=
\backslash
tiny] {ReviewPart} 					} 					edge from parent [<-] node[left, draw=none,
 font=
\backslash
tiny] {ReviewPart} 				} 				edge from parent [<-] node[left, draw=none,
 font=
\backslash
tiny] {ReviewInstance} 			};
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:tree"

\end_inset

Operator tree.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:query1"

\end_inset

 Extraction of informal movie reviews.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Example
Consider the task of extracting informal movie reviews from blog posts.
 A possible annotator to perform the task is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:query1"

\end_inset

.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:high-level"

\end_inset

 shows the high-level structure of the annotator.
 There are two main components: the 
\series bold
ReviewPart
\series default
 module, which extracts the text snippets that are identified as parts of
 a movie review, and the 
\series bold
ReviewInstance
\series default
 module that aggregates adjacent snippets into single blocks of text.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:tree"

\end_inset

 shows the operator tree of the annotator.
 Review parts are extracted by a series of join operators that combine elements
 of basic relations, extracted by running span extractors on the text.
 Subsequently, the block operator aggregates the parts, and review instances
 that are contained into others are discarded.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:AQL-opt"

\end_inset

Optimization Techniques
\end_layout

\begin_layout Standard
As mentioned in the introduction of this chapter, SystemT can make use of
 the optimization techniques from traditional database systems, but there
 exist some peculiar aspects of SystemT and span extraction tasks that enable
 new optimization methods.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "first-rem"

\end_inset

The effect of document-at-a-time processing is that the span relations produced
 and consumed for a single document by operators are very small in size
 and often empty.
\begin_inset CommandInset label
LatexCommand label
name "small-relations"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "runtime-dom"

\end_inset

Evaluating an annotator on a large set of documents is a 
\emph on
CPU-intensive process
\emph default
.
 This is because the running time is by far dominated by the execution of
 the operators 
\begin_inset Formula $\varepsilon_{re}$
\end_inset

 and 
\begin_inset Formula $\varepsilon_{d}$
\end_inset

, that are applied to each document in an input set.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "last-rem"

\end_inset

Spans are nothing but 
\emph on
intervals
\emph default
, so we can exploit 
\emph on
interval algebra
\emph default
.
\begin_inset CommandInset label
LatexCommand label
name "interval-algebra"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
\noindent
With Remark 
\begin_inset CommandInset ref
LatexCommand ref
reference "small-relations"

\end_inset

 and Remark 
\begin_inset CommandInset ref
LatexCommand ref
reference "interval-algebra"

\end_inset

 in mind, running time can be reduced in a number of ways.
 Let us look at them briefly.
\end_layout

\begin_layout Description
Regular
\begin_inset space ~
\end_inset

Expression
\begin_inset space ~
\end_inset

Strength
\begin_inset space ~
\end_inset

Reduction Some classes of regular expressions, as defined in the POSIX standard,
 can be executed by using 
\emph on
specialized engines, 
\emph default
that are able to improve performance.
 For example, an expression that looks for a finite number of strings in
 a text is evaluated more efficiently by a string-matching engine.
\end_layout

\begin_layout Description
Shared
\begin_inset space ~
\end_inset

Dictionary
\begin_inset space ~
\end_inset

Matching
\begin_inset space ~
\end_inset

(SDM) Dictionary lookups are usually very expensive, as we need to consult
 the dictionary thousand of times in a typical setting.
 Instead of evaluating each 
\begin_inset Formula $\varepsilon_{d}$
\end_inset

 operator in an extraction task independently for each input document, it
 is evaluated once and for all at the beginning of the process, and the
 obtained matches are shared among the single documents.
\end_layout

\begin_layout Description
Conditional
\begin_inset space ~
\end_inset

Evaluation
\begin_inset space ~
\end_inset

(CE) As we know, an annotator is evaluated independently on each input document.
 Thus, by employing some heuristic, it can be guessed if a (sub)query will
 give any matches in a document without loss of generality, and in case
 it does not, it is not evaluated on it.
\end_layout

\begin_layout Description
Restricted
\begin_inset space ~
\end_inset

Span
\begin_inset space ~
\end_inset

Extraction
\begin_inset space ~
\end_inset

(RSE) It consists in executing expensive operations on selected regions
 of a document.
 It is used for 
\emph on
join
\emph default
 operators involving a dictionary matching operator in their arguments.
 One input operator is evaluated on the whole document, while the others
 are modified to consider only some neighborhood of the results from the
 first one.
 These neighborhoods are established by some ad hoc heuristic.
\end_layout

\begin_layout Standard
The techniques described allow the use of a 
\emph on
cost-based plan optimizer
\emph default
: in a query plan, the subgraphs suitable for optimization are identified,
 and all the possible optimized plans for them are formulated.
 In the end, the best ones are retained.
 Results of sample experiments on a large dataset are described in 
\begin_inset CommandInset citation
LatexCommand cite
key "4497502,Krishnamurthy:2009:SSD:1519103.1519105"

\end_inset

.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:AQL-aql"

\end_inset

AQL
\end_layout

\begin_layout Standard
AQL is the concrete language used by SystemT to express annotators, designed
 to support the execution model described in Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Execution-Model"

\end_inset

.
 It is a 
\emph on
declarative language
\emph default
 with a syntax very similar to that of SQL.
 It supports all the operators presented in Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Algebra-of-Operators"

\end_inset

.
 When coding an extraction task in AQL, we can build a series of views of
 a document, of progressively higher abstraction level.
 Higher-level views are typically based on lower-level views.
 The content of a view corresponds with annotations in the text.
 An input document is modeled as a view too, which is provided by default.
 The main advantages of AQL are:
\end_layout

\begin_layout Itemize
it allows formulating complex low-level patterns in a declarative fashion;
\end_layout

\begin_layout Itemize
it enables 
\emph on
modularization 
\emph default
and 
\emph on
reuse
\emph default
 of the queries, making development and maintenance of complex high-level
 structures easier.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikz[level distance=2cm]  	
\backslash
node[rectangle, draw, align=left] {--
\backslash
emph{Define a dictionary of actions} 
\backslash

\backslash
 
\backslash
textbf{create} dictionary Action as ('saw', 'watched', ...
 ); 
\backslash

\backslash
 
\backslash

\backslash
 --
\backslash
emph{Use a regular expression to find movie titles} 
\backslash

\backslash
 
\backslash
textbf{create view} Title 
\backslash
textbf{as} 
\backslash

\backslash
 
\backslash
textbf{extract} regex /["'][A-Z]$
\backslash
textbackslash$w+(s+$
\backslash
textbackslash$w+)
\backslash
{0,3
\backslash
}["']/ 
\backslash

\backslash
 
\backslash
 
\backslash
 
\backslash
 
\backslash
textbf{on} D.text 
\backslash

\backslash
 
\backslash
 
\backslash
 
\backslash
 
\backslash
textbf{as} title 
\backslash

\backslash
 
\backslash
textbf{from} Document D; 
\backslash

\backslash
 
\backslash

\backslash
 --
\backslash
emph{A single ReviewPart rule.
 It looks for instances} 
\backslash

\backslash
 --
\backslash
emph{of Action followed within 10 characters by a title} 
\backslash

\backslash
 
\backslash
textbf{create view} ReviewPart 
\backslash
textbf{as} 
\backslash

\backslash
 
\backslash
textbf{select} CombineSpans(A.act, T.title) 
\backslash
textbf{as} part 
\backslash

\backslash
 
\backslash
textbf{from} 
\backslash

\backslash
  
\backslash
 
\backslash
 
\backslash
 (
\backslash
textbf{extract} dictionary 'Action' 
\backslash
textbf{on} D.text 
\backslash
textbf{as} act 
\backslash

\backslash
 
\backslash
 
\backslash
 
\backslash
 
\backslash
 
\backslash
textbf{from} Document D) A, Title T 
\backslash

\backslash
 
\backslash
textbf{where} 
\backslash

\backslash
 
\backslash
 
\backslash
 
\backslash
 Follows(A.act, T.title, 0, 10) 
\backslash

\backslash
 
\backslash
textbf{consolidate on} CombineSpans(A.act, T.title);};
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:AQL"

\end_inset

Parts of the annotator from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:query1"

\end_inset

 expressed in AQL.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
The AQL code in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AQL"

\end_inset

 realizes a join combining an instance of an action related to movies with
 an instance of movie title, which follows the action within 10 characters.
 It is the first join from the left in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:tree"

\end_inset

.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:AQL-vset"

\end_inset

A Model for the Core of AQL
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

, a formal model capturing the core functionality of AQL is described.
 The authors show a way to represent annotators expressed in AQL by means
 of modified finite state automata, namely 
\emph on
variable stack automata
\emph default
 and 
\emph on
variable set automata
\emph default
.
 In this section, I present this model and look at the relative expressive
 power of its main elements.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:AQL-basic"

\end_inset

Basic Definitions
\end_layout

\begin_layout Standard
Let us start with the definition of a language.
\end_layout

\begin_layout Definition
A language L is a subset of 
\begin_inset Formula $\Sigma^{\ast}$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
An important concept is that of regular expressions, which can be defined
 by describing their language.
\end_layout

\begin_layout Definition
Regular expressions over 
\begin_inset Formula $\Sigma$
\end_inset

 are the strings that belong to the language 
\begin_inset Formula $\gamma$
\end_inset

, defined by the following grammar:
\begin_inset Formula 
\begin{equation}
\gamma:=\textrm{Ø}\mid\epsilon\mid\sigma\mid\gamma\vee\gamma\mid\gamma\cdot\gamma\mid\gamma^{\ast}
\end{equation}

\end_inset


\end_layout

\begin_layout Definition
\noindent
where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Ø$
\end_inset

 is the expression matching the empty language;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\epsilon$
\end_inset

 is the empty string;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\sigma\in\Sigma$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\vee$
\end_inset

 is the ordinary disjunction operator;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\cdot$
\end_inset

 is the concatenation operator;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\ast$
\end_inset

 is the Kleene Star operator.
\end_layout

\end_deeper
\begin_layout Standard
\noindent
Additionally, we might use 
\begin_inset Formula $\gamma^{+}$
\end_inset

 as a shortcut for 
\begin_inset Formula $\gamma\cdot\gamma^{\ast}$
\end_inset

, and 
\begin_inset Formula $\Sigma$
\end_inset

 as an abbreviation of 
\begin_inset Formula $\sigma_{1}\vee...\vee\sigma_{n}$
\end_inset

.
 The language 
\begin_inset Formula $\mathcal{L}\left(\gamma\right)$
\end_inset

 of a regular expression 
\begin_inset Formula $\gamma$
\end_inset

 is the set of strings 
\begin_inset Formula $\mathbf{s}$
\end_inset

 over 
\begin_inset Formula $\Sigma$
\end_inset

 that are matched by that expression.
 A language 
\begin_inset Formula $L$
\end_inset

 is 
\emph on
regular
\emph default
 if 
\begin_inset Formula $L=\mathcal{L}\left(\gamma\right)$
\end_inset

 for some regular expression 
\begin_inset Formula $\gamma$
\end_inset

.
 We also need the definition of a 
\emph on
string relation
\emph default
.
\end_layout

\begin_layout Definition
A n-ary string relation is a subset of 
\begin_inset Formula $\left(\Sigma^{\ast}\right)^{n}$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
An interesting class of string relations is that of recognizable relations,
 denoted as 
\begin_inset Formula $\textrm{REC}$
\end_inset

.
\end_layout

\begin_layout Definition
Given a k-ary string relation 
\begin_inset Formula $R$
\end_inset

, 
\begin_inset Formula $R$
\end_inset

 is recognizable if it is representable by a finite union the form:
\begin_inset Formula 
\begin{equation}
\bigcup L_{1}\times...\times L_{k}
\end{equation}

\end_inset


\end_layout

\begin_layout Definition
where each 
\begin_inset Formula $L$
\end_inset


\begin_inset Formula $_{i}$
\end_inset

 is a regular language.
\end_layout

\begin_layout Standard
\noindent
I have already mentioned span relations (Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "span-relation"

\end_inset

).
 They allow giving a precise definition of annotators, by introducing the
 concept of 
\emph on
document spanner
\emph default
.
\end_layout

\begin_layout Definition
Given a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

, a document spanner 
\begin_inset Formula $P$
\end_inset

 is a function that maps 
\begin_inset Formula $\mathbf{s}$
\end_inset

 to a 
\begin_inset Formula $\left(V,\mathbf{s}\right)$
\end_inset

-relation 
\begin_inset Formula $r$
\end_inset

, where 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $V:=\textrm{SVars}\left(P\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
 We say 
\begin_inset Formula $P$
\end_inset

 is n-ary if 
\begin_inset Formula $\left|V\right|=n$
\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textbf{String s}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\backslash
resizebox{
\backslash
textwidth}{!}{
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="27">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row topspace="default" bottomspace="default" interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Quotes eld
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Quotes eld
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
n
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
21
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
23
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
26
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
27
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\backslash
resizebox{.8
\backslash
textwidth}{!}{
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="20">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row topspace="default" bottomspace="default" interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
w
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Quotes eld
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
l
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
l
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Quotes eld
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
29
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
33
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
34
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
35
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
38
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
39
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
41
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
42
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
43
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
44
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
45
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
46
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
47
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula $P\left(\mathbf{s}\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $y$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $z$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\mu_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left[3,10\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left[11,23\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left[3,23\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\mu_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left[32,35\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left[36,48\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left[32,48\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\mu_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left[3,10\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left[36,48\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left[3,48\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:running-ex"

\end_inset

A string 
\begin_inset Formula $\mathbf{s}$
\end_inset

 and the span relation obtained by applying spanner 
\begin_inset Formula $P$
\end_inset

 to 
\begin_inset Formula $\mathbf{s}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Example
Consider the string 
\begin_inset Formula $\mathbf{s}$
\end_inset

, over the alphabet 
\begin_inset Formula $\Sigma=\left\{ \textrm{A, \ldots\ , Z, a, \ldots\ , z, \_, "}\right\} $
\end_inset

, shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:running-ex"

\end_inset

.
 The character 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

'_'
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

can be thought as a space.
 The table shown below 
\begin_inset Formula $\mathbf{s}$
\end_inset

 represents the span relation 
\begin_inset Formula $P\left(\mathbf{s}\right)$
\end_inset

, which is the result of applying the ternary spanner 
\begin_inset Formula $P$
\end_inset

 to 
\begin_inset Formula $\mathbf{s}$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
I now present two special types of spanners, which were originally defined
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

 (see Subsection 2.2, ibid.), and that will be useful later on, when we will
 reason on the relative power of various classes of spanners of interest.
 The first one is that of 
\emph on
hierarchical spanners
\emph default
.
 In order to formulate their definition, we need to say when a 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuple is hierarchical.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "hierarchical-tuple"

\end_inset

Given a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

, a document spanner 
\begin_inset Formula $P$
\end_inset

 and a 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuple 
\begin_inset Formula $\mu\in P\left(\mathbf{s}\right)$
\end_inset

, 
\begin_inset Formula $\mu$
\end_inset

 is hierarchical if, for every 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $x,y\in\textrm{SVars}\left(P\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, one of the following conditions holds:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\mu\left(x\right)\supseteq\mu\left(y\right);$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mu\left(x\right)\subseteq\mu\left(y\right)$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mu\left(x\right)$
\end_inset

 is disjoint from 
\begin_inset Formula $\mu\left(y\right)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\noindent
The definition of 
\emph on
hierarchical spanner
\emph default
 follows.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "hierarchical-spanner"

\end_inset

Given a document spanner 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $P$
\end_inset

 is hierarchical if 
\begin_inset Formula $\forall\mathbf{s}\in\Sigma^{\ast}$
\end_inset

, 
\begin_inset Formula $\forall\mu\in P\left(\mathbf{s}\right)$
\end_inset

, 
\begin_inset Formula $\mu$
\end_inset

 is hierarchical.
\end_layout

\begin_layout Standard
\noindent
The class of hierarchical spanners is denoted by 
\begin_inset Formula $\mathbf{HS}$
\end_inset

.
 The second type of spanners considered is that of 
\emph on
universal spanners
\emph default
.
 Some accessory definitions are needed.
\end_layout

\begin_layout Definition
Given a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

 and a document spanner 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $P$
\end_inset

 is total on 
\begin_inset Formula $\mathbf{s}$
\end_inset

 if 
\begin_inset Formula $P\left(\mathbf{s}\right)$
\end_inset

 consists of all the possible 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuples on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVars}\left(P\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Definition
Given a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

 and a document spanner 
\begin_inset Formula $P$
\end_inset

, 
\begin_inset Formula $P$
\end_inset

 is hierarchically total on 
\begin_inset Formula $\mathbf{s}$
\end_inset

 if 
\begin_inset Formula $P\left(\mathbf{s}\right)$
\end_inset

 consists of all the possible hierarchical 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuples on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVars}\left(P\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\noindent
There are two kinds of universal spanners: the 
\emph on
universal spanner
\emph default
 and the 
\emph on
universal hierarchical spanners
\emph default
.
\end_layout

\begin_layout Definition
Given a finite set of span variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $Y$
\end_inset


\begin_inset Formula $\subseteq\textrm{SVars}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, the universal spanner 
\begin_inset Formula $\Upsilon_{Y}$
\end_inset

 over 
\begin_inset Formula $Y$
\end_inset

 is the unique document spanner 
\begin_inset Formula $P$
\end_inset

 such that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVars}\left(P\right)=Y$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

 and 
\begin_inset Formula $P$
\end_inset

 is total on every string 
\begin_inset Formula $\mathbf{s}\in\Sigma^{\ast}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Definition
Given a finite set of span variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $Y$
\end_inset


\begin_inset Formula $\subseteq\textrm{SVars}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, the universal hierarchical spanner 
\begin_inset Formula $\Upsilon_{Y}^{H}$
\end_inset

 over 
\begin_inset Formula $Y$
\end_inset

 is the unique document spanner 
\begin_inset Formula $P$
\end_inset

 such that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVars}\left(P\right)=Y$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

 and 
\begin_inset Formula $P$
\end_inset

 is hierarchically total on every string 
\begin_inset Formula $\mathbf{s}\in\Sigma^{\ast}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\noindent
The next subsection introduces the basic ways of representing spanners,
 as described in 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Spanner-repr"

\end_inset

Spanner Representations
\end_layout

\begin_layout Standard
We saw, in Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Algebra-of-Operators"

\end_inset

, that the operations used by SystemT and AQL to extract spans relations
 from text are regular expression matching and dictionary matching.
 In the remainder of this dissertation I focus on regular expressions.
 The regular expressions of AQL can be seen as usual regular expressions
 enriched with 
\emph on
capture variables
\emph default
, that are precisely the span variables constituting the span relations
 of Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "span-relation"

\end_inset

.
 In 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

, three types of representations are described, that are able to model this
 kind of modified regular expressions.
 They are:
\end_layout

\begin_layout Itemize

\emph on
regex formulas;
\end_layout

\begin_layout Itemize

\emph on
variable stack automata;
\end_layout

\begin_layout Itemize

\emph on
variable set automata.
\end_layout

\begin_layout Standard
These models are also called 
\emph on
primitive spanner representations
\emph default
.
\end_layout

\begin_layout Subsubsection
Regex Formulas
\end_layout

\begin_layout Standard
In order to define a regex formula, let us introduce the concept of 
\emph on
variable regex.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "vregex"

\end_inset

A variable regex is a regular expression with capture variables that extends
 usual regular expressions in the following way:
\begin_inset Formula 
\begin{equation}
\gamma:=\textrm{Ø}\mid\epsilon\mid\sigma\mid\gamma\vee\gamma\mid\gamma\cdot\gamma\mid\gamma^{\ast}\mid x\left\{ \gamma\right\} \label{eq:language-vregex}
\end{equation}

\end_inset

 where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $x\in\textrm{SVars}$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $x\left\{ \gamma\right\} $
\end_inset

 means that we assign to x the span defined by the string matched by the
 evaluation of 
\begin_inset Formula $\gamma$
\end_inset

 .
\end_layout

\end_deeper
\begin_layout Standard
\noindent
The set of span variables appearing in a variable regex 
\begin_inset Formula $\gamma$
\end_inset

 is called 
\begin_inset Formula $\textrm{SVars}\left(\gamma\right)$
\end_inset

.
 Evaluating a variable regex on a string produces a parse tree over the
 alphabet 
\begin_inset Formula $\Lambda=\Sigma\cup\textrm{SVars}\cup\left\{ \epsilon,\vee,\cdot,\ast\right\} $
\end_inset

.
 A valid parse tree for a variable regex 
\begin_inset Formula $\gamma$
\end_inset

 is called a 
\begin_inset Formula $\gamma$
\end_inset

-parse.
 We accept a variable regex expression only if its parses have exactly one
 occurrence of each of the variables appearing in it, otherwise the variable
 assignment would remain unclear.
 Such an expression is referred to as 
\emph on
functional
\emph default
.
\end_layout

\begin_layout Definition
A variable regex 
\begin_inset Formula $\gamma$
\end_inset

 is functional if 
\begin_inset Formula $\forall\mathbf{s}\in\Sigma^{\ast}$
\end_inset

, 
\begin_inset Formula $\forall\gamma$
\end_inset

-parse 
\begin_inset Formula $t$
\end_inset

 for 
\begin_inset Formula $\mathbf{s}$
\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\forall x\in\textrm{SVars}\left(\gamma\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, 
\begin_inset Formula $x$
\end_inset

 occurs exactly one time in 
\begin_inset Formula $t$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Definition
A regex formula is a functional variable regex.
\end_layout

\begin_layout Standard
\noindent
The spanner represented by a regex formula 
\begin_inset Formula $\gamma$
\end_inset

 may be denoted as 
\begin_inset Formula $\left\llbracket \gamma\right\rrbracket $
\end_inset

.
 We have that 
\begin_inset Formula $\textrm{SVars}\left(\left\llbracket \gamma\right\rrbracket \right)=\textrm{SVars}\left(\gamma\right)$
\end_inset

, and the span relation 
\begin_inset Formula $\left\llbracket \gamma\right\rrbracket \left(\mathbf{s}\right)$
\end_inset

 is the set 
\begin_inset Formula $\left\{ \mu^{p}\mid p\textrm{ is a }\gamma\textrm{-parse for \mathbf{s}}\right\} $
\end_inset

, where 
\begin_inset Formula $\mu^{p}$
\end_inset

 is a tuple defined by a 
\begin_inset Formula $\gamma$
\end_inset

-parse 
\begin_inset Formula $p$
\end_inset

.
 The class of regex formulas is referred to as 
\begin_inset Formula $\textrm{RGX}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\backslash
resizebox{
\backslash
textwidth}{!}{
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikz [level distance=1.2cm] 	
\backslash
node {$
\backslash
cdot$} 	[sibling distance=3cm] 		child[level distance=1cm] { node {$
\backslash
ast$} 			[sibling distance=1.2cm] 			child { node {$
\backslash
vee$} 				child {node[align=center] {
\backslash
textbf{I} 
\backslash

\backslash
 1} } 			} 			child { node {$
\backslash
vee$} 				child {node[align=center] {
\backslash
textbf{
\backslash
_} 
\backslash

\backslash
 2} } 			}			 		} 		child[level distance=2cm] { node {$z$} 			child { node
 {$
\backslash
cdot$} 				[sibling distance=3.8cm] 				child{ node {$x$} 				       [level
 distance = 1cm] 					child {node {$
\backslash
vee$} 						child { node {$
\backslash
cdot$} 							[sibling distance=1.2cm, level distance = 2cm] 							child
 {node[align=center] {
\backslash
textbf{w} 
\backslash

\backslash
 3} } 							child { node[align=center] {
\backslash
textbf{a} 
\backslash

\backslash
 4}} 							child { node[align=center] {
\backslash
textbf{t} 
\backslash

\backslash
 5}} 							child { node[align=center] {
\backslash
textbf{c} 
\backslash

\backslash
 6}} 							child { node[align=center] {
\backslash
textbf{h} 
\backslash

\backslash
 7}} 							child { node[align=center] {
\backslash
textbf{e} 
\backslash

\backslash
 8}} 							child { node[align=center] {
\backslash
textbf{d} 
\backslash

\backslash
 9}} 						} 					} 				} 				child[level distance=1cm]{ node {$+$} 					[level
 distance=1cm] 					child { node {$
\backslash
vee$}  						child { node[align=center] {
\backslash
textbf{
\backslash
_} 
\backslash

\backslash
 10}} 						} 				} 				child{ node {$y$} 					child {node {$
\backslash
cdot$} 						child[sibling distance =1.3cm, level distance=1cm] {  								node[a
lign=center] {
\backslash
textbf{"} 
\backslash

\backslash
 11} 						} 						child[level distance=1.2cm, sibling distance=1.2cm] {node
 {$
\backslash
cdot$} 							child { node {$
\backslash
vee$} 								[level distance=1cm] 								child { node[align=center] {
\backslash
textbf{T} 
\backslash

\backslash
 12}} 							} 							child { node {$
\backslash
ast$} 								[sibling distance=1cm, level distance=1cm] 								child {
 node {$
\backslash
vee$} 									child { node[align=center] {
\backslash
textbf{h} 
\backslash

\backslash
 13}} 								} 								child { node {$
\backslash
vee$} 									child { node[align=center] {
\backslash
textbf{e} 
\backslash

\backslash
 14}} 								} 							} 						} 						child[sibling distance =3.8cm] { node
 {$
\backslash
ast$} 							child {node {$
\backslash
cdot$}  								[sibling distance=1.2cm, level distance=1.2cm] 								child
 { node[align=center] {
\backslash
textbf{
\backslash
_} 
\backslash

\backslash
 15} } 								child { node {$
\backslash
cdot$} 									[sibling distance=1.2cm] 									child { node {$
\backslash
vee$} 										child { node[align=center] {
\backslash
textbf{M} 
\backslash

\backslash
 16}} 									} 									child[level distance=2.5cm, sibling distance=2.2cm]
 { node{$
\backslash
ast$} 										[level distance=1cm, sibling distance=1cm] 										child
 { node {$
\backslash
vee$} 											child { node[align=center] {
\backslash
textbf{a} 
\backslash

\backslash
 17}} 										} 										child { node {$
\backslash
vee$} 											child { node[align=center] {
\backslash
textbf{t} 
\backslash

\backslash
 18}} 										} 										child { node {$
\backslash
vee$} 											child { node[align=center] {
\backslash
textbf{r} 
\backslash

\backslash
 19}} 										} 										child { node {$
\backslash
vee$} 											child { node[align=center] {
\backslash
textbf{i} 
\backslash

\backslash
 20}} 										} 										child { node {$
\backslash
vee$} 											child { node[align=center] {
\backslash
textbf{x} 
\backslash

\backslash
 21}} 										} 									} 								} 						
\end_layout

\begin_layout Plain Layout

							} 						} 						child[sibling distance=2cm] { 							node[align=center]
 {
\backslash
textbf{"} 
\backslash

\backslash
 22} 						} 					} 				} 			} 		} 		child[level distance=1cm] { node {$
\backslash
ast$} 			[sibling distance=1.2cm] 			child { node {$
\backslash
vee$} 				child { node[align=center] {
\backslash
textbf{
\backslash
_} 
\backslash

\backslash
 23}} 			} 			child { node {.
 .
 .} 				edge from parent[draw=none]				 				} 			child { node {$
\backslash
vee$} 				child { node[align=center] {" 
\backslash

\backslash
 47}} 			}		 		};
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:parse"

\end_inset

 A 
\begin_inset Formula $\gamma$
\end_inset

-parse 
\begin_inset Formula $p$
\end_inset

 for string 
\begin_inset Formula $\mathbf{s}$
\end_inset

 (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:running-ex"

\end_inset

).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "ex-rgx"

\end_inset

Consider the variable regex 
\begin_inset Formula $\gamma$
\end_inset

 defined by:
\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula 
\begin{equation}
\Sigma^{\ast}\cdot z\left\{ x\left\{ \gamma_{\textrm{action}}\right\} \cdot\Sigma^{+}\cdot y\left\{ \gamma_{\textrm{title}}\right\} \right\} \cdot\Sigma^{\ast}\label{eq:rgx}
\end{equation}

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\end_layout

\begin_layout Example
where 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\gamma_{\textrm{action}}=\left(\textrm{w}\cdot\textrm{a}\cdot\textrm{t}\cdot\textrm{c}\cdot\textrm{h}\cdot\textrm{e}\cdot\textrm{d}\right)\vee\left(\textrm{s}\cdot\textrm{a}\cdot\textrm{w}\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\gamma_{\textrm{title}}=\textrm{"}\cdot\left(\textrm{A}\vee\ldots\lor\textrm{Z}\right)\cdot\left(\textrm{a}\lor\ldots\lor\textrm{z}\right)^{\ast}\cdot\left(\_\cdot\left(\textrm{A}\vee\ldots\lor\textrm{Z}\right)\cdot\left(\textrm{a}\lor\ldots\lor\textrm{z}\right)^{\ast}\right)^{\ast}\cdot\textrm{"}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
 Notice that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVars}\left(\gamma\right)=\left\{ x,y,z\right\} $
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:parse"

\end_inset

 shows a 
\begin_inset Formula $\gamma$
\end_inset

-parse 
\begin_inset Formula $p$
\end_inset

 for string 
\begin_inset Formula $\mathbf{s}$
\end_inset

 of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:running-ex"

\end_inset

.
 In this parse, each variable contained in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVars}\left(\gamma\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

occurs exactly once.
 It is easy to verify that this holds for every 
\begin_inset Formula $\gamma$
\end_inset

-parse.
 Hence, 
\begin_inset Formula $\gamma$
\end_inset

 is functional.
 We have that 
\begin_inset Formula $\mu^{p}\left(x\right)=\left[3,10\right\rangle $
\end_inset

, 
\begin_inset Formula $\mu^{p}\left(y\right)=\left[11,23\right\rangle $
\end_inset

 and 
\begin_inset Formula $\mu^{p}\left(z\right)=\left[3,23\right\rangle $
\end_inset

, thus 
\begin_inset Formula $\mu^{p}$
\end_inset

 is the 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuple 
\begin_inset Formula $\mu_{1}$
\end_inset

 from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:running-ex"

\end_inset

.
 Finally, considering the span relation 
\begin_inset Formula $P\left(\mathbf{s}\right)$
\end_inset

 (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:running-ex"

\end_inset

), we have that 
\begin_inset Formula $\left\llbracket \gamma\right\rrbracket \left(\mathbf{s}\right)=P\left(\mathbf{s}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
We can be more precise on the characterization of a regex formula.
 In order to do this, let us introduce the notion of 
\emph on
syntactically 
\begin_inset Formula $Y$
\end_inset

-functional 
\emph default
variable regex, 
\begin_inset Formula $Y$
\end_inset

 being a finite subset of 
\begin_inset Formula $\textrm{SVars}$
\end_inset

.
\end_layout

\begin_layout Definition
Given a variable regex 
\begin_inset Formula $\gamma$
\end_inset

, 
\begin_inset Formula $\gamma$
\end_inset

 is syntactically 
\begin_inset Formula $Y$
\end_inset

-functional if at least one of following hold:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\gamma=\emptyset$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\gamma=\epsilon$
\end_inset

 or 
\begin_inset Formula $\gamma=\sigma$
\end_inset

 with 
\begin_inset Formula $\sigma\in\Sigma$
\end_inset

 and 
\begin_inset Formula $Y=\emptyset$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\gamma=\gamma_{1}\vee\gamma_{2}$
\end_inset

, where 
\begin_inset Formula $\gamma_{1},\gamma_{2}$
\end_inset

 are syntactically 
\begin_inset Formula $Y$
\end_inset

-functional variable regexes;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\gamma=\gamma_{1}\cdot\gamma_{2}$
\end_inset

, where 
\begin_inset Formula $\gamma_{1},\gamma_{2}$
\end_inset

 are variable regexes, and there exists a subset 
\begin_inset Formula $Y_{1}$
\end_inset

 of 
\begin_inset Formula $Y$
\end_inset

 such that 
\begin_inset Formula $\gamma_{1}$
\end_inset

 is syntactically 
\begin_inset Formula $Y_{1}$
\end_inset

-functional and 
\begin_inset Formula $\gamma_{2}$
\end_inset

 is syntactically 
\begin_inset Formula $Y_{2}$
\end_inset

-functional, for 
\begin_inset Formula $Y_{2}=Y\setminus Y_{1}$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\gamma=\left(\gamma_{1}\right){}^{\ast}$
\end_inset

, where 
\begin_inset Formula $\gamma_{1}$
\end_inset

 is a variable regex with no variable assignments, and 
\begin_inset Formula $Y=\emptyset$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\gamma=x\left\{ \gamma_{1}\right\} $
\end_inset

, where 
\begin_inset Formula $x\in Y$
\end_inset

 and 
\begin_inset Formula $\gamma_{1}$
\end_inset

 is a syntactically 
\begin_inset Formula $\left(Y\setminus\left\{ x\right\} \right)$
\end_inset

-functional variable regex.
\end_layout

\end_deeper
\begin_layout Standard
It is easy to prove, for a variable regex 
\begin_inset Formula $\gamma$
\end_inset

, the next proposition (by induction on the structure of 
\begin_inset Formula $\gamma$
\end_inset

).
\end_layout

\begin_layout Proposition
Given a variable regex 
\begin_inset Formula $\gamma$
\end_inset

, 
\begin_inset Formula $\gamma$
\end_inset

 is functional if and only if it is syntactically 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVars}\left(\gamma\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

-functional.
 Moreover, whether 
\begin_inset Formula $\gamma$
\end_inset

 is syntactically 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVars}\left(\gamma\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

-functional can be tested in polynomial time.
\end_layout

\begin_layout Standard
This characterization of regex formulas will be useful in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:A-Runtime-System"

\end_inset

, where I will present a formal model of a runtime system for the core of
 AQL, and I will show its applicability.
\end_layout

\begin_layout Subsubsection
Variable Stack Automata
\end_layout

\begin_layout Standard
Variable stack automata (vstk-automata for short) are representations of
 document spanners by means of modified NFAs.
 Basically, a NFA is augmented with a 
\emph on
stack of span variables
\emph default
.
 A variable is pushed on the stack when its corresponding span is opened,
 and popped when it is closed.
 The formal definition of a vstk-automaton follows.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "vstk-aut"

\end_inset

A Variable Stack Automaton is a tuple 
\begin_inset Formula $\left(Q,q_{0},q_{f},\delta\right)$
\end_inset

, where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Q$
\end_inset

 is a finite set of states;
\end_layout

\begin_layout Itemize
\begin_inset Formula $q_{0}\in Q$
\end_inset

 is the initial state;
\end_layout

\begin_layout Itemize
\begin_inset Formula $q_{f}\in Q$
\end_inset

 is the accepting state;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\delta$
\end_inset

 is a finite transition relation, containing triples of the forms 
\begin_inset Formula $\left(q,\sigma,q'\right)$
\end_inset

, 
\begin_inset Formula $\left(q,\epsilon,q'\right)$
\end_inset

, 
\begin_inset Formula $\left(q,x\vdash,q'\right)$
\end_inset

, 
\begin_inset Formula $\left(q,\dashv,q'\right)$
\end_inset

, where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $q,q'\in Q$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\sigma\in\Sigma$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $x\in\textrm{SVars}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\vdash$
\end_inset

 is the push symbol;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\dashv$
\end_inset

 is the pop symbol.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\noindent
Notice that we don't need to specify which variable we want to pop, as it
 is naturally the last that was pushed onto the stack.
 Given a vstk-automaton 
\begin_inset Formula $A$
\end_inset

, the set of variables that appear in its transitions is denoted as 
\begin_inset Formula $\textrm{SVars}\left(A\right)$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\backslash
resizebox{
\backslash
textwidth}{!}{
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\backslash
begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]  
\backslash
node[state,initial]  (q_0)                {};  
\backslash
node[state]          (q_1) [right=of q_0] {};  
\backslash
node[state]          (q_2) [right=of q_1] {}; 
\backslash
node[state]          (q_3) [above right=of q_2] {}; 
\backslash
node[state]          (q_4) [right=of q_3] {}; 
\backslash
node[state]          (q_5) [right=of q_4] {}; 
\backslash
node[state]          (q_6) [right=of q_5] {}; 
\backslash
node[state]          (q_7) [right=of q_6] {}; 
\backslash
node[state]          (q_8) [right=of q_7] {}; 
\backslash
node[state]          (q_9) [right=of q_2,xshift=2.5cm] {}; 
\backslash
node[state]          (q_10) [right=of q_9,xshift=2cm] {}; 
\backslash
node[state]          (q_11) [below right=of q_8] {}; 
\backslash
node[state]          (q_12) [below=of q_11,yshift=-0.3cm] {}; 
\backslash
node[state]          (q_13) [left=of q_12] {}; 
\backslash
node[state]          (q_14) [left=of q_13] {}; 
\backslash
node[state]          (q_15) [left=of q_14] {}; 
\backslash
node[state]          (q_21) [left=of q_15] {}; 
\backslash
node[state]          (q_16) [left=of q_21] {}; 
\backslash
node[state]          (q_17) [below left=of q_16,xshift=2.7cm,yshift=-0.5cm]
 {}; 
\backslash
node[state]          (q_18) [left=of q_17,xshift=-0.8cm] {}; 
\backslash
node[state]          (q_19) [left=of q_16] {}; 
\backslash
node[state,accepting](q_20) [left=of q_19] {};  
\backslash
path[->] (q_0) edge              node        {$z
\backslash
vdash$} (q_1)  		edge [loop above] node        {$
\backslash
Sigma$} ()  	  (q_1) edge 	          node        {$x
\backslash
vdash$} (q_2)  	  (q_2) edge              node        {w} (q_3)  	  (q_2)
 edge              node        {s} (q_9)  	  (q_3) edge              node
        {a} (q_4)  	  (q_4) edge              node        {t} (q_5)  	 
 (q_5) edge              node        {c} (q_6)  	  (q_6) edge          
    node        {h} (q_7)  	  (q_7) edge              node        {e} (q_8)
  	  (q_8) edge              node        {d} (q_11)  	  (q_9) edge     
         node        {a} (q_10)  	  (q_10) edge              node      
  {w} (q_11)  	  (q_11) edge              node        {$
\backslash
dashv$} (q_12)  	  (q_12) edge              node[swap]        {$
\backslash
Sigma$} (q_13)  	  (q_13) edge              node[swap]        {$y
\backslash
vdash$} (q_14)  	  	 edge [loop above] node        {$
\backslash
Sigma$} ()  	  (q_14) edge              node[swap]        {"} (q_15)  	
  (q_15) edge              node[swap]        {A,...,Z} (q_21)  	  (q_16) edge
              node        {
\backslash
_} (q_17)  	  (q_17) edge 		   node        {A,...,Z} (q_18)  	  (q_16) edge
              node[swap]        {"} (q_19)  	  (q_18) edge [loop below]
 node        {a,..,z} () 		 edge 		   node        {$
\backslash
epsilon$} (q_16)  	  (q_19) edge              node[swap]        {$
\backslash
epsilon$} (q_20)  	  	 edge [loop above] node        {$
\backslash
dashv$} ()  	  (q_20) edge [loop above] node        {$
\backslash
Sigma$} ()  	  (q_21) edge [loop above] node        {a,..,z} ()  	  	 edge
 	 	   node        {$
\backslash
epsilon$} (q_16); 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:vstk"

\end_inset

A vstk-automaton 
\begin_inset Formula $A$
\end_inset

 with 
\begin_inset Formula $\left\llbracket A\right\rrbracket =\left\llbracket \gamma\right\rrbracket $
\end_inset

, where 
\begin_inset Formula $\gamma$
\end_inset

 is the regex formula 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rgx"

\end_inset

 (see Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex-rgx"

\end_inset

).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:vstk"

\end_inset

 shows a vstk-automaton 
\begin_inset Formula $A$
\end_inset

.
 Each circle represents a state.
 The double circle is the accepting state.
 A label 
\begin_inset Formula $a$
\end_inset

 on an edge from state 
\begin_inset Formula $q$
\end_inset

 to state 
\begin_inset Formula $q^{'}$
\end_inset

 represents the transition 
\begin_inset Formula $\left(q,a,q^{'}\right)$
\end_inset

.
 A sequence 
\begin_inset Formula $\sigma_{1},\ldots,\sigma_{k}$
\end_inset

 on an edge from 
\begin_inset Formula $q$
\end_inset

 to 
\begin_inset Formula $q^{'}$
\end_inset

 is a shorthand for the 
\begin_inset Formula $k$
\end_inset

 transitions 
\begin_inset Formula $\left(q,\sigma_{1},q^{'}\right),\ldots,\left(q,\sigma_{k},q^{'}\right)$
\end_inset

.
 Assuming 
\begin_inset Formula $\Sigma=\left\{ \sigma_{1},\ldots,\sigma_{l}\right\} $
\end_inset

, the label 
\begin_inset Formula $\Sigma$
\end_inset

 is used in place of 
\begin_inset Formula $\sigma_{1},\ldots,\sigma_{l}$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Next, I report the definitions of a 
\emph on
configuration 
\emph default
and of a 
\emph on
run
\emph default
 of a vstk-automaton, which define its semantics.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "vstk-conf"

\end_inset

Given a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

 with length 
\begin_inset Formula $\left|\mathbf{s}\right|=n$
\end_inset

 and a vstk-automaton 
\begin_inset Formula $A$
\end_inset

 , a configuration of 
\begin_inset Formula $A$
\end_inset

 is a tuple 
\begin_inset Formula $c=\left(q,\overrightarrow{v},Y,i\right)$
\end_inset

, where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $q\in Q$
\end_inset

 is the current state;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\overrightarrow{v}$
\end_inset

 is the current variable stack;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $Y\subseteq\textrm{SVars}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

is the set of available variables (those not already pushed on the stack);
\end_layout

\begin_layout Itemize
\begin_inset Formula $i\in\left\{ 1,...,n+1\right\} $
\end_inset

 is the position of the next character to be read in 
\begin_inset Formula $\mathbf{s}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\noindent
Here, as for regex formulas, we want the variable assignment to be clear,
 so once a variable is pushed on the stack, it is removed from the set of
 available variables, thus it can be pushed only once.
 For the rest, a run of a vstk-automaton is similar to those of ordinary
 NFAs.
\end_layout

\begin_layout Definition
Given a string 
\begin_inset Formula $s$
\end_inset

 and a vstk-automaton 
\begin_inset Formula $A$
\end_inset

, a run 
\begin_inset Formula $\rho$
\end_inset

 of 
\begin_inset Formula $A$
\end_inset

 on 
\begin_inset Formula $s$
\end_inset

 is a sequence of configurations 
\begin_inset Formula $c_{0},...,c_{m}$
\end_inset

 such that:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $c_{0}=\left(q_{0},\epsilon,\textrm{SVars}\left(A\right),1\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\forall j\in\left\{ 0,...,m-1\right\} $
\end_inset

, for 
\begin_inset Formula $c_{j}$
\end_inset

=
\begin_inset Formula $\left(q_{j},\overrightarrow{v_{j}},Y_{j},i_{j}\right)$
\end_inset

, 
\begin_inset Formula $c_{j+1}$
\end_inset

=
\begin_inset Formula $\left(q_{j+1},\overrightarrow{v_{j+1}},Y_{j+1},i_{j+1}\right)$
\end_inset

 one of the following holds:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\overrightarrow{v_{j+1}}=\overrightarrow{v_{j}}$
\end_inset

, 
\begin_inset Formula $Y_{j+1}=Y_{j}$
\end_inset

 and either:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $i_{j+1}=i_{j}+1$
\end_inset

, 
\begin_inset Formula $\left(q_{j},s_{i_{j}},q_{j+1}\right)\in\delta$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $i_{j+1}=i_{j}$
\end_inset

, 
\begin_inset Formula $\left(q_{j},\epsilon,q_{j+1}\right)\in\delta$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $i_{j+1}=i_{j}$
\end_inset

 and for some 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $x\in\textrm{SVars}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

either:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\overrightarrow{v_{j+1}}=\overrightarrow{v_{j}}\cdot x$
\end_inset

, 
\begin_inset Formula $x\in Y_{j}$
\end_inset

, 
\begin_inset Formula $Y_{j+1}=Y_{j}\setminus\left\{ x\right\} $
\end_inset

, 
\begin_inset Formula $\left(q_{j},x\vdash,q_{j+1}\right)\in\delta$
\end_inset

 (
\begin_inset Formula $x$
\end_inset

 is pushed on the stack);
\end_layout

\begin_layout Itemize
\begin_inset Formula $\overrightarrow{v_{j}}=\overrightarrow{v_{j+1}}\cdot x$
\end_inset

, 
\begin_inset Formula $Y_{j+1}=Y_{j}$
\end_inset

, 
\begin_inset Formula $\left(q_{j},\dashv,q_{j+1}\right)\in\delta$
\end_inset

 (the variable on top of the stack is popped).
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Definition
Given a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

 with length 
\begin_inset Formula $\left|\mathbf{s}\right|=n$
\end_inset

 and a vstk-automaton 
\begin_inset Formula $A$
\end_inset

, a run 
\begin_inset Formula $\rho=c_{0},...,c_{m}$
\end_inset

 of 
\begin_inset Formula $A$
\end_inset

 on 
\begin_inset Formula $\mathbf{s}$
\end_inset

 is accepting if 
\begin_inset Formula $c_{m}=\left(q_{f},\epsilon,\emptyset,n+1\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
The set of all possible accepting runs of a vstk-automaton 
\begin_inset Formula $A$
\end_inset

 on a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

 is denoted as 
\begin_inset Formula $\textrm{ARuns}\left(A,\mathbf{s}\right)$
\end_inset

.
 The spanner represented by 
\begin_inset Formula $A$
\end_inset

 may be referred to as 
\begin_inset Formula $\left\llbracket A\right\rrbracket $
\end_inset

.
 We have that 
\begin_inset Formula $\textrm{SVars}\left(\left\llbracket A\right\rrbracket \right)=\textrm{SVars}\left(A\right)$
\end_inset

, and the span relation 
\begin_inset Formula $\left\llbracket A\right\rrbracket \left(\mathbf{s}\right)$
\end_inset

 is the set 
\begin_inset Formula $\left\{ \mu^{\rho}\mid\rho\in\textrm{ARuns}\left(A,\mathbf{s}\right)\right\} $
\end_inset

, where 
\begin_inset Formula $\mu^{\rho}$
\end_inset

 is a tuple defined by a run 
\begin_inset Formula $\rho$
\end_inset

.
 In particular, for every variable 
\begin_inset Formula $x\in\textrm{SVars}\left(A\right)$
\end_inset

, 
\begin_inset Formula $\mu^{\rho}\left(x\right)$
\end_inset

 is the span 
\begin_inset Formula $\left[i_{b},i_{e}\right\rangle $
\end_inset

, where:
\end_layout

\begin_layout Itemize
\begin_inset Formula $c_{b}$
\end_inset

=
\begin_inset Formula $\left(q_{b},\overrightarrow{v_{b}},Y_{b},i_{b}\right)$
\end_inset

 is the unique configuration of 
\begin_inset Formula $\rho$
\end_inset

 where 
\begin_inset Formula $x$
\end_inset

 appears in the stack for the first time;
\end_layout

\begin_layout Itemize
\begin_inset Formula $c_{e}$
\end_inset

=
\begin_inset Formula $\left(q_{e},\overrightarrow{v_{e}},Y_{e},i_{e}\right)$
\end_inset

 is the unique configuration of 
\begin_inset Formula $\rho$
\end_inset

 where 
\begin_inset Formula $x$
\end_inset

 appears in the stack for the last time.
\end_layout

\begin_layout Standard
\noindent
The class of variable stack automata is called 
\begin_inset Formula $\textrm{VA}_{\textrm{stk}}$
\end_inset

.
\end_layout

\begin_layout Example
Consider the regex formula 
\begin_inset Formula $\gamma$
\end_inset

 from Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex-rgx"

\end_inset

 and the vstk-automaton 
\begin_inset Formula $A$
\end_inset

 from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:vstk"

\end_inset

.
 We have that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVars}\left(A\right)=\left\{ x,y,z\right\} $
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
 The reader can verify that 
\begin_inset Formula $\left\llbracket \gamma\right\rrbracket =\left\llbracket A\right\rrbracket $
\end_inset

.
\end_layout

\begin_layout Subsubsection
Variable Set Automata
\end_layout

\begin_layout Standard
Variable Set Automata (vset-automata for short) are another model for representi
ng document spanners that is based on NFAs.
 Vset-automata are defined in a very similar way to that of vstk-automata.
 The main differences are:
\end_layout

\begin_layout Itemize
the stack of span variables is replaced by a 
\emph on
set;
\end_layout

\begin_layout Itemize
no order is defined on the variables in the set, so when we want to remove
 a variable from it, we need to specify which one.
\end_layout

\begin_layout Standard
The following is the formal definition of a vset-automaton.
\end_layout

\begin_layout Definition
A variable set automaton is a tuple 
\begin_inset Formula $\left(Q,q_{0},q_{f},\delta\right)$
\end_inset

, where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Q$
\end_inset

, 
\begin_inset Formula $q_{0}$
\end_inset

 and 
\begin_inset Formula $q_{f}$
\end_inset

 are defined as in Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "vstk-aut"

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\delta$
\end_inset

 is the same as in Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "vstk-aut"

\end_inset

, except that it has triples of the form 
\begin_inset Formula $\left(q,\dashv x,q'\right)$
\end_inset

, with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $x\in\textrm{SVars}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, instead of those of the form 
\begin_inset Formula $\left(q,\dashv,q'\right)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\noindent
We also need to slightly modify the definitions of configuration and run
 with respect to those of a vstk-automaton.
\end_layout

\begin_layout Definition
Given a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

 with length 
\begin_inset Formula $\left|\mathbf{s}\right|=n$
\end_inset

 and a vset-automaton 
\begin_inset Formula $A$
\end_inset

 , a configuration of 
\begin_inset Formula $A$
\end_inset

 is a tuple 
\begin_inset Formula $c=\left(q,V,Y,i\right)$
\end_inset

, where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $q$
\end_inset

, 
\begin_inset Formula $i$
\end_inset

 are defined as in Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "vstk-conf"

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $V\subseteq\textrm{SVars}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

is the active variable set;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $Y\subseteq\textrm{SVars}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

is the set of available variables (those not already inserted in the set).
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Definition
Given a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

 and a vset-automaton 
\begin_inset Formula $A$
\end_inset

, a run 
\begin_inset Formula $\rho$
\end_inset

 of 
\begin_inset Formula $A$
\end_inset

 on 
\begin_inset Formula $\mathbf{s}$
\end_inset

 is a sequence of configurations 
\begin_inset Formula $c_{0},...,c_{m}$
\end_inset

 such that:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $c_{0}=\left(q_{0},\emptyset,\textrm{SVars}\left(A\right),1\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\forall j\in\left\{ 0,...,m-1\right\} $
\end_inset

, for 
\begin_inset Formula $c_{j}$
\end_inset

=
\begin_inset Formula $\left(q_{j},V_{j},Y_{j},i_{j}\right)$
\end_inset

, 
\begin_inset Formula $c_{j+1}$
\end_inset

=
\begin_inset Formula $\left(q_{j+1},V_{j+1},Y_{j+1},i_{j+1}\right)$
\end_inset

 one of the following holds:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $V_{j+1}=V_{j}$
\end_inset

, 
\begin_inset Formula $Y_{j+1}=Y_{j}$
\end_inset

 and either:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $i_{j+1}=i_{j}+1$
\end_inset

, 
\begin_inset Formula $\left(q_{j},s_{i_{j}},q_{j+1}\right)\in\delta$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $i_{j+1}=i_{j}$
\end_inset

, 
\begin_inset Formula $\left(q_{j},\epsilon,q_{j+1}\right)\in\delta$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $i_{j+1}=i_{j}$
\end_inset

 and for some 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $x\in\textrm{SVars}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

either:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $x\in Y_{j}$
\end_inset

, 
\begin_inset Formula $V_{j+1}=V_{j}\cup\left\{ x\right\} $
\end_inset

, 
\begin_inset Formula $Y_{j+1}=Y_{j}\setminus\left\{ x\right\} $
\end_inset

, 
\begin_inset Formula $\left(q_{j},x\vdash,q_{j+1}\right)\in\delta$
\end_inset

 (
\begin_inset Formula $x$
\end_inset

 is inserted into the active set);
\end_layout

\begin_layout Itemize
\begin_inset Formula $x\in V_{j}$
\end_inset

, 
\begin_inset Formula $V_{j+1}=V_{j}\setminus\left\{ x\right\} $
\end_inset

, 
\begin_inset Formula $Y_{j+1}=Y_{j}$
\end_inset

, 
\begin_inset Formula $\left(q_{j},\dashv x,q_{j+1}\right)\in\delta$
\end_inset

 (
\begin_inset Formula $x$
\end_inset

 is removed from the active set).
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Definition
Given a string with length 
\begin_inset Formula $\left|\mathbf{s}\right|=n$
\end_inset

 and a vset-automaton 
\begin_inset Formula $A$
\end_inset

, a run 
\begin_inset Formula $\rho=c_{0},...,c_{m}$
\end_inset

 of 
\begin_inset Formula $A$
\end_inset

 on 
\begin_inset Formula $\mathbf{s}$
\end_inset

 is accepting if 
\begin_inset Formula $c_{m}=\left(q_{f},\emptyset,\emptyset,n+1\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Given a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

 and a vset-automaton 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $\textrm{ARuns}\left(A,\mathbf{s}\right)$
\end_inset

 and 
\begin_inset Formula $\left\llbracket A\right\rrbracket $
\end_inset

 are defined as for vstk-automata.
 The class of variable set automata is called 
\begin_inset Formula $\textrm{VA}_{\textrm{set}}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto]  
\backslash
node[state,initial,accepting]  (q_0)                      {};  
\backslash
path[->] (q_0) edge [loop above] node        {$
\backslash
Sigma$} () 	        edge [loop below] node[align=center]        {$y_{1}
\backslash
vdash,
\backslash
ldots y_{m}
\backslash
vdash,$ 
\backslash

\backslash
 $
\backslash
dashv y_{1},
\backslash
ldots 
\backslash
dashv y_{m}$} (); 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:vset"

\end_inset

A vset-automaton 
\begin_inset Formula $B$
\end_inset

 with 
\begin_inset Formula $\left\llbracket B\right\rrbracket =\Upsilon_{Y}$
\end_inset

, for 
\begin_inset Formula $Y=\left\{ y_{1},\ldots,y_{m}\right\} $
\end_inset

 (Figure 2b , 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "vset"

\end_inset

Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:vset"

\end_inset

 shows a vset-automaton 
\begin_inset Formula $B$
\end_inset

, with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVars}\left(B\right)=Y$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, where 
\begin_inset Formula $Y=\left\{ y_{1},\ldots,y_{m}\right\} $
\end_inset

.
 We have that 
\begin_inset Formula $\left\llbracket B\right\rrbracket =\Upsilon_{Y}$
\end_inset

.
 This example shows that vset-automata can express spanners that regex formulas
 and vstk-automata cannot.
 (Example 3.12, 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

).
\end_layout

\begin_layout Standard
The next subsection describes a series of operators with can be used to
 combine spanners.
\end_layout

\begin_layout Subsection
Algebras of Spanners
\begin_inset CommandInset label
LatexCommand label
name "subsec:Algebras-of-Spanners"

\end_inset


\end_layout

\begin_layout Standard
Besides mere span extraction, AQL offers the capability to combine, transform
 and filter extracted tuples by using a series of operators.
 Here, I list the algebraic operators for spanners, described in 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

, that are considered to capture the core algebraic operations of AQL.
 They are:
\end_layout

\begin_layout Itemize

\emph on
Union 
\emph default
(
\begin_inset Formula $\cup$
\end_inset

);
\end_layout

\begin_layout Itemize

\emph on
Projection 
\emph default
(
\begin_inset Formula $\pi$
\end_inset

);
\end_layout

\begin_layout Itemize

\emph on
Natural Join
\emph default
 (
\begin_inset Formula $\bowtie$
\end_inset

);
\end_layout

\begin_layout Itemize

\emph on
String Selection
\emph default
 (
\begin_inset Formula $\varsigma$
\end_inset

).
\end_layout

\begin_layout Standard
A finite set of spanner operators forms a 
\emph on
spanner algebra
\emph default
.
 In the following, I look at the definitions of the listed spanner operators.
\end_layout

\begin_layout Subsubsection
Union
\end_layout

\begin_layout Standard
Before giving the definition of the union operator, we need to introduce
 the concept of 
\emph on
union-compatible spanners.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "union-comp"

\end_inset

Given two document spanners 
\begin_inset Formula $P_{1}$
\end_inset

 and 
\begin_inset Formula $P_{2}$
\end_inset

, they are union-compatible if and only if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVars}\left(P_{1}\right)=\textrm{SVars}\left(P_{2}\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\noindent
The definition of union of two spanners is as follows.
\end_layout

\begin_layout Definition
Given two union-compatible document spanners 
\begin_inset Formula $P_{1}$
\end_inset

 and 
\begin_inset Formula $P_{2}$
\end_inset

, their union is the spanner denoted as 
\begin_inset Formula $P_{1}\cup P_{2}$
\end_inset

, for which we have that:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVars}\left(P_{1}\cup P_{2}\right)=\textrm{SVars}\left(P_{1}\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
given a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

, 
\begin_inset Formula $\left(P_{1}\cup P_{2}\right)\left(\mathbf{s}\right)=P_{1}\left(\mathbf{s}\right)\cup P_{2}\left(\mathbf{s}\right)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Subsubsection
Projection
\end_layout

\begin_layout Definition
Given a document spanner 
\begin_inset Formula $P$
\end_inset

 and a set of span variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $Y\subseteq\textrm{SVars}\left(P\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, the projection of 
\begin_inset Formula $P$
\end_inset

 over 
\begin_inset Formula $Y$
\end_inset

 is the spanner denoted as 
\begin_inset Formula $\pi_{Y}P$
\end_inset

, satisfying 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVars}\left(\pi_{Y}P\right)=Y$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, where, for every string 
\begin_inset Formula $\mathbf{s}$
\end_inset

, 
\begin_inset Formula $\pi_{Y}P\left(\mathbf{s}\right)$
\end_inset

 is obtained by reducing the domain of each 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuple belonging to 
\begin_inset Formula $P\left(\mathbf{s}\right)$
\end_inset

 to 
\begin_inset Formula $Y$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Natural Join
\end_layout

\begin_layout Definition
Given two document spanners 
\begin_inset Formula $P_{1}$
\end_inset

 and 
\begin_inset Formula $P_{2}$
\end_inset

, their natural join is the spanner denoted as 
\begin_inset Formula $P_{1}\bowtie P_{2}$
\end_inset

, for which we have that:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVars}\left(P_{1}\bowtie P_{2}\right)=\textrm{SVars}\left(P_{1}\right)\cup\textrm{SVars}\left(P_{2}\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
given a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

, 
\begin_inset Formula $\left(P_{1}\bowtie P_{2}\right)\left(\mathbf{s}\right)$
\end_inset

 consists of every 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuple 
\begin_inset Formula $\mu$
\end_inset

 for which there exists a pair of tuples 
\begin_inset Formula $\mu_{1}\in P_{1}\left(\mathbf{s}\right)$
\end_inset

,
\begin_inset Formula $\mu_{2}\in P_{2}\left(\mathbf{s}\right)$
\end_inset

, such that 
\begin_inset Formula $\mu_{1}$
\end_inset

 and 
\begin_inset Formula $\mu_{2}$
\end_inset

 assign the same spans to the span variables they have in common.
 Note that this implies that 
\begin_inset Formula $\mu_{1},\mu_{2}$
\end_inset

 agree on variables that are common to 
\begin_inset Formula $P_{1},P_{2}$
\end_inset

: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\forall x\in\textrm{SVars}\left(P_{1}\right)\cap\textrm{SVars}\left(P_{2}\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, 
\begin_inset Formula $\mu_{1}\left(x\right)=\mu_{2}\left(x\right)$
\end_inset

.
 
\end_layout

\end_deeper
\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "join-ex"

\end_inset

Consider again the regex formula 
\begin_inset Formula $\gamma$
\end_inset

 from Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "ex-rgx"

\end_inset

.
 The reader can verify that 
\begin_inset Formula $\gamma$
\end_inset

 can be expressed as:
\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula 
\begin{equation}
\left(\Sigma^{\ast}\cdot x\left\{ \gamma_{\textrm{action}}\right\} \cdot\Sigma^{\ast}\right)\bowtie\left(\Sigma^{\ast}\cdot y\left\{ \gamma_{\textrm{title}}\right\} \cdot\Sigma^{\ast}\right)\bowtie\left(\Sigma^{\ast}\cdot z\left\{ x\left\{ \Sigma^{+}\right\} \cdot\Sigma^{+}\cdot y\left\{ \Sigma^{+}\right\} \right\} \cdot\Sigma^{\ast}\right)
\end{equation}

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
String Selection
\end_layout

\begin_layout Definition
Given a document spanner 
\begin_inset Formula $P$
\end_inset

 and a k-ary string relation 
\begin_inset Formula $R$
\end_inset

, the string selection operation according to 
\begin_inset Formula $R$
\end_inset

 is denoted as 
\begin_inset Formula $\varsigma^{R}$
\end_inset

, and is parametrized by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $x_{1},...,x_{k}\in\textrm{SVars}\left(P\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
 We have that, given a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

 and a spanner 
\begin_inset Formula $P':=\varsigma_{x_{1},...,x_{k}}^{R}P$
\end_inset

, 
\begin_inset Formula $P'\left(\mathbf{s}\right)$
\end_inset

 consists of all the 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuples 
\begin_inset Formula $\mu\in P\left(\mathbf{s}\right)$
\end_inset

 such that 
\begin_inset Formula $\left(\mathbf{s}_{\mu\left(x_{1}\right)},...,\mathbf{s}_{\mu\left(x_{k}\right)}\right)\in R$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
In the remainder of this dissertation, the only string selection operator
 considered is 
\begin_inset Formula $\varsigma_{x,y}^{=}$
\end_inset

 which, given a spanner 
\begin_inset Formula $P$
\end_inset

, restricts 
\begin_inset Formula $P\left(\mathbf{s}\right)$
\end_inset

 to those 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuples that satisfy 
\begin_inset Formula $\mathbf{s}_{\mu\left(x\right)}=\mathbf{s}_{\mu\left(y\right)}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
At this point, we have defined three models to represent spanners and a
 series of operators to combine spanners.
 The question we might want to ask now is: what is the most convenient way
 to represent an AQL query containing only core operations? As we will see,
 this question is not trivial, because if we try and combine the elements
 we have seen in different ways, we might obtain different classes of spanners.
 To answer our question, we will formally define the class of spanners that
 captures the core of AQL, i.e.
 the 
\emph on
core spanners, 
\emph default
and we will identify those classes of spanner representations that can model
 it, by reasoning on the relative expressive power of some relevant spanner
 classes.
\end_layout

\begin_layout Standard
\noindent
Before beginning, let us introduce some additional notation.
 Given a generic class of spanner representations 
\begin_inset Formula $\textrm{SR}$
\end_inset

, the set of all the spanners that can be represented by 
\begin_inset Formula $\textrm{SR}$
\end_inset

 is denoted as 
\begin_inset Formula $\left\llbracket \textrm{SR}\right\rrbracket $
\end_inset

.
 Formally, we have that 
\begin_inset Formula $\left\llbracket \textrm{SR}\right\rrbracket =\left\{ \left\llbracket r\right\rrbracket \mid r\in\textrm{SR}\right\} $
\end_inset

.
 Let 
\begin_inset Formula $O$
\end_inset

 be a spanner algebra.
 Let us denote by 
\begin_inset Formula $\textrm{SR}^{O}$
\end_inset

 the closure of 
\begin_inset Formula $\textrm{SR}$
\end_inset

 under 
\begin_inset Formula $O$
\end_inset

, that is: the class of spanner representations obtained by applying (compositio
ns of) operators contained in 
\begin_inset Formula $O$
\end_inset

 to the representations in 
\begin_inset Formula $\textrm{SR}$
\end_inset

.
 The corresponding set of spanners is referred to as 
\begin_inset Formula $\left\llbracket \textrm{SR}^{O}\right\rrbracket $
\end_inset

.
 We can now start looking for an answer to our current question.
 In the following, many mathematical statements will be formulated, without
 proving them.
 The reader can refer to 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

 for the missing proofs, in particular to Chapter 4.
 
\end_layout

\begin_layout Proposition
The following hold:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
every document spanner represented in the classes 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{RGX}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{VA}_{\textrm{stk}}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

is hierarchical, that is: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left\llbracket \textrm{\textrm{RGX}}\right\rrbracket ,\left\llbracket \textrm{\textrm{VA}_{\textrm{stk}}}\right\rrbracket \subseteq\mathbf{HS}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\end_layout

\begin_layout Enumerate
there exist some spanners represented in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{VA}_{\textrm{set}}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

that are not hierarchical: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left\llbracket \textrm{\textrm{VA}_{set}}\right\rrbracket \nsubseteq\mathbf{HS}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

(see, e.g., Example 
\begin_inset CommandInset ref
LatexCommand ref
reference "vset"

\end_inset

);
\end_layout

\begin_layout Enumerate
the operators 
\begin_inset Formula $\cup$
\end_inset

, 
\begin_inset Formula $\pi$
\end_inset

, 
\begin_inset Formula $\varsigma^{R}$
\end_inset

 preserve the property of being hierarchical, while 
\begin_inset Formula $\bowtie$
\end_inset

 does not, thus we have that:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
given a class of spanner representations 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SR}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left\llbracket \textrm{SR}\right\rrbracket \subseteq\mathbf{HS}\Rightarrow\left\llbracket \textrm{SR}^{\left\{ \cup,\pi,\varsigma^{R}\right\} }\right\rrbracket \subseteq\mathbf{HS}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\end_layout

\begin_layout Enumerate
there exist two hierarchical spanners 
\begin_inset Formula $P_{1},P_{2}$
\end_inset

 such that 
\begin_inset Formula $P_{1}\bowtie P_{2}\notin\mathbf{HS}$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\noindent
In the next Subsection, I discuss the class of 
\emph on
regular spanners
\emph default
, which plays a central role in the construction of the class of core spanners.
\end_layout

\begin_layout Subsection
Regular Spanners
\end_layout

\begin_layout Standard
A regular spanner is defined as follows.
\end_layout

\begin_layout Definition
A spanner is regular if it can be defined by a vset-automaton.
\end_layout

\begin_layout Standard
\noindent
Let us see how regular spanners are related to the other basic spanner classes.
 A preliminary result is that regex formulas and vstk-automata have the
 same expressive power.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name ".rgx=vstk"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left\llbracket \textrm{\textrm{RGX}}\right\rrbracket =\left\llbracket \textrm{\textrm{VA}_{\textrm{stk}}}\right\rrbracket $
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\noindent
It turns out that the spanners expressed by representations in 
\begin_inset Formula $\textrm{\textrm{VA}_{\textrm{stk}}}$
\end_inset

 (
\begin_inset Formula $\textrm{\textrm{RGX}}$
\end_inset

) are exactly those that are both regular and hierarchical.
\end_layout

\begin_layout Theorem
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left\llbracket \textrm{\textrm{VA}_{\textrm{stk}}}\right\rrbracket =\left\llbracket \textrm{\textrm{VA}_{\textrm{set}}}\right\rrbracket \cap\mathbf{HS}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\noindent
For what concerns the algebraic operators presented in Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Algebras-of-Spanners"

\end_inset

, it can be shown that union, projection and natural join don't increase
 the expressive power of regular spanners.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name ".setext=set"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left\llbracket \textrm{\textrm{VA}_{\textrm{set}}}^{\left\{ \cup,\pi,\bowtie\right\} }\right\rrbracket =\left\llbracket \textrm{\textrm{VA}_{\textrm{set}}}\right\rrbracket $
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\noindent
On the other hand, applying the same operators to the spanner representations
 in 
\begin_inset Formula $\textrm{\textrm{VA}_{\textrm{stk}}}$
\end_inset

 results in a class equivalent to regular spanners.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name ".stkext=set"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left\llbracket \textrm{\textrm{VA}_{\textrm{stk}}}^{\left\{ \cup,\pi,\bowtie\right\} }\right\rrbracket =\left\llbracket \textrm{\textrm{VA}_{\textrm{set}}}\right\rrbracket $
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\noindent
Let us now look at which string relations can be simulated by regular spanners,
 starting with the concept of 
\emph on
selectable string relation
\emph default
.
\end_layout

\begin_layout Definition
Given a string relation 
\begin_inset Formula $R$
\end_inset

 and a class of spanners 
\begin_inset Formula $C$
\end_inset

, 
\begin_inset Formula $R$
\end_inset

 is selectable by 
\begin_inset Formula $C$
\end_inset

 if for every document spanner 
\begin_inset Formula $P\in C$
\end_inset

 and for every 
\begin_inset Formula $\overrightarrow{x}=x_{1},...,x_{k}$
\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $x_{i}\in\textrm{SVars}\left(P\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, we have that 
\begin_inset Formula $\varsigma_{\overrightarrow{x}}^{R}P\in C$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Let us introduce the concept of 
\emph on
restricted universal spanner.
\end_layout

\begin_layout Definition
Given a string relation 
\begin_inset Formula $R$
\end_inset

 and a sequence of variables
\begin_inset Formula $\overrightarrow{x}=x_{1},...,x_{k}$
\end_inset

 with their corresponding set 
\begin_inset Formula $X=\left\{ x_{1},...,x_{k}\right\} $
\end_inset

, the 
\begin_inset Formula $R$
\end_inset

-restricted universal spanner over 
\begin_inset Formula $\overrightarrow{x}$
\end_inset

 is 
\begin_inset Formula $\Upsilon_{\overrightarrow{x}}^{R}:=\varsigma_{\overrightarrow{x}}^{R}\Upsilon_{X}$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Selectability of a string relation 
\begin_inset Formula $R$
\end_inset

 by a class of spanners 
\begin_inset Formula $C$
\end_inset

 corresponds to the presence in 
\begin_inset Formula $C$
\end_inset

 of all the possible 
\begin_inset Formula $R$
\end_inset

-restricted universal spanners, under some conditions.
\end_layout

\begin_layout Proposition
Given a string relation 
\begin_inset Formula $R$
\end_inset

 and a class of spanners 
\begin_inset Formula $C$
\end_inset

 containing all the possible universal spanners and closed under natural
 join, 
\begin_inset Formula $R$
\end_inset

 is selectable by 
\begin_inset Formula $C$
\end_inset

 if and only if, for every 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\overrightarrow{x}=x_{1},...,x_{k}\in\textrm{SVars}^{k}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, 
\begin_inset Formula $\Upsilon_{\overrightarrow{x}}^{R}\in C$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
In the case of regular spanners, the class of string relations that they
 can select is exactly 
\begin_inset Formula $\textrm{REC}$
\end_inset

.
\end_layout

\begin_layout Theorem
The class of string relations selectable by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left\llbracket \textrm{\textrm{VA}_{\textrm{set}}}\right\rrbracket $
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{REC}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\noindent
The relation 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $=$
\end_inset


\begin_inset Quotes erd
\end_inset

 is not in 
\begin_inset Formula $\textrm{REC}$
\end_inset

, thus it is not selectable by regular spanners, nonetheless it is important
 for selection predicates in AQL.
 Therefore, regular spanners are incapable of modeling its core.
 In the following subsection, I describe the class of core spanners, that,
 as shown in 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

, models the core of AQL.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:AQL-coresp"

\end_inset

Core Spanners
\end_layout

\begin_layout Standard
An expression in the core of AQL belongs to 
\begin_inset Formula $\textrm{RGX}^{\left\{ \cup,\pi,\bowtie,\varsigma^{=}\right\} }$
\end_inset

.
 Consequently, a core spanner is defined as follows.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "core-def"

\end_inset

A core spanner is a document spanner belonging to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left\llbracket \textrm{RGX}^{\left\{ \cup,\pi,\bowtie,\varsigma^{=}\right\} }\right\rrbracket $
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Thanks to Theorems 
\begin_inset CommandInset ref
LatexCommand ref
reference ".rgx=vstk"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference ".setext=set"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference ".stkext=set"

\end_inset

 we can easily state the next theorem.
 
\end_layout

\begin_layout Theorem
\noindent
\begin_inset CommandInset label
LatexCommand label
name "RGX=SET"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left\llbracket \textrm{RGX}^{\left\{ \cup,\pi,\bowtie,\varsigma^{=}\right\} }\right\rrbracket =\left\llbracket \textrm{\textrm{VA}_{\textrm{stk}}}^{\left\{ \cup,\pi,\bowtie,\varsigma^{=}\right\} }\right\rrbracket =\left\llbracket \textrm{\textrm{VA}_{\textrm{set}}}^{\left\{ \cup,\pi,\bowtie,\varsigma^{=}\right\} }\right\rrbracket $
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\noindent
This shows that core spanners can be reduced to regular spanners extended
 with the algebra 
\begin_inset Formula $\left\{ \cup,\pi,\bowtie,\varsigma^{=}\right\} $
\end_inset

.
 But the following lemma tells us that an algebra with fewer operators is
 also sufficient.
\end_layout

\begin_layout Lemma
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left\llbracket \textrm{\textrm{VA}_{\textrm{set}}}^{\left\{ \cup,\pi,\bowtie,\varsigma^{=}\right\} }\right\rrbracket =\left\llbracket \textrm{\textrm{VA}_{\textrm{set}}}^{\left\{ \pi,\varsigma^{=}\right\} }\right\rrbracket $
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Another lemma, known as the 
\emph on
core simplification lemma
\emph default
, gives an even simpler way of representing core spanners.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "Core-simplif"

\end_inset


\begin_inset Formula $\mathbf{(Core\,Simplification\,Lemma)}$
\end_inset

 Every core spanner can be defined by an expression of the form
\end_layout

\begin_layout Lemma
\begin_inset Formula 
\begin{equation}
\pi_{V}SA
\end{equation}

\end_inset


\end_layout

\begin_layout Lemma
\noindent
where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $A$
\end_inset

 is a vset-automaton;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $V\subseteq\textrm{SVars}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $S$
\end_inset

 is a sequence of string selections 
\begin_inset Formula $\varsigma_{x,y}^{=}$
\end_inset

, for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $x,y\in\textrm{SVars}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\noindent
For what concerns which string relations can be simulated by core spanners,
 the next definition presents three string relations of relevance.
\end_layout

\begin_layout Definition
Given two strings 
\begin_inset Formula $\mathbf{s},\mathbf{t}\in\Sigma^{\ast}$
\end_inset

:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\mathbf{s}\sqsubseteq\mathbf{t}$
\end_inset

 if 
\begin_inset Formula $\mathbf{s}$
\end_inset

 is a (consecutive) substring of t (i.e.
 
\begin_inset Formula $\mathbf{s}=\mathbf{t}_{\left[i,j\right\rangle }$
\end_inset

);
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathbf{s}\sqsubseteq_{\textrm{prf}}\mathbf{t}$
\end_inset

 if 
\begin_inset Formula $\mathbf{s}$
\end_inset

 is a prefix of t (i.e.
 
\begin_inset Formula $\mathbf{s}=\mathbf{t}_{\left[1,j\right\rangle }$
\end_inset

);
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathbf{s}\sqsubseteq_{\textrm{sfx}}\mathbf{t}$
\end_inset

if 
\begin_inset Formula $\mathbf{s}$
\end_inset

 is a suffix of t (i.e.
 
\begin_inset Formula $\mathbf{s}=\mathbf{t}_{\left[i,\left|\mathbf{t}\right|+1\right\rangle }$
\end_inset

).
\end_layout

\end_deeper
\begin_layout Proposition
\noindent
All the string relations in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{REC}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, 
\begin_inset Formula $\mathbf{\sqsubseteq}$
\end_inset

, 
\begin_inset Formula $\sqsubseteq_{\textrm{prf}}$
\end_inset

 and 
\begin_inset Formula $\sqsubseteq_{\textrm{sfx}}$
\end_inset

 are selectable by the core spanners.
\end_layout

\begin_layout Subsection
Difference
\end_layout

\begin_layout Standard
Besides the operators introduced so far, AQL also supports difference, which
 is defined as follows.
\end_layout

\begin_layout Definition
Given two union compatible document spanners 
\begin_inset Formula $P_{1}$
\end_inset

 and 
\begin_inset Formula $P_{2}$
\end_inset

, their difference is the spanner 
\begin_inset Formula $P_{1}\setminus P_{2}$
\end_inset

, for which we have:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVars}\left(P_{1}\setminus P_{2}\right)=\textrm{SVars}\left(P_{1}\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
given a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

, 
\begin_inset Formula $\left(P_{1}\setminus P_{2}\right)\left(\mathbf{s}\right)=\left(P_{1}\right)\setminus\left(P_{2}\right)\left(\mathbf{s}\right)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\noindent
It can be shown that regular spanners are closed under difference.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name ".setdiff=set"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left\llbracket \textrm{\textrm{VA}_{\textrm{set}}}^{\left\{ \setminus\right\} }\right\rrbracket =\left\llbracket \textrm{\textrm{VA}_{\textrm{set}}}\right\rrbracket $
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\noindent
Despite the result of of Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference ".setdiff=set"

\end_inset

, core spanners are not closed under difference.
 This is why this operator has not been considered in this discussion.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name ".last-stat"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left\llbracket \textrm{RGX}^{\left\{ \cup,\pi,\bowtie,\varsigma^{=}\right\} }\right\rrbracket \subsetneq\left\llbracket \textrm{RGX}^{\left\{ \cup,\pi,\bowtie,\varsigma^{=},\setminus\right\} }\right\rrbracket $
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:A-Runtime-System"

\end_inset

A Runtime System for the Core of AQL
\end_layout

\begin_layout Standard
In this chapter I describe the model of a new runtime system for the core
 fragment of AQL.
 It is based on a modified version of vset-automata, the 
\emph on
extended vset-automata (
\emph default
or 
\emph on
eVset-automata).

\emph default
 In particular, the system works with a special kind of eVset-automata:
 
\emph on
well-behaved eVset-automata.

\emph default
 The structure of the chapter is as follows.

\emph on
 
\emph default
In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:EVST-def"

\end_inset

 I define eVset-automata.
 Then, in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:EVST-wb"

\end_inset

, I describe well-behaved eVset-automata and their properties, with particular
 attention to their ability to support the operators presented in Subsection
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Algebras-of-Spanners"

\end_inset

: I show construction methods to simulate projection, union and natural
 join with well-behaved eVset-automata.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

 contains descriptions of construction methods for the same purpose, but
 for vset-automata.
 However, those methods have exponential space complexity, while the methods
 presented in this chapter have polynomial 
\emph on
time
\emph default
 complexity.
 Finally, I show how well-behaved eVset-automata can be used in a class
 of spanner representations that models the class of core spanners, with
 some simplifications, that are similar to those obtained in Subsection
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:AQL-coresp"

\end_inset

 of the previous chapter.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:EVST-def"

\end_inset

Extended Vset-automata
\end_layout

\begin_layout Standard
Before I define extended vset-automata formally, I introduce some basic
 concepts.
\end_layout

\begin_layout Definition
Given a set 
\begin_inset Formula $X\subseteq\textrm{SVars}$
\end_inset

, we define:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVOps}^{\vdash}\left(X\right)=\left\{ x\vdash\mid x\in X\right\} $
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVOps}^{\dashv}\left(X\right)=\left\{ \dashv x\mid x\in X\right\} $
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVOps}\left(X\right)=\textrm{SVOps}^{\vdash}\left(X\right)\cup\textrm{SVOps}^{\dashv}\left(X\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\noindent
With this definition in mind, we are ready to describe an extended vset-automato
n.
\end_layout

\begin_layout Definition
An extended 
\emph on
vset-automaton
\emph default
 (or 
\emph on
eVset-automaton
\emph default
) is a tuple 
\begin_inset Formula $\left(Q,q_{0},q_{f},\delta\right)$
\end_inset

, where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Q$
\end_inset

 is a finite set of states;
\end_layout

\begin_layout Itemize
\begin_inset Formula $q_{0}\in Q$
\end_inset

 is the initial state;
\end_layout

\begin_layout Itemize
\begin_inset Formula $q_{f}\in Q$
\end_inset

 is the accepting state;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\delta=\delta^{\textrm{char}}\cup\delta^{\textrm{op}}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

is a finite transition relation consisting of triples, where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\delta^{\textrm{char}}=\left\{ \left(q,\sigma,q'\right)\mid q,q'\in Q,\sigma\in\Sigma\right\} $
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, whose elements are called character transitions;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\delta^{\textrm{op}}=\left\{ \left(q,S,q'\right)\mid q,q'\in Q,S\subseteq\textrm{SVOps}\left(\textrm{SVars}\right),S\textrm{ finite}\right\} $
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, whose elements are called operation transitions .
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
\noindent
In a transition 
\begin_inset Formula $\left(q,a,q'\right)$
\end_inset

 with label 
\begin_inset Formula $a$
\end_inset

 from state 
\begin_inset Formula $q$
\end_inset

 to state 
\begin_inset Formula $q'$
\end_inset

, 
\begin_inset Formula $q$
\end_inset

 is called the 
\emph on
source state
\emph default
, while 
\begin_inset Formula $q'$
\end_inset

 is called the 
\emph on
destination state
\emph default
.
 With a slight abuse of notation, I denote by 
\begin_inset Formula $\textrm{SVOps}\left(A\right)$
\end_inset

 the set of variable operations appearing in the transitions of an eVset-automat
on 
\begin_inset Formula $A$
\end_inset

.
 
\begin_inset Formula $\textrm{SVars}\left(A\right)$
\end_inset

 is defined as for a usual vset-automaton.
 In order to make the semantics of an eVset-automaton clear, we need the
 definitions of a 
\emph on
configuration
\emph default
 and a 
\emph on
run
\emph default
 of an eVset-automaton.
\end_layout

\begin_layout Definition
Given a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

, 
\begin_inset Formula $\left|\mathbf{s}\right|=n$
\end_inset

, and an eVset-automaton 
\begin_inset Formula $A=\left(Q,q_{0},q_{f},\delta\right)$
\end_inset

, a configuration of A is a tuple 
\begin_inset Formula $c=\left(q,V,Y,i\right)$
\end_inset

, where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $q\in Q$
\end_inset

 is the current state;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $V\subseteq\textrm{SVars}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

is the active variable set;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $Y\subseteq\textrm{SVars}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

is the set of available variables;
\end_layout

\begin_layout Itemize
\begin_inset Formula $i$
\end_inset

 is an index belonging to 
\begin_inset Formula $\left\{ 1,\ldots,n+1\right\} $
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "e-run"

\end_inset

Given a string 
\begin_inset Formula $\mathbf{s}=s_{1},\ldots,s_{n}$
\end_inset

 and an eVset-automaton 
\begin_inset Formula $A=\left(Q,q_{0},q_{f},\delta\right)$
\end_inset

, a run 
\begin_inset Formula $\rho$
\end_inset

 of 
\begin_inset Formula $A$
\end_inset

 on 
\begin_inset Formula $\mathbf{s}$
\end_inset

 is a sequence 
\begin_inset Formula $c_{0},\ldots,c_{m}$
\end_inset

 of configurations, where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $c_{0}=\left(q_{0},\emptyset,\textrm{SVars}\left(A\right),1\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
for 
\begin_inset Formula $j=0,\ldots,m-1$
\end_inset

 one of the following holds for 
\begin_inset Formula $c_{j}=\left(q_{j},V_{j},Y_{j},i_{j}\right)$
\end_inset

 and 
\begin_inset Formula $c_{j+1}=\left(q_{j+1},V_{j+1},Y_{j+1},i_{j+1}\right)$
\end_inset

:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $V_{j+1}=V_{j}$
\end_inset

, 
\begin_inset Formula $Y_{j+1}=Y_{j}$
\end_inset

, 
\begin_inset Formula $i_{j+1}=i_{j}+1$
\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left(q_{j},s_{j},q_{j+1}\right)\in\delta^{\textrm{char}}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $i_{j+1}=i_{j}$
\end_inset

, and for some 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $S\subseteq\textrm{SVOps}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

we have :
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
for each 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $x\in\textrm{SVars}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $x\vdash\in S\Rightarrow x\in Y_{j}$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\dashv x\in S\Rightarrow\left(x\vdash\in S\lor x\in V_{j}\right)$
\end_inset

;
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $V_{j+1}=\left(V_{j}\cup\left\{ x\mid x\vdash\in S\right\} \right)\setminus\left\{ x\mid\dashv x\in S\right\} $
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $Y_{j+1}=Y_{j}\setminus\left\{ x\mid x\vdash\in S\right\} $
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left(q_{j},S,q_{j+1}\right)\in\delta^{\textrm{op}}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Definition
\begin_inset Formula $\rho$
\end_inset

 is accepting if 
\begin_inset Formula $c_{m}=\left(q_{f},\emptyset,\emptyset,n+1\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\textrm{ARuns}\left(A,\mathbf{s}\right)$
\end_inset

 and 
\begin_inset Formula $\left\llbracket A\right\rrbracket $
\end_inset

, for an eVset-automaton 
\begin_inset Formula $A$
\end_inset

 and a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

, are defined in similar ways to those of usual vset-automata.
 This new kind of vset-automata allows to perform an arbitrary number of
 variable operations in one transition.
 The operations in a transition are to be performed in a given order.
 The exact order is not very important, except for the fact that, in a valid
 run, the insertion and removal of a variable from the active variable set
 need to happen in the correct order (i.e.
 insertions first).
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\backslash
begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
\backslash
node[state,initial]  (q_0)                     {}; 
\backslash
node[state]          (q_1) [right=of q_0] {}; 
\backslash
node[state]          (q_2) [right=of q_1] {}; 
\backslash
node[state,accepting](q_3) [right=of q_2] {}; 
\backslash
path[->] (q_0) edge              node        {$
\backslash
left
\backslash
{ x
\backslash
vdash
\backslash
right
\backslash
} $} (q_1) 		edge [loop above] node        {$
\backslash
Sigma$} () 	  (q_1) edge 	          node        {$
\backslash
left
\backslash
{ y
\backslash
vdash
\backslash
right
\backslash
} $} (q_2) 		edge [loop above] node        {a} (q_2) 	  (q_2) edge     
         node        {$
\backslash
left
\backslash
{ 
\backslash
dashv x,
\backslash
dashv y
\backslash
right
\backslash
} $} (q_3) 		edge [loop above] node        {b} () 	  (q_3) edge [loop above]
 node        {$
\backslash
Sigma$} (); 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:evset"

\end_inset

An eVset-automaton 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
The automaton 
\begin_inset Formula $A$
\end_inset

, shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:evset"

\end_inset

, is an extended vset-automaton.
 The operation transitions are those with a label of the form 
\begin_inset Formula $\left\{ o_{1},\ldots\,,o_{n}\right\} $
\end_inset

, with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $o_{i}\in\textrm{SVOps}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $\left(\textrm{SVars}\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To understand the motivation for using eVset-automata instead of plain vset-auto
mata (that will be clear in the next section) we need to introduce some
 additional useful concepts.
\end_layout

\begin_layout Definition
Given a transition 
\begin_inset Formula $t\in\delta$
\end_inset

 in an eVset-automaton 
\begin_inset Formula $A$
\end_inset

, and an ordering 
\begin_inset Formula $\varphi$
\end_inset

 on the elements of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVOps}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, we define
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{Ops}\left(t\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

as either:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $t=\left(q,S,q'\right)\in\delta^{\textrm{op}}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, the set 
\begin_inset Formula $S$
\end_inset

;
\end_layout

\begin_layout Itemize
if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $t\in\delta^{\textrm{char}}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, the empty set.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{LOps}_{\varphi}\left(t\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

as either:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $t=\left(q,S,q'\right)\in\delta^{\textrm{op}}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, the list 
\begin_inset Formula $o_{1},\ldots,o_{\left|S\right|}$
\end_inset

 of the operations belonging to 
\begin_inset Formula $S$
\end_inset

, ordered according to 
\begin_inset Formula $\varphi$
\end_inset

;
\end_layout

\begin_layout Itemize
if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $t\in\delta^{\textrm{char}}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, the empty list.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Definition
\noindent
Given an extended vset-automaton 
\begin_inset Formula $A=\left(Q,q_{0},q_{f},\delta\right)$
\end_inset

 and a pair of states 
\begin_inset Formula $q,q'\in Q$
\end_inset

, a path 
\begin_inset Formula $p$
\end_inset

 between 
\begin_inset Formula $q$
\end_inset

 and 
\begin_inset Formula $q'$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

 is a sequence of transitions 
\begin_inset Formula $t_{1},$
\end_inset


\begin_inset Formula $\ldots,t_{n}\in\delta$
\end_inset

, such that:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
the source state of 
\begin_inset Formula $t_{1}$
\end_inset

 is 
\begin_inset Formula $q$
\end_inset

;
\end_layout

\begin_layout Itemize
the destination state of 
\begin_inset Formula $t_{n}$
\end_inset

 is 
\begin_inset Formula $q'$
\end_inset

;
\end_layout

\begin_layout Itemize
\noindent
for every pair 
\begin_inset Formula $t_{i},t_{i+1}$
\end_inset

, the destination state of 
\begin_inset Formula $t_{i}$
\end_inset

 equals the source state of 
\begin_inset Formula $t_{i+1}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Definition
We also write 
\begin_inset Formula $p_{q}^{q'}$
\end_inset

.
 We refer to the set of paths in 
\begin_inset Formula $A$
\end_inset

 as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{Paths}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
A path in an eVset-automaton is closely related to a run, as formalized
 by the next definition.
\end_layout

\begin_layout Definition
Given a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

, an eVset-automaton 
\begin_inset Formula $A=\left(Q,q_{0},q_{f},\delta\right)$
\end_inset

, a run 
\begin_inset Formula $\rho=c_{0},$
\end_inset


\begin_inset Formula $\ldots,c_{m}$
\end_inset

 of 
\begin_inset Formula $A$
\end_inset

 on 
\begin_inset Formula $\mathbf{s}$
\end_inset

 and a path 
\begin_inset Formula $p=t_{0},\ldots,t_{m-1}$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

, we say that 
\begin_inset Formula $p$
\end_inset

 supports 
\begin_inset Formula $\rho$
\end_inset

 if, for every pair 
\begin_inset Formula $c_{i}$
\end_inset

, 
\begin_inset Formula $c_{i+1}$
\end_inset

 of configurations, 
\begin_inset Formula $c_{i+1}$
\end_inset

 is obtained from 
\begin_inset Formula $c_{i}$
\end_inset

 by applying 
\begin_inset Formula $t_{i}$
\end_inset

, using the rules given in Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "e-run"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Definition
Given a path 
\begin_inset Formula $p=t_{1},\ldots,t_{n}$
\end_inset

 in an eVset-automaton 
\begin_inset Formula $A$
\end_inset

, and considering an ordering 
\begin_inset Formula $\varphi$
\end_inset

 on the elements of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVOps}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, we define
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
the set 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{Ops}\left(p\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

as
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula 
\[
\bigcup_{i=1}^{n}\textrm{Ops}\left(t_{i}\right)
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
the list 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{LOps}_{\varphi}\left(p\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

as
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula 
\[
\bigoplus_{i=1}^{n}\textrm{LOps}_{\varphi}\left(t_{i}\right)
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

where 
\begin_inset Formula $\bigoplus$
\end_inset

 is the usual list concatenation operator.
\end_layout

\end_deeper
\begin_layout Definition
If every transition in 
\begin_inset Formula $p$
\end_inset

 belongs to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\delta^{\textrm{op}}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, we say that 
\begin_inset Formula $p$
\end_inset

 is an operation-only path.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
From now on, without loss of generality, let us consider a fixed order 
\begin_inset Formula $\varphi$
\end_inset

, in which insertions of variables (e.g., 
\begin_inset Formula $x\vdash$
\end_inset

) into the active set come before deletions (e.g., 
\begin_inset Formula $\dashv x$
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
As shown in the previous chapter, the class of vset-automata does not get
 more expressive power when extended with the algebra 
\begin_inset Formula $O=\left\{ \cup,\pi,\bowtie\right\} $
\end_inset

.
 Hence, this class is a good candidate to be the base for a class of representat
ions of the core spanners, as the Core Simplification Lemma suggests.
 Nonetheless, the constructions presented in 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

 to simulate the operators of 
\begin_inset Formula $O$
\end_inset

 with vset-automata are inefficient, as in general they result in vset-automata
 that are exponential in the size of the input.
 In the following, I introduce a subclass of extended vset-automata
\emph on
, well-behaved eVset-automata
\emph default
, and I describe 
\emph on
polynomial-time constructions
\emph default
 to simulate the operators of 
\begin_inset Formula $O$
\end_inset

 for this subclass.
 Moreover, we will see that an AQL query belonging to the core fragment
 of the language, as defined in 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

, can be converted into a well-behaved eVset-automaton extended with string
 equality selection (and an external final projection, if necessary), making
 it possible for the runtime to be based almost entirely on well-behaved
 eVset-automata.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:EVST-wb"

\end_inset

Well-Behaved Extended Vset-Automata
\end_layout

\begin_layout Standard
In order to be well-behaved, an eVset-automaton has to respect some constraints
 on its paths that are between its initial and accepting state.
 I call this kind of paths 
\emph on
complete paths.
\end_layout

\begin_layout Definition
\noindent
Given an eVset-automaton 
\begin_inset Formula $A=\left(Q,q_{0},q_{f},\delta\right)$
\end_inset

, a path 
\begin_inset Formula $p=t_{1},\ldots,t_{n}$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

 is complete if it is between 
\begin_inset Formula $q_{0}$
\end_inset

 and 
\begin_inset Formula $q_{f}$
\end_inset

, that is 
\begin_inset Formula $p=p_{q_{0}}^{q_{f}}$
\end_inset

.
\end_layout

\begin_layout Standard
I now formally define a well-behaved eVset-automaton.
\end_layout

\begin_layout Definition
\noindent
\begin_inset CommandInset label
LatexCommand label
name "well-behaved"

\end_inset

An eVset-automaton 
\begin_inset Formula $A$
\end_inset

 is well-behaved if, for every complete path 
\begin_inset Formula $p$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

 we have:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
for every 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $o\in\textrm{SVOps}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, 
\begin_inset Formula $o$
\end_inset

 appears exactly once in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{LOps}\left(p\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\begin_inset CommandInset label
LatexCommand label
name "enu:well-behaved-1,"

\end_inset


\end_layout

\begin_layout Enumerate
for every pair of operations 
\begin_inset Formula $x\vdash$
\end_inset

,
\begin_inset Formula $\dashv x$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\in\textrm{SVOps}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, 
\begin_inset Formula $x\vdash$
\end_inset

 appears before 
\begin_inset Formula $\dashv x$
\end_inset

 in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{LOps}\left(p\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
According to the definition, well-behaved eVset-automata guarantee that
 any of their complete paths will support a valid accepting run.
 This property is desirable, because it allows to execute a well-behaved
 eVset-automaton 
\begin_inset Formula $A$
\end_inset

 with an engine that does not need to check, for each run 
\begin_inset Formula $\rho$
\end_inset

 on a given string 
\begin_inset Formula $\mathbf{s}$
\end_inset

, that all the operations in 
\begin_inset Formula $\textrm{SVOps}\left(A\right)$
\end_inset

 are performed correctly.
 This is an advantage over generic eVset-automata (or vset-automata).
 
\end_layout

\begin_layout Example
Consider again the eVset-automaton 
\begin_inset Formula $A$
\end_inset

 from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:evset"

\end_inset

.
 It is easy to verify that 
\begin_inset Formula $A$
\end_inset

 is well-behaved.
\end_layout

\begin_layout Standard
Since states that cannot reach the accepting state, or that cannot be reached
 from the initial state, are not used in complete paths, we might want to
 consider only well-behaved eVset-automata where these states do not exist.
\end_layout

\begin_layout Definition
Given an eVset-automaton 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

 is pruned if for every state 
\begin_inset Formula $q$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

, there is a path between 
\begin_inset Formula $q_{0}$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

, and a path between 
\begin_inset Formula $q$
\end_inset

 and 
\begin_inset Formula $q_{f}$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Example
The eVset-automaton 
\begin_inset Formula $A$
\end_inset

 from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:evset"

\end_inset

 is pruned.
\end_layout

\begin_layout Standard
The next proposition tells us that the we can always prune a well-behaved
 eVset-automaton, obtaining a new eVset-automaton equivalent to the original.
\end_layout

\begin_layout Proposition
Given a well-behaved eVset-automaton 
\begin_inset Formula $A$
\end_inset

, there exists a pruned well-behaved eVset-automaton 
\begin_inset Formula $A'$
\end_inset

 such that 
\begin_inset Formula $\left\llbracket A'\right\rrbracket =\left\llbracket A\right\rrbracket $
\end_inset

.
 Moreover, 
\begin_inset Formula $A'$
\end_inset

 can be produced in polynomial time.
\end_layout

\begin_layout Proof
To obtain 
\begin_inset Formula $A'$
\end_inset

, it is sufficient to remove from 
\begin_inset Formula $A$
\end_inset

 those states from which we can't reach the final state, those states that
 are unreachable from the initial state, and all the transitions that have
 them as source or destination states.
 To test each state for removal we can use, e.g., Dijkstra's shortest path
 algorithm, which ensures 
\begin_inset Formula $A'$
\end_inset

 can be found in polynomial time.
 Because of our construction, 
\begin_inset Formula $A'$
\end_inset

 is well-behaved, as all its complete paths are also in 
\begin_inset Formula $A$
\end_inset

.
 We now show that, for every string 
\begin_inset Formula $\mathbf{s},$
\end_inset

 we have 
\begin_inset Formula $\left\llbracket A'\right\rrbracket \left(\mathbf{s}\right)=\left\llbracket A\right\rrbracket \left(\mathbf{s}\right)$
\end_inset

.
 To see that 
\begin_inset Formula $\left\llbracket A'\right\rrbracket \left(\mathbf{s}\right)\subseteq\left\llbracket A\right\rrbracket \left(\mathbf{s}\right)$
\end_inset

, we can notice that each run 
\begin_inset Formula $\rho'$
\end_inset

 of 
\begin_inset Formula $A'$
\end_inset

 on 
\begin_inset Formula $\mathbf{s}$
\end_inset

 that is accepting can be supported only by a complete path 
\begin_inset Formula $p'$
\end_inset

, which is also in 
\begin_inset Formula $A$
\end_inset

 by construction.
 
\begin_inset Formula $\left\llbracket A\right\rrbracket \left(\mathbf{s}\right)\subseteq\left\llbracket A'\right\rrbracket \left(\mathbf{s}\right)$
\end_inset

 is true as well because we include in 
\begin_inset Formula $A'$
\end_inset

 all the complete paths existing in 
\begin_inset Formula $A$
\end_inset

 so every run 
\begin_inset Formula $p$
\end_inset

 of 
\begin_inset Formula $A$
\end_inset

 on 
\begin_inset Formula $\mathbf{s}$
\end_inset

 is also a run of 
\begin_inset Formula $A'$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
If a well-behaved eVset-automaton is pruned, it automatically gets two other
 properties.
\end_layout

\begin_layout Corollary
Given a pruned well-behaved eVset-automaton 
\begin_inset Formula $A$
\end_inset

, for every path 
\begin_inset Formula $p$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{LOps}\left(p\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

contains no duplicates.
\end_layout

\begin_layout Proof
Since 
\begin_inset Formula $A$
\end_inset

 is pruned, 
\begin_inset Formula $p$
\end_inset

 is part of a complete path 
\begin_inset Formula $p'$
\end_inset

.
 But 
\begin_inset Formula $A$
\end_inset

 is also well-behaved, so 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{LOps}\left(p'\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

contains no duplicates, which implies that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{LOps}\left(p\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

has no duplicates either.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "same-ops"

\end_inset

Given a pruned well-behaved eVset-automaton 
\begin_inset Formula $A$
\end_inset

, and two states 
\begin_inset Formula $q,q'$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

, for every pair of paths 
\begin_inset Formula $p,p'$
\end_inset

 between 
\begin_inset Formula $q$
\end_inset

 and 
\begin_inset Formula $q'$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{Ops}\left(p\right)=\textrm{Ops}\left(p'\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\begin_layout Proof
Since 
\begin_inset Formula $A$
\end_inset

 is pruned, there exists a path 
\begin_inset Formula $p^{0}$
\end_inset

 between 
\begin_inset Formula $q_{0}$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

.
 For the same reason, there exists a path 
\begin_inset Formula $p^{f}$
\end_inset

 between 
\begin_inset Formula $q'$
\end_inset

 and 
\begin_inset Formula $q_{f}$
\end_inset

.
 So 
\begin_inset Formula $q$
\end_inset

 and 
\begin_inset Formula $q'$
\end_inset

 appear in two complete paths, which we may call 
\begin_inset Formula $p^{0}pp^{f}$
\end_inset

 and 
\begin_inset Formula $p^{0}p'p^{f}$
\end_inset

, that differ only in the subpaths between 
\begin_inset Formula $q$
\end_inset

 and 
\begin_inset Formula $q'$
\end_inset

.
 If 
\begin_inset Formula $\textrm{Ops}\left(p\right)\neq\textrm{Ops}\left(p'\right)$
\end_inset

, then one of 
\begin_inset Formula $p^{0}pp^{f}$
\end_inset

 and 
\begin_inset Formula $p^{0}p'p^{f}$
\end_inset

 would not satisfy the requirement 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:well-behaved-1,"

\end_inset

 of Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "well-behaved"

\end_inset

, making 
\begin_inset Formula $A$
\end_inset

 not well-behaved, a contradiction.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
In the following, I describe the constructions used by the runtime system
 to simulate algebraic operations with well-behaved eVset-automata.
 The main advantage of these constructions is that their time complexity
 is 
\emph on
polynomial
\emph default
 in the size of the input automaton/a.
 Before we start, a formal definition of the size of an eVset-automaton
 is necessary, along with some assumptions.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "size-evset"

\end_inset

Given an eVset-automaton 
\begin_inset Formula $A=\left(Q,q_{0},q_{f},\delta\right)$
\end_inset

, the size of 
\begin_inset Formula $A$
\end_inset

 is defined as 
\begin_inset Formula $\left|A\right|=\left|Q\right|+\left|\delta\right|$
\end_inset

, where:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\left|Q\right|$
\end_inset

 is the cardinality of 
\begin_inset Formula $Q$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|\delta\right|$
\end_inset

 is defined by the following sum:
\begin_inset Formula 
\begin{equation}
\sum_{t\in\delta}\left|t\right|\label{eq:sum-tr}
\end{equation}

\end_inset

where, for every transition 
\begin_inset Formula $t\in\delta$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $t\in\delta^{\textrm{op}}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left|t\right|=2+\left|\textrm{Ops}\left(t\right)\right|$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left|\textrm{Ops}\left(t\right)\right|$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

being the cardinality of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{Ops}\left(t\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|t\right|=3$
\end_inset

 otherwise.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
This definition takes into account the number of states of an eVset-automaton,
 as well as the number of transitions it contains.
 Each transition is weighted by the number of elements that define it.
 In case it is a character transition, we count two states and a character.
 If it is an operation transition instead, we count the two states and the
 number of operations it performs.
 Although this definition is abstract, it is closely related to the sizes
 of real eVset-automata representations, that are indeed determined by the
 elements considered, up to a multiplicative constant.
 Moreover, in the proofs that will follow, I assume that the operations
 of adding a state to/deleting a state from the state set of an eVset-automaton,
 or adding a transition to/deleting a transition from its transition function,
 take 
\emph on
constant time
\emph default
.
 These assumptions are reasonable, because the state set and the transition
 function are implemented as Scala hashsets in the runtime system, and the
 hashset data structure indeed guarantees this complexity
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
See 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://docs.scala-lang.org/overviews/collections/performance-characteristics.html
\end_layout

\end_inset

.
\end_layout

\end_inset

.
 Another important assumption is that, given an eVset-automaton 
\begin_inset Formula $A$
\end_inset

, creating a new transition requires 
\begin_inset Formula $O\left(\left|\textrm{SVars}\left(A\right)\right|\right)$
\end_inset

 time.
 This complexity is justified by the fact that, given an operation transition
 
\begin_inset Formula $t$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

, we create 
\begin_inset Formula $\textrm{Ops}\left(t\right)$
\end_inset

 by adding 
\begin_inset Formula $O\left(\left|\textrm{SVars}\left(A\right)\right|\right)$
\end_inset

 operations to it, and 
\begin_inset Formula $\textrm{Ops}\left(t\right)$
\end_inset

 is implemented as a hashset as well.
 Moreover, the time required to instantiate a character transition can be
 considered constant, so it is dominated by 
\begin_inset Formula $O\left(\left|\textrm{SVars}\left(A\right)\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard
We are ready to discuss the announced constructions, starting with the one
 for projection.
\end_layout

\begin_layout Theorem
\noindent
\begin_inset CommandInset label
LatexCommand label
name "ext-proj"

\end_inset

Given a well-behaved eVset-automaton 
\begin_inset Formula $A$
\end_inset

, the set 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $X=\textrm{SVars}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

and a set 
\begin_inset Formula $Y\subseteq X$
\end_inset

, a well behaved eVset-automaton 
\begin_inset Formula $A'$
\end_inset

 can be produced in linear time such that 
\begin_inset Formula $\left\llbracket A'\right\rrbracket =\pi_{Y}\left\llbracket A\right\rrbracket $
\end_inset

.
\end_layout

\begin_layout Proof
Let us consider 
\begin_inset Formula $A=\left(Q,q_{0},q_{f},\delta\right)$
\end_inset

.
 We can take 
\begin_inset Formula $A'=\left(Q',q_{0}',q_{f}',\delta'\right)$
\end_inset

, where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Q'=Q$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $q_{0}'=q_{0}$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $q_{f}'=q_{f}$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\delta'=\left(\delta\setminus\delta^{\textrm{unprojected}}\right)\cup\delta^{\textrm{projected}}$
\end_inset

, where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\delta^{\textrm{unprojected}}=\left\{ \left(q,S,q'\right)\in\delta\mid S\cap\textrm{SVOps}\left(X\setminus Y\right)\neq\textrm{Ø}\right\} $
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\delta^{\textrm{projected}}=\left\{ \left(q,S',q'\right)\mid\exists\left(q,S,q'\right)\in\delta^{\textrm{unprojected}}:S'=S\setminus\textrm{SVOps}\left(X\setminus Y\right)\right\} $
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Proof
This construction removes all the occurrences of variable operations concerning
 variables excluded from the projection.
 
\begin_inset Formula $A'$
\end_inset

 is still well-behaved, since we maintain the occurrences of operations
 concerning the variables on which we project, that continue to appear exactly
 once on each complete path, and in the right order.
 To obtain this construction, we can examine all transitions in 
\begin_inset Formula $\delta$
\end_inset

 and, for each operation transition 
\begin_inset Formula $t$
\end_inset

, remove it from 
\begin_inset Formula $\delta$
\end_inset

 if it contains variable operations involving variables we need to exclude,
 then add a new transition 
\begin_inset Formula $t'$
\end_inset

 that is identical to 
\begin_inset Formula $t$
\end_inset

, except for the fact that it does not contain the unwanted operations.
 In this procedure, we scan 
\begin_inset Formula $O\left(\left|\delta\right|\right)$
\end_inset

 transitions and we replace a transition 
\begin_inset Formula $t$
\end_inset

 in 
\begin_inset Formula $O\left(\left|t\right|\right)$
\end_inset

 time.
 Hence, the total running time is 
\begin_inset Formula $O\left(\sum_{t\in\delta}O\left(\left|t\right|\right)\right)=O\left(\left|\delta\right|\right)=O\left(\left|A\right|\right)$
\end_inset

.
 Next, let us show that 
\begin_inset Formula $\left\llbracket A'\right\rrbracket =\pi_{Y}\left\llbracket A\right\rrbracket $
\end_inset

.
 Notice that given a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

, for each accepting run 
\begin_inset Formula $\rho$
\end_inset

 of 
\begin_inset Formula $A$
\end_inset

 on 
\begin_inset Formula $\mathbf{s}$
\end_inset

 producing an 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuple 
\begin_inset Formula $\mu$
\end_inset

, there is an accepting run 
\begin_inset Formula $\rho'$
\end_inset

 of 
\begin_inset Formula $A'$
\end_inset

 that produces an 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuple 
\begin_inset Formula $\mu'$
\end_inset

, which assigns the same spans as 
\begin_inset Formula $\mu$
\end_inset

 to the variables in common with 
\begin_inset Formula $\mu'$
\end_inset

, which by construction belong to 
\begin_inset Formula $Y$
\end_inset

.
 The path 
\begin_inset Formula $p'$
\end_inset

 supporting 
\begin_inset Formula $\rho'$
\end_inset

 is exactly the path obtained by modifying the path 
\begin_inset Formula $p$
\end_inset

, that supports 
\begin_inset Formula $\rho$
\end_inset

, by eliminating the operations on non-projected variables.
 This shows that 
\begin_inset Formula $\pi_{Y}\left\llbracket A\right\rrbracket \subseteq\left\llbracket A'\right\rrbracket $
\end_inset

.
 It must also be that 
\begin_inset Formula $\left\llbracket A'\right\rrbracket \subseteq\pi_{Y}\left\llbracket A\right\rrbracket $
\end_inset

, because no additional complete paths were added to 
\begin_inset Formula $A'$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
A similar result holds for the union operation.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Theorem
\noindent
\begin_inset CommandInset label
LatexCommand label
name "ext-union"

\end_inset

Given two well-behaved eVset-automata 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 that are union-compatible (i.e., 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVars}\left(A\right)=\textrm{SVars}\left(B\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

), a third well-behaved eVset-automaton 
\begin_inset Formula $C$
\end_inset

 can be produced in linear time such that 
\begin_inset Formula $\left\llbracket C\right\rrbracket =\left\llbracket A\right\rrbracket \cup\left\llbracket B\right\rrbracket $
\end_inset

.
\end_layout

\begin_layout Proof
Let us consider 
\begin_inset Formula $A=\left(Q^{A},q_{0}^{A},q_{f}^{A},\delta^{A}\right)$
\end_inset

 and 
\begin_inset Formula $B=\left(Q^{B},q_{0}^{B},q_{f}^{B},\delta^{B}\right)$
\end_inset

.
 We can take 
\begin_inset Formula $C=\left(Q^{C},q_{0}^{C},q_{f}^{C},\delta^{C}\right)$
\end_inset

, where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Q^{C}=Q^{A}\cup Q^{B}\cup\left\{ q_{0}^{C},q_{f}^{C}\right\} $
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\delta^{C}=\delta^{A}\cup\delta^{B}\cup\left\{ \left(q_{0}^{C},\emptyset,q_{0}^{B}\right),\left(q_{f}^{B},\emptyset,q_{f}^{C}\right),\left(q_{0}^{C},\emptyset,q_{0}^{A}\right),\left(q_{f}^{A},\emptyset,q_{f}^{C}\right)\right\} $
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
In this construction, we allow to go from the initial state of 
\begin_inset Formula $C$
\end_inset

 to the initial state of either 
\begin_inset Formula $A$
\end_inset

 or 
\begin_inset Formula $B$
\end_inset

, and to go from the accepting state of 
\begin_inset Formula $A$
\end_inset

 or that of 
\begin_inset Formula $B$
\end_inset

 to the one of 
\begin_inset Formula $C$
\end_inset

, without any new variable operations.
 Thus, given a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

, 
\begin_inset Formula $C$
\end_inset

 can span exactly the 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuples contained in 
\begin_inset Formula $\left\llbracket A\right\rrbracket \left(\mathbf{s}\right)\cup\left\llbracket B\right\rrbracket \left(\mathbf{s}\right)$
\end_inset

.
 Regarding the complexity of the construction, the operations that we perform
 here are the union of the state sets and transition functions, and the
 addition of a fixed number of new transitions and states.
 Let us consider the size of the input as 
\begin_inset Formula $n=\left|A\right|+\left|B\right|$
\end_inset

.
 With the assumptions we made, the time complexity is 
\begin_inset Formula $O\left(\left|Q^{B}\right|\right)+O\left(\left|\delta^{B}\right|\right)=O\left(n\right)$
\end_inset

.
 It is trivial to verify that 
\begin_inset Formula $C$
\end_inset

 is well-behaved, thus the details are omitted.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
In order to show that we can obtain the natural join of two spanners, represente
d by well-behaved eVset-automata, in polynomial time, we need a few more
 steps than in the previous cases.
 The construction that I present is conceptually very similar to that described
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

 for the natural join of plain vset-automata.
 That construction simulates running the input automata in parallel, making
 sure that operations on common variables are performed simultaneously.
 Unfortunately this does not work in general, as the next example shows.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\backslash
begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
\backslash
node[state,initial]  (q_0)                      {}; 
\backslash
node[state]          (q_1) [right=of q_0] {}; 
\backslash
node[state]          (q_2) [right=of q_1] {}; 
\backslash
node[state,accepting](q_3) [right=of q_2] {}; 
\backslash
path[->] (q_0) edge              node        {$
\backslash
left
\backslash
{ y
\backslash
vdash
\backslash
right
\backslash
} $} (q_1) 		edge [loop above] node        {$
\backslash
Sigma$} () 	  (q_1) edge 	          node        {$
\backslash
left
\backslash
{ x
\backslash
vdash
\backslash
right
\backslash
} $} (q_2) 		edge [loop above] node        {a} (q_2) 	  (q_2) edge     
         node        {$
\backslash
left
\backslash
{ 
\backslash
dashv x,
\backslash
dashv y
\backslash
right
\backslash
} $} (q_3) 		edge [loop above] node        {b} () 	  (q_3) edge [loop above]
 node        {$
\backslash
Sigma$} (); 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:evset-2"

\end_inset

A well-behaved eVset-automaton 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Example
Consider the well-behaved eVset-automata 
\begin_inset Formula $A$
\end_inset

 from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:evset"

\end_inset

, and 
\begin_inset Formula $B$
\end_inset

 from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:evset-2"

\end_inset

 and the string 
\begin_inset Formula $\mathbf{s}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

'b'
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
 
\begin_inset Formula $\left\llbracket A\right\rrbracket \left(\mathbf{s}\right)$
\end_inset

 contains the 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuple 
\begin_inset Formula $\mu$
\end_inset

 such that 
\begin_inset Formula $\mu\left(x\right)=\left[0,1\right\rangle $
\end_inset

 and 
\begin_inset Formula $\mu\left(y\right)=\left[0,1\right\rangle $
\end_inset

.
 We also have that 
\begin_inset Formula $\mu\in\left\llbracket B\right\rrbracket \left(\mathbf{s}\right)$
\end_inset

.
 If we attempt to run 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 in parallel on 
\begin_inset Formula $\mathbf{s}$
\end_inset

, we will not be able to span 
\begin_inset Formula $\mu$
\end_inset

, because the two automata disagree on the order of the operations 
\begin_inset Formula $x\vdash$
\end_inset

 and 
\begin_inset Formula $y\vdash$
\end_inset

.
 Thus, we don't get 
\begin_inset Formula $\left\llbracket A\right\rrbracket \bowtie\left\llbracket B\right\rrbracket \left(\mathbf{s}\right)$
\end_inset

 as a result of the execution.
\end_layout

\begin_layout Standard
For the construction to work, the input automata must be modified in some
 way.
 In my system, I convert them into a particular form of eVset-automata,
 that I call 
\emph on
operation-closed
\emph default
.
 The definition of an operation-closed eVset-automaton follows.
\end_layout

\begin_layout Definition
Given an eVset-automaton 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

 is operation-closed if, for every pair of states 
\begin_inset Formula $q,q'$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

, whenever there exists an operation-only path 
\begin_inset Formula $p$
\end_inset

=
\begin_inset Formula $t_{1},\ldots,t_{n}$
\end_inset

 between 
\begin_inset Formula $q$
\end_inset

 and 
\begin_inset Formula $q'$
\end_inset

, then there exists a transition 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $t=\left(q,\bigcup_{i=1}^{n}\textrm{Ops}\left(t_{i}\right),q'\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

in 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto]  
\backslash
node[state,initial]  (q_0)                      {}; 
\backslash
node[state]          (q_1) [right=of q_0] {}; 
\backslash
node[state]          (q_2) [right=of q_1] {};  
\backslash
node[state,accepting](q_3) [right=of q_2] {};  
\backslash
path[->] (q_0) edge              node        {$
\backslash
left
\backslash
{ x
\backslash
vdash
\backslash
right
\backslash
} $} (q_1) 		edge [bend left=60] node        {$
\backslash
left
\backslash
{ x
\backslash
vdash,y
\backslash
vdash
\backslash
right
\backslash
} $} (q_2) 		edge [bend right=60] node[swap]    {$
\backslash
left
\backslash
{  x
\backslash
vdash, 
\backslash
dashv x, y
\backslash
vdash, 
\backslash
dashv y 
\backslash
right
\backslash
} $} (q_3)  		edge [loop above] node        {$
\backslash
Sigma$} ()  	  (q_1) edge 	          node        {$
\backslash
left
\backslash
{ y
\backslash
vdash
\backslash
right
\backslash
} $} (q_2) 		edge [bend right=30] node[swap]        {$
\backslash
left
\backslash
{ 
\backslash
dashv x, y
\backslash
vdash, 
\backslash
dashv y 
\backslash
right
\backslash
} $} (q_3)  		edge [loop above] node        {a} (q_2)  	  (q_2) edge   
           node       {$
\backslash
left
\backslash
{ 
\backslash
dashv x,
\backslash
dashv y
\backslash
right
\backslash
} $} (q_3)  		edge [loop above] node        {b} ()  	  (q_3) edge [loop
 above] node        {$
\backslash
Sigma$} ();  
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:op-clos"

\end_inset

An operation-closed well-behaved eVset-automaton 
\begin_inset Formula $A'$
\end_inset

, with 
\begin_inset Formula $\left\llbracket A'\right\rrbracket =\left\llbracket A\right\rrbracket $
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 is the automaton from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:evset"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
Consider the well-behaved eVset-automaton 
\begin_inset Formula $A'$
\end_inset

 from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:op-clos"

\end_inset

.
 
\begin_inset Formula $A'$
\end_inset

 is operation-closed.
 The reader can verify that 
\begin_inset Formula $\left\llbracket A'\right\rrbracket =\left\llbracket A\right\rrbracket $
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 is the eVset-automaton from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:evset"

\end_inset

.
\end_layout

\begin_layout Standard
As the next proposition states, given a well-behaved eVset-automaton, we
 can always find an equivalent operation-closed well-behaved eVset-automaton.
 This manipulation of a well-behaved eVset-automaton, along with the fact
 that it is always possible, ensures the applicability of the join construction.
\end_layout

\begin_layout Proposition
\begin_inset CommandInset label
LatexCommand label
name "well-b-to-op-clos"

\end_inset

Given a well-behaved eVset-automaton 
\begin_inset Formula $A$
\end_inset

, there exists an operation-closed well-behaved eVset-automaton 
\begin_inset Formula $A'$
\end_inset

 such that 
\begin_inset Formula $\left\llbracket A'\right\rrbracket =\left\llbracket A\right\rrbracket $
\end_inset

.
 Moreover, the size of 
\begin_inset Formula $A'$
\end_inset

 is cubic in the size of 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Proof
Let us consider 
\begin_inset Formula $A=\left(Q,q_{0},q_{f},\delta\right)$
\end_inset

.
 Without loss of generality, we can assume that 
\begin_inset Formula $A$
\end_inset

 is pruned.
 Then we can take 
\begin_inset Formula $A'=\left(Q',q_{0}',q_{f}',\delta'\right)$
\end_inset

, where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Q'=Q$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $q_{0}'=q_{0}$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $q_{f}'=q_{f}$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\begin{aligned}\delta'= & \delta\cup\left\{ \left(q,\bigcup_{i=1}^{n}\textrm{Ops}\left(t_{i}\right),q'\right)\mid\exists p=t_{1},\ldots,t_{n}\in\textrm{Paths}\left(A\right):p=p_{q}^{q'},\right.\\
 & \left.\textrm{ \ensuremath{p} is operation-only}\right\} \textrm{.}
\end{aligned}
$
\end_inset


\end_layout

\end_deeper
\begin_layout Proof
This construction does nothing but including in 
\begin_inset Formula $A'$
\end_inset

 the transitions that are missing in 
\begin_inset Formula $A$
\end_inset

 to be operation-closed.
 
\begin_inset Formula $A'$
\end_inset

 is well-behaved because for each new operation transition 
\begin_inset Formula $t$
\end_inset

 between 
\begin_inset Formula $q,q'\in Q$
\end_inset

 and each operation-only path 
\begin_inset Formula $p=p_{q}^{q'}$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

 we have that 
\begin_inset Formula $\textrm{Ops}\left(t\right)=\textrm{Ops}\left(p\right)$
\end_inset

 (see Corollary 
\begin_inset CommandInset ref
LatexCommand ref
reference "same-ops"

\end_inset

).
 Let us show that, for every string 
\begin_inset Formula $\mathbf{s}\in\Sigma^{\ast}$
\end_inset

, 
\begin_inset Formula $\left\llbracket A'\right\rrbracket \left(\mathbf{s}\right)=\left\llbracket A\right\rrbracket \left(\mathbf{s}\right)$
\end_inset

.
 To see that 
\begin_inset Formula $\left\llbracket A'\right\rrbracket \left(\mathbf{s}\right)\subseteq\left\llbracket A\right\rrbracket \left(\mathbf{s}\right)$
\end_inset

, consider an accepting run 
\begin_inset Formula $\rho'$
\end_inset

 of 
\begin_inset Formula $A'$
\end_inset

 on 
\begin_inset Formula $\mathbf{s}$
\end_inset

, that returns an 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuple 
\begin_inset Formula $\mu$
\end_inset

.
 This run is supported by a complete path 
\begin_inset Formula $p'$
\end_inset

 in 
\begin_inset Formula $A'$
\end_inset

.
 We can always find a complete path 
\begin_inset Formula $p$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

 that supports a run 
\begin_inset Formula $\rho$
\end_inset

 of 
\begin_inset Formula $A$
\end_inset

 on 
\begin_inset Formula $\mathbf{s}$
\end_inset

, which returns 
\begin_inset Formula $\mu$
\end_inset

 as well.
 To obtain 
\begin_inset Formula $p$
\end_inset

, we substitute every operation transition 
\begin_inset Formula $t$
\end_inset

 in 
\begin_inset Formula $p'$
\end_inset

 that does not belong to 
\begin_inset Formula $\delta$
\end_inset

 with an operation-only path 
\begin_inset Formula $p''$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

 such that 
\begin_inset Formula $\textrm{Ops}\left(p''\right)=\textrm{Ops}\left(t\right)$
\end_inset

 and 
\begin_inset Formula $p''$
\end_inset

 is between the source and destination states of 
\begin_inset Formula $t$
\end_inset

.
 This is always possible by construction of 
\begin_inset Formula $A'$
\end_inset

.
 It is easy to verify that the run 
\begin_inset Formula $\rho$
\end_inset

 of 
\begin_inset Formula $A$
\end_inset

 on 
\begin_inset Formula $\mathbf{s}$
\end_inset

, supported by 
\begin_inset Formula $p$
\end_inset

, returns indeed 
\begin_inset Formula $\mu$
\end_inset

, thus the details are omitted.
 
\begin_inset Formula $\left\llbracket A\right\rrbracket \left(\mathbf{s}\right)\subseteq\left\llbracket A'\right\rrbracket \left(\mathbf{s}\right)$
\end_inset

 is also true, because we include all the transitions belonging to 
\begin_inset Formula $\delta$
\end_inset

 in 
\begin_inset Formula $\delta'$
\end_inset

.
 Because of Corollary 
\begin_inset CommandInset ref
LatexCommand ref
reference "same-ops"

\end_inset

, in the worst case we add a new operation transition of size 
\begin_inset Formula $O\left(\left|\textrm{SVars}\left(A\right)\right|\right)=O\left(\left|A\right|\right)$
\end_inset

 between each pair of states 
\begin_inset Formula $q,q'\in Q$
\end_inset

.
 Hence, the size of 
\begin_inset Formula $A'$
\end_inset

 is cubic in the size of 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
The construction described in the last proposition is the reason why extended
 vset-automata were used for the runtime system instead of plain vset-automata.
 When we construct an operation-closed automaton, starting from an automaton
 that does not have this property, the size of the resulting transition
 function might explode (although it will stay polynomial in the size of
 the original automaton).
 The ability to include multiple variable operations in a single transition
 allows for a more compact representation, that is also easier to manipulate.
 Now that we have seen how to transform a well-behaved eVset-automaton for
 the use of the join construction, we can look at its formal definition.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "wb-prod"

\end_inset

Given two operation-closed well-behaved eVset-automata 
\begin_inset Formula $A=\left(Q_{A},q_{A}^{0},\right.$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $\left.q_{A}^{f},\delta_{A}\right)$
\end_inset

 and 
\begin_inset Formula $B=\left(Q_{B},q_{B}^{0},q_{B}^{f},\delta_{B}\right)$
\end_inset

, their product is an eVset-automaton 
\begin_inset Formula $C=\left(Q,q^{0},q^{f},\delta\right)$
\end_inset

, where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Q=Q_{A}\times Q_{B}$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $q^{0}=\left\langle q_{A}^{0},q_{B}^{0}\right\rangle $
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $q^{f}=\left\langle q_{A}^{f},q_{B}^{f}\right\rangle $
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\delta$
\end_inset

 has the following transitions:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\left(\left\langle q_{A},q_{B}\right\rangle ,\sigma,\left\langle q'_{A},q'_{B}\right\rangle \right)$
\end_inset

 whenever 
\begin_inset Formula $\sigma\in\Sigma$
\end_inset

, 
\begin_inset Formula $\left(q_{A},\sigma,q'_{A}\right)\in\delta_{A}$
\end_inset

 and 
\begin_inset Formula $\left(q_{B},\sigma,q'_{B}\right)\in\delta_{B}$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(\left\langle q_{A},q_{B}\right\rangle ,S_{A}\cup S_{B},\left\langle q'_{A},q'_{B}\right\rangle \right)$
\end_inset

 whenever 
\begin_inset Formula $\left(q_{A},S_{A},q'_{A}\right)\in\delta_{A}$
\end_inset

, 
\begin_inset Formula $\left(q_{B},S_{B},q'_{B}\right)\in\delta_{B}$
\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVOps}\left(B\right)\cap S_{A}=\textrm{SVOps}\left(A\right)\cap S_{B}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(\left\langle q_{A},q_{B}\right\rangle ,S_{A},\left\langle q'_{A},q{}_{B}\right\rangle \right)$
\end_inset

 whenever 
\begin_inset Formula $\left(q_{A},S_{A},q'_{A}\right)\in\delta_{A}$
\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVOps}\left(B\right)\cap S_{A}=\emptyset$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(\left\langle q_{A},q_{B}\right\rangle ,S_{B},\left\langle q_{A},q'_{B}\right\rangle \right)$
\end_inset

 whenever 
\begin_inset Formula $\left(q_{B},S_{B},q'_{B}\right)\in\delta_{B}$
\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{SVOps}\left(A\right)\cap S_{B}=\emptyset$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Definition
We write 
\begin_inset Formula $C=A\otimes B$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
We can now state the following theorem.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "ext-join"

\end_inset

Given two operation-closed well-behaved eVset-automata 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, and given an eVset-automaton 
\begin_inset Formula $C$
\end_inset

 such that 
\begin_inset Formula $C=A\otimes B$
\end_inset

, then 
\begin_inset Formula $\left\llbracket C\right\rrbracket =\left\llbracket A\right\rrbracket \bowtie\left\llbracket B\right\rrbracket $
\end_inset

.
 Moreover, 
\begin_inset Formula $C$
\end_inset

 is well-behaved, and can be obtained in quadratic time.
 
\end_layout

\begin_layout Proof
This proof is similar to the proof for the analogous construction for plain
 vset-automata described in 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

.
 To show that 
\begin_inset Formula $\left\llbracket C\right\rrbracket \subseteq\left\llbracket A\right\rrbracket \bowtie\left\llbracket B\right\rrbracket $
\end_inset

, we can decompose a run of 
\begin_inset Formula $C$
\end_inset

 on a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

 into two consistent runs of 
\begin_inset Formula $\rho_{A}$
\end_inset

 of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $\rho_{B}$
\end_inset

 of 
\begin_inset Formula $B$
\end_inset

.
 Two runs 
\begin_inset Formula $\rho$
\end_inset

, 
\begin_inset Formula $\rho'$
\end_inset

, with supporting paths 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $p'$
\end_inset

 respectively, are consistent with each other if, for every pair of operations
 
\begin_inset Formula $o,o'$
\end_inset

 both belonging to 
\begin_inset Formula $\textrm{Ops}\left(p\right)$
\end_inset

 and 
\begin_inset Formula $\textrm{Ops}\left(p'\right)$
\end_inset

, 
\begin_inset Formula $o$
\end_inset

 appears before 
\begin_inset Formula $o'$
\end_inset

 in 
\begin_inset Formula $\textrm{LOps}\left(p\right)$
\end_inset

 if and only if the same holds for 
\begin_inset Formula $\textrm{LOps}\left(p'\right)$
\end_inset

.
 Since a run of 
\begin_inset Formula $C$
\end_inset

 represents two parallel runs of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 by construction, the decomposition aims to isolate the two individual runs
 of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

.
 The details of this decomposition are not difficult to figure out, and
 are omitted.
 To show that 
\begin_inset Formula $\left\llbracket A\right\rrbracket \bowtie\left\llbracket B\right\rrbracket \subseteq\left\llbracket C\right\rrbracket $
\end_inset

, let us consider a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

, a 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuple 
\begin_inset Formula $\mu_{A}\in\left\llbracket A\right\rrbracket \left(\mathbf{s}\right)$
\end_inset

 and a 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuple 
\begin_inset Formula $\mu_{B}\in\left\llbracket B\right\rrbracket \left(\mathbf{s}\right)$
\end_inset

 that assigns the same spans as 
\begin_inset Formula $\mu_{A}$
\end_inset

 to the variables they have in common.
 Given the 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuple 
\begin_inset Formula $\mu$
\end_inset

 that contains all the variable assignments of 
\begin_inset Formula $\mu_{A}$
\end_inset

 and 
\begin_inset Formula $\mu_{B}$
\end_inset

, we need to find a run 
\begin_inset Formula $\rho$
\end_inset

 of 
\begin_inset Formula $C$
\end_inset

 on 
\begin_inset Formula $\mathbf{s}$
\end_inset

 that returns 
\begin_inset Formula $\mu$
\end_inset

.
 Let us call 
\begin_inset Formula $\rho_{A}\in\textrm{ARuns}\left(A,\mathbf{s}\right)$
\end_inset

 and 
\begin_inset Formula $\rho_{B}\in\textrm{ARuns}\left(B,\mathbf{s}\right)$
\end_inset

 the runs that return 
\begin_inset Formula $\mu_{A}$
\end_inset

 and 
\begin_inset Formula $\mu_{B}$
\end_inset

, respectively.
 We can obtain 
\begin_inset Formula $\rho$
\end_inset

 by combining 
\begin_inset Formula $\rho_{A}$
\end_inset

 and 
\begin_inset Formula $\rho_{B}$
\end_inset

.
 For this construction to work, 
\begin_inset Formula $\rho_{A}$
\end_inset

 and 
\begin_inset Formula $\rho_{B}$
\end_inset

 need to be consistent on the order of the variable operations they perform.
 Since 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are well-behaved and operation-closed, 
\begin_inset Formula $\rho_{A}$
\end_inset

 and 
\begin_inset Formula $\rho_{B}$
\end_inset

 can always be selected so that they are consistent.
 Again the details of this construction are straightforward and are not
 reported.
 Moreover, it is easy to see that 
\begin_inset Formula $C$
\end_inset

 is well-behaved by construction.
 To obtain 
\begin_inset Formula $C=A\otimes B$
\end_inset

 algorithmically, the simplest approach is to compare all the possible pairs
 of transitions 
\begin_inset Formula $t_{A}\in\delta_{A},t_{b}\in\delta_{B}$
\end_inset

, and to generate, for each pair, a new transition, according to the rules
 provided by Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "wb-prod"

\end_inset

.
 The cost of generating a new transition from 
\begin_inset Formula $t_{A}$
\end_inset

 and 
\begin_inset Formula $t_{B}$
\end_inset

 is 
\begin_inset Formula $O\left(\left|t_{A}\right|+\left|t_{B}\right|\right)$
\end_inset

, the most costly case being the one involving two operation-transitions.
 Let us consider the size of the input as 
\begin_inset Formula $n=\left|A\right|+\left|B\right|$
\end_inset

.
 The running time for obtaining 
\begin_inset Formula $C$
\end_inset

 is then equal to 
\begin_inset Formula $\sum_{t_{A}\in\delta_{A},t_{B}\in\delta_{B}}O\left(\left|t_{A}\right|+\left|t_{B}\right|\right)=\sum_{t_{A}\in\delta_{A},t_{B}\in\delta_{B}}O\left(\left|t_{A}\right|\right)+\sum_{t_{A}\in\delta_{A},t_{B}\in\delta_{B}}O\left(\left|t_{B}\right|\right)=\sum_{t_{B}\in\delta_{B}}\sum_{t_{A}\in\delta_{A}}O\left(\left|t_{A}\right|\right)+\sum_{t_{A}\in\delta_{A}}\sum_{t_{B}\in\delta_{B}}O\left(\left|t_{B}\right|\right)=O\left(\left|\delta_{B}\right|\cdot\left|\delta_{A}\right|\right)+O\left(\left|\delta_{A}\right|\cdot\left|\delta_{B}\right|\right)=$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
In the previous chapter, we saw that the Core Simplification Lemma allows
 us to represent core spanners in a convenient way, based on vset-automata.
 What about well-behaved eVset-automata? Does a similar statement hold?
 The answer is affirmative, and in the following we will prove this claim.
 First of all, let us reason on the relative expressive power of eVset-automata
 with respect to plain vset-automata.
\end_layout

\begin_layout Lemma
\noindent
\begin_inset CommandInset label
LatexCommand label
name "eVset-to-plain"

\end_inset

Given an eVset-automaton 
\begin_inset Formula $A=\left(Q,q_{0},q_{f},\delta\right)$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

 can be converted in linear time into a vset-automaton 
\begin_inset Formula $A'$
\end_inset

 such that 
\begin_inset Formula $\left\llbracket A'\right\rrbracket =\left\llbracket A\right\rrbracket $
\end_inset

, in a well-behavedness preserving manner
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Notice that I didn't define well-behavedness in the case of a plain vset-automat
on.
 Nonetheless, the idea underlying the definition for extended vset-automata
 remains unchanged and the actual definition for a standard vset-automaton
 is not difficult to figure out.
\end_layout

\end_inset

.
\end_layout

\begin_layout Proof
Without loss of generality, we consider an ordering of the symbols in 
\begin_inset Formula $\textrm{SVOps}\left(A\right)$
\end_inset

 of the following form:
\begin_inset Formula 
\[
x\vdash,\ldots,y\vdash,\dashv x,\ldots,\dashv y
\]

\end_inset

 In this ordering, all insertion operations come before the deletion operations.
 Let us define 
\begin_inset Formula $o\prec o'$
\end_inset

, with 
\begin_inset Formula $o,o'\in\textrm{SVOps}\left(A\right)$
\end_inset

, if 
\begin_inset Formula $o$
\end_inset

 comes before 
\begin_inset Formula $o'$
\end_inset

 (
\emph on
not
\emph default
 if they are equal) in the chosen ordering.
 Consider 
\begin_inset Formula $A'=$
\end_inset


\begin_inset Formula $\left(Q',q_{0}',q_{f}',\delta'\right)$
\end_inset

, with 
\begin_inset Formula $\textrm{SVars}\left(A'\right)=\textrm{SVars}\left(A\right)$
\end_inset

, whose components are defined as follows:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Q'=Q\cup Q^{\textrm{ops}}\cup Q^{\emptyset}$
\end_inset

, where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Q^{\textrm{ops}}=\left\{ q_{q',o,q''}\mid\exists\left(q',S,q''\right)\in\delta:o\in S\right\} $
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $Q^{\emptyset}=\left\{ q_{q',\emptyset,q''}\mid\exists\left(q',\emptyset,q''\right)\in\delta\right\} $
\end_inset

;
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $q_{0}'=q_{0};$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $q_{f}'=q_{f}$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $\delta'=\left(\delta\setminus\delta^{S}\right)\cup\delta^{\textrm{ops}}\cup\delta^{\emptyset}\cup\delta^{\epsilon}$
\end_inset

, where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\delta^{S}=\left\{ \left(q,S,q'\right)\in\delta\right\} ;$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\begin{aligned}\delta^{\textrm{ops}}= & \left\{ \left(q_{q',o,q''},o,q_{q',o',q''}\right)\mid\exists\left(q',S,q''\right)\in\delta:\left(o,o'\in S\land o\prec o'\land\right.\right.\\
 & \left.\left.\forall o''\in S:o\nprec o''\nprec o'\right)\right\} \cup\left\{ \left(q_{q',o,q''},o,q''\right)\mid\exists\left(q',S,q''\right)\in\delta:\right.\\
 & \left.\left(o\in S\land\forall o'\in S:o\nprec o'\right)\right\} \textrm{;}
\end{aligned}
$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\delta^{\emptyset}=\left\{ \left(q_{q',\emptyset,q''},\epsilon,q''\right)\mid\exists\left(q',\emptyset,q''\right)\in\delta\right\} ;$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\begin{aligned}\delta^{\epsilon}= & \left\{ \left(q,\epsilon,q'\right)\mid\left(\left(\exists\left(q',o,q''\right)\in\delta^{\textrm{ops}}:\forall\left(q',o',q''\right)\in\delta^{\textrm{ops}}:o'\nprec o\right)\lor\right.\right.\\
 & \left.\left.\left(\exists\left(q',\epsilon,q''\right)\in\delta^{\emptyset}\right)\right)\land\left(\exists\left(q,S,q'''\right)\in\delta\right)\right\} \textrm{.}
\end{aligned}
$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Proof
This construction expands the transitions of 
\begin_inset Formula $A$
\end_inset

 that are labeled with a set of variable operations into a sequence of transitio
ns performing one operation at a time, taking care of putting the insertion
 operations before the deletion ones.
 This construction clearly preserves well-behavedness, because each complete
 path 
\begin_inset Formula $p'$
\end_inset

 in 
\begin_inset Formula $A'$
\end_inset

 is obtained from a path 
\begin_inset Formula $p$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

, preserving the original operations of 
\begin_inset Formula $p$
\end_inset

 and ensuring a correct order of their appearance (if 
\begin_inset Formula $A$
\end_inset

 is well-behaved).
 Each sequence starts with an 
\begin_inset Formula $\epsilon$
\end_inset

-transition.
 This is not necessary in principle, but it allows to reduce the complexity
 of the formulation.
 The construction also substitutes transitions labeled with the empty set
 with ordinary 
\begin_inset Formula $\epsilon$
\end_inset

-transitions.
 To prove the equivalence between 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $A'$
\end_inset

 it is sufficient to notice that for every string 
\begin_inset Formula $\mathbf{s}$
\end_inset

, every run belonging to 
\begin_inset Formula $\textrm{ARuns}\left(A,\mathbf{s}\right)$
\end_inset

 can be put in correspondence with a run belonging to 
\begin_inset Formula $\textrm{ARuns}\left(A',\mathbf{s}\right)$
\end_inset

, and vice versa.
 Indeed, if we start from 
\begin_inset Formula $\rho\in\textrm{ARuns}\left(A,\mathbf{s}\right)$
\end_inset

 we can obtain a run 
\begin_inset Formula $\textrm{\rho'\in ARuns}\left(A',\mathbf{s}\right)$
\end_inset

 that spans the same 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuple 
\begin_inset Formula $\mu$
\end_inset

.
 It is sufficient to expand configuration pairs in 
\begin_inset Formula $\rho$
\end_inset

 whose current states are linked in 
\begin_inset Formula $A$
\end_inset

 by a transition 
\begin_inset Formula $t$
\end_inset

, which we expand in 
\begin_inset Formula $A'$
\end_inset

, with a series of configurations that let us perform the set of variable
 operations in 
\begin_inset Formula $t$
\end_inset

 one at a time.
 This is always possible by construction of 
\begin_inset Formula $A'$
\end_inset

.
 If we start from 
\begin_inset Formula $\textrm{\rho'\in ARuns}\left(A',\mathbf{s}\right)$
\end_inset

, we can obtain an equivalent run 
\begin_inset Formula $\rho\in\textrm{ARuns}\left(A,\mathbf{s}\right)$
\end_inset

 in the opposite way, by compressing consecutive configurations.
 The details are omitted.
\end_layout

\begin_layout Proof
\noindent
It remains to show that the construction of 
\begin_inset Formula $A'$
\end_inset

 can be carried in linear time.
 Let us refer to the size of 
\begin_inset Formula $A$
\end_inset

 as 
\begin_inset Formula $n$
\end_inset

.
 With the usual assumptions, expanding a single transition 
\begin_inset Formula $t$
\end_inset

 of 
\begin_inset Formula $A$
\end_inset

 takes 
\begin_inset Formula $O\left(\left|t\right|\right)$
\end_inset

 time.
 Expanding every transition that is needed will then take 
\begin_inset Formula $O\left(\sum_{t\in\delta}O\left(\left|t\right|\right)\right)=O\left(n\right)$
\end_inset

 time.
\end_layout

\begin_layout Standard
The opposite direction is also true.
\end_layout

\begin_layout Lemma
\noindent
Given a vset-automaton 
\begin_inset Formula $A=\left(Q,q_{0},q_{f},\delta\right)$
\end_inset

, an eVset-automaton 
\begin_inset Formula $A'$
\end_inset

 can be found in linear time such that 
\begin_inset Formula $\left\llbracket A'\right\rrbracket =\left\llbracket A\right\rrbracket $
\end_inset

, in a well-behavedness preserving manner.
\end_layout

\begin_layout Proof
In this case it is sufficient to replace every transition 
\begin_inset Formula $t$
\end_inset

 performing a variable operation 
\begin_inset Formula $o$
\end_inset

 in 
\begin_inset Formula $A$
\end_inset

 with an operation transition 
\begin_inset Formula $t'$
\end_inset

 in 
\begin_inset Formula $A'$
\end_inset

 such that 
\begin_inset Formula $\textrm{Ops}\left(t'\right)=\left\{ o\right\} $
\end_inset

 and 
\begin_inset Formula $\textrm{LOps}\left(t'\right)=o$
\end_inset

 .
 
\begin_inset Formula $\epsilon$
\end_inset

-transitions can be replaced by operation transitions with an empty set.
 We need to show that this construction can be carried out in linear time.
 We do not have a definition of the size of a vset-automaton, but we can
 easily adapt Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "size-evset"

\end_inset

: the only difference is that every transition in the transition function
 weights 
\begin_inset Formula $3$
\end_inset

.
 With this assumption, this construction can be obtained in linear time,
 as its time complexity has a similar expression to that of the construction
 discussed in the previous lemma.
 It is easy to verify equivalence, and that well-behavedness is preserved,
 thus the details are omitted.
\end_layout

\begin_layout Standard
These results are interesting.
 In particular, Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "eVset-to-plain"

\end_inset

 ensures that any well-behaved eVset-automaton, opportunely extended with
 the needed algebraic operators, represents a query belonging to the core
 fragment of AQL.
 Is also the inverse true? As mentioned, the runtime system works only with
 well-behaved eVset-automata.
 Then, for the system to have full applicability, it must hold that an AQL
 core query can be represented by a well-behaved eVset-automaton (extended
 with the needed operators).
 This is indeed the case, as we are going to see.
 According to Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "core-def"

\end_inset

, an AQL core query is a set of regex formulas combined by using the operators
 described in Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Algebras-of-Spanners"

\end_inset

.
 The first step is to prove that a regex formula can always be converted
 into a well-behaved eVset-automaton.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "regex-to-well"

\end_inset

Given a regex formula 
\begin_inset Formula $\gamma$
\end_inset

, a well-behaved eVset-automaton 
\begin_inset Formula $A$
\end_inset

 can be found in polynomial time such that 
\begin_inset Formula $\left\llbracket A\right\rrbracket =\left\llbracket \gamma\right\rrbracket $
\end_inset

.
\end_layout

\begin_layout Proof
It is well known that there exists a polynomial-time method to generate
 an NFA corresponding to a regular expression 
\begin_inset Formula $r$
\end_inset

.
 This method generates the NFA inductively while parsing 
\begin_inset Formula $r$
\end_inset

.
 A description of the method is available in, e.g., 
\begin_inset CommandInset citation
LatexCommand cite
key "cox_2007"

\end_inset

.
 This procedure does not deal with submatch extraction, thus we need to
 describe how to handle the 
\begin_inset Formula $x\left\{ \cdot\right\} $
\end_inset

 operator, 
\begin_inset Formula $x\in\textrm{SVars}\left(\gamma\right)$
\end_inset

.
 We can add the following fragment to 
\begin_inset Formula $A$
\end_inset

:
\end_layout

\begin_layout Proof
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{centering}
\end_layout

\end_inset


\end_layout

\begin_layout Proof
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Proof
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto]  
\backslash
node[state,  draw=none]     	  (q_00) 	         {}; 
\backslash
node[state]   		  (q_0)  [right=of q_00] {}; 
\backslash
node[state, rectangle]   (q_1) [right=of q_0]   {$e$}; 
\backslash
node[state, draw=none]   (q_2) [right=of q_1] {};  
\backslash
path[->] (q_00) edge              node        {} (q_0) 	  (q_0)  edge  
            node        {$
\backslash
left
\backslash
{ x
\backslash
vdash
\backslash
right
\backslash
} $} (q_1)  	  (q_1)  edge 	          node        {$
\backslash
left
\backslash
{ 
\backslash
dashv x
\backslash
right
\backslash
} $} (q_2); 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Proof
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Proof
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{centering}
\end_layout

\end_inset


\end_layout

\begin_layout Proof
\noindent
where the rectangle with label 
\begin_inset Formula $e$
\end_inset

 is the part of 
\begin_inset Formula $A$
\end_inset

 representing the subexpression of 
\begin_inset Formula $\gamma$
\end_inset

 contained in 
\begin_inset Formula $x\left\{ \cdot\right\} $
\end_inset

.
 The fact that the arrow pointing to the leftmost state comes from nowhere
 means that the fragment is connected to whichever state came before it,
 and, similarly, the arrow coming out of the rectangle is going nowhere
 because we connect it to the state that comes after.
 We could also merge consecutive operation transitions in 
\begin_inset Formula $A$
\end_inset

, to fully exploit the fact that it is an eVset-automaton, without altering
 the runtime complexity.
 Correctness follows from the correctness of the single fragments generated,
 which is easy to verify.
 Finally, 
\begin_inset Formula $A$
\end_inset

 is well-behaved, because of the construction we used, along with the fact
 that the new fragment for span capturing cannot appear in a loop and that
 every path in 
\begin_inset Formula $A$
\end_inset

 spans the same variables (because 
\begin_inset Formula $\gamma$
\end_inset

 is syntactically 
\begin_inset Formula $\textrm{SVars}\left(\gamma\right)$
\end_inset

-functional).
\end_layout

\begin_layout Standard
Let us call the class of well-behaved eVset-automata 
\begin_inset Formula $\textrm{VA}_{\textrm{WESet}}$
\end_inset

.
 By combining Theorems 
\begin_inset CommandInset ref
LatexCommand ref
reference "regex-to-well"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "ext-union"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "ext-join"

\end_inset

 and Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "eVset-to-plain"

\end_inset

, we can state the following theorem.
\end_layout

\begin_layout Theorem
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left\llbracket \textrm{RGX}^{\left\{ \cup,\pi,\bowtie,\varsigma^{=}\right\} }\right\rrbracket =\left\llbracket \textrm{VA}_{\textrm{WESet}}^{\left\{ \cup,\pi,\bowtie,\varsigma^{=}\right\} }\right\rrbracket =\left\llbracket \textrm{VA}_{\textrm{WESet}}^{\left\{ \pi,\varsigma^{=}\right\} }\right\rrbracket $
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\begin_layout Proof
Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "regex-to-well"

\end_inset

 tells us that 
\begin_inset Formula $\left\llbracket \textrm{RGX}\right\rrbracket \subseteq\left\llbracket \textrm{VA}_{\textrm{WESet}}\right\rrbracket $
\end_inset

.
 Thus we can state that
\end_layout

\begin_layout Proof
\begin_inset Formula 
\begin{equation}
\left\llbracket \textrm{RGX}^{\left\{ \cup,\pi,\bowtie,\varsigma^{=}\right\} }\right\rrbracket \subseteq\left\llbracket \textrm{VA}_{\textrm{WESet}}^{\left\{ \cup,\pi,\bowtie,\varsigma^{=}\right\} }\right\rrbracket 
\end{equation}

\end_inset


\end_layout

\begin_layout Proof
Moreover, Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "eVset-to-plain"

\end_inset

 and Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "RGX=SET"

\end_inset

 imply that
\end_layout

\begin_layout Proof
\begin_inset Formula 
\begin{equation}
\left\llbracket \textrm{VA}_{\textrm{WESet}}^{\left\{ \cup,\pi,\bowtie,\varsigma^{=}\right\} }\right\rrbracket \subseteq\left\llbracket \textrm{VA}_{\textrm{set}}^{\left\{ \cup,\pi,\bowtie,\varsigma^{=}\right\} }\right\rrbracket =\left\llbracket \textrm{RGX}^{\left\{ \cup,\pi,\bowtie,\varsigma^{=}\right\} }\right\rrbracket 
\end{equation}

\end_inset


\end_layout

\begin_layout Proof
Finally, Theorems 
\begin_inset CommandInset ref
LatexCommand ref
reference "ext-union"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "ext-join"

\end_inset

 justify the right-hand equality in the statement of this theorem.
\end_layout

\begin_layout Standard
We can also formulate a modified version of the Core Simplification Lemma
 (Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "Core-simplif"

\end_inset

).
 The proof is very similar to that of the original lemma, which can be found
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

, and is omitted here.
\end_layout

\begin_layout Lemma
Every core spanner can be defined by an expression of the form
\end_layout

\begin_layout Lemma
\begin_inset Formula 
\begin{equation}
\pi_{V}SA
\end{equation}

\end_inset


\end_layout

\begin_layout Lemma
\noindent
where:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $A$
\end_inset

 is a well-behaved eVset-automaton;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $V\subseteq\textrm{SVars}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $S$
\end_inset

 is a sequence of string selections 
\begin_inset Formula $\varsigma_{x,y}^{=}$
\end_inset

, for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $x,y\in\textrm{SVars}\left(A\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
In this chapter, eVset-automata were introduced.
 Then, a particular kind of eVset-automata, well-behaved eVset-automata,
 that I use in the runtime system, was discussed: we saw that an execution
 engine for these automata is less complex than one for generic eVset-automata.
 Then, I proved that we can simulate the operators in the algebra 
\begin_inset Formula $\left\{ \pi,\cup,\bowtie\right\} $
\end_inset

 by combining the input automata with polynomial-time procedures, that return
 well-behaved eVset-automata.
 Finally, I have shown that well-behaved eVset-automata can be used to convenien
tly represent core spanners.
 The next chapter is a discussion of the actual implementation of the runtime
 system.
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Implementation"

\end_inset

Implementation
\end_layout

\begin_layout Standard
This chapter describes the implementation of the runtime system.
 The outline of the chapter is the following.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-Thompson-Approach"

\end_inset

 describes an idealized engine for the evaluation of an NFA on a string,
 originally proposed by Ken Thompson.
 A modified version of this engine is used in the runtime system for evaluating
 core spanners, by means of representations based on well-behaved eVset-automata.
 In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Implementation"

\end_inset

, I discuss the actual implementation of the runtime system.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-Thompson-Approach"

\end_inset

A Method for NFA Execution: The Thompson Approach
\end_layout

\begin_layout Standard
Given a regular expression 
\begin_inset Formula $r$
\end_inset

, its corresponding NFA 
\begin_inset Formula $A$
\end_inset

 and a string 
\begin_inset Formula $\mathbf{s}$
\end_inset

, the Thompson algorithm will try all the feasible runs of 
\begin_inset Formula $A$
\end_inset

 on 
\begin_inset Formula $\mathbf{s}$
\end_inset

 at the same time.
 More precisely, the method iterates over the characters of 
\begin_inset Formula $\mathbf{s}$
\end_inset

 and, for each iteration, there is a set of current states, each representing
 the advancement in a feasible run.
 The following steps are performed in an iteration of the algorithm: the
 set of outgoing transitions, for each current state, is examined, all 
\begin_inset Formula $\epsilon$
\end_inset

-transitions are fired iteratively and, subsequently, any transition labeled
 with the character corresponding to the current one is fired.
 This produces a new set of states and the execution continues as described.
 
\begin_inset Formula $\mathbf{s}$
\end_inset

 is matched by 
\begin_inset Formula $A$
\end_inset

 if, at the end of the execution, all the symbols of 
\begin_inset Formula $\mathbf{s}$
\end_inset

 have been consumed and at least one state in the current state set is an
 accepting state.
 It can be shown that the time complexity of this approach is 
\begin_inset Formula $O\left(mn\right)$
\end_inset

, where 
\begin_inset Formula $m$
\end_inset

 is the size of 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

 is the size of 
\begin_inset Formula $\mathbf{s}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Usually, we accept 
\emph on
partial matching
\emph default
: we don't require that a regular expression reaches the end of the input
 string to produce a match.
 In terms of the corresponding automaton, we consider as accepting a run
 that ends in the final state even if it didn't scan the whole string.
 This is useful for implementing 
\emph on
unanchored matching,
\emph default
 where we want to obtain not only the matches starting from the beginning
 of a string
\emph on
, 
\emph default
but also those starting from its suffixes
\emph on
.
 
\emph default
The regular expressions in AQL queries perform unanchored matching transparently
 to the user: they automatically scan the input document for matches.
 Thus, this kind of matching is implicitly adopted by the runtime system
 too.

\emph on
 
\emph default
The regular expressions of AQL retain all the matches they can find.
 Instead, the traditional Thompson algorithm produces a single match.
 Thus, for the original procedure, partial matching poses the problem of
 ambiguous matches.
 This is why concrete algorithms implement a policy to discriminate among
 multiple possible matches (e.g., greedy leftmost).
 For more information on the Thompson approach, see 
\begin_inset CommandInset citation
LatexCommand cite
key "cox_2007"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\backslash
begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
\backslash
node[state,initial]  (q_0)                      {$q_0$}; 
\backslash
node[state]          (q_1) [above right=of q_0] {$q_1$}; 
\backslash
node[state]          (q_2) [below right=of q_0] {$q_2$}; 
\backslash
node[state,accepting](q_3) [below right=of q_1] {$q_3$}; 
\backslash
path[->] (q_0) edge              node        {a} (q_1) 		edge          
    node [swap] {$
\backslash
epsilon$} (q_2) 	  (q_1) edge [bend left]  node        {a} (q_3) 		edge
 [bend right] node        {b} (q_3) 		edge [loop above] node        {a}
 () 	  (q_2) edge              node [swap] {c} (q_3) 		edge [loop below]
 node        {a} () 	  (q_3) edge [loop right] node        {a} (); 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:thompson-aut"

\end_inset

An 
\begin_inset Formula $\epsilon$
\end_inset

-NFA 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\backslash
begin{tikzpicture}[node distance=2.5cm,auto]     
\backslash
node (one) [align=left] {
\backslash
underline{a}aab 
\backslash

\backslash
$
\backslash
left
\backslash
{ q_{0}, q_{2} 
\backslash
right
\backslash
} $};     
\backslash
node (two) [right of=one,align=left] { a
\backslash
underline{a}ab 
\backslash

\backslash
$
\backslash
left
\backslash
{ q_{1}, q_{2} 
\backslash
right
\backslash
} $};     
\backslash
node (three) [right of=two,align=left] { aa
\backslash
underline{a}b 
\backslash

\backslash
$
\backslash
left
\backslash
{ q_{1}, q_{2}, q_{3} 
\backslash
right
\backslash
} $};     
\backslash
node (four) [right of=three,align=left] {aaa
\backslash
underline{b} 
\backslash

\backslash
$
\backslash
left
\backslash
{ q_{1}, q_{2}, q_{3} 
\backslash
right
\backslash
} $};     
\backslash
node (five) [right of=four,align=left] {aaab
\backslash
underline{ }
\backslash

\backslash
$
\backslash
left
\backslash
{q_{3} 
\backslash
right
\backslash
} $};     
\backslash
path[->] (one) edge node {} (two);     
\backslash
path[->] (two) edge node {} (three);     
\backslash
path[->] (three) edge node {} (four);     
\backslash
path[->] (four) edge node {} (five); 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:thompson-exec"

\end_inset

The execution of 
\begin_inset Formula $A$
\end_inset

 on 'aaab' according to the Thompson approach.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Example-Thompson"

\end_inset

Example of the Thompson algorithm.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
The automaton 
\begin_inset Formula $A$
\end_inset

 of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Example-Thompson"

\end_inset

 accepts the string 
\begin_inset Formula $\mathbf{s}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

'aaab'
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Example-Thompson"

\end_inset

 also illustrates the execution of 
\begin_inset Formula $A$
\end_inset

 on 
\begin_inset Formula $\mathbf{s}$
\end_inset

.
 Notice that the current state set is not a multiset.
 Hence, runs that end up in the same state are naturally merged.
 For instance, if we are in 
\begin_inset Formula $q_{1}$
\end_inset

 and we read an 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{'a'}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em  
\end_layout

\end_inset


\begin_inset space ~
\end_inset

we can go to 
\begin_inset Formula $q_{3}$
\end_inset

, but we can also read an 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{'a'}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

while in 
\begin_inset Formula $q_{3}$
\end_inset

, remaining in that state.
 Nonetheless, in the cases where both 
\begin_inset Formula $q_{1}$
\end_inset

 and 
\begin_inset Formula $q_{3}$
\end_inset

 are in the current state set and an 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{'a'}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em  
\end_layout

\end_inset


\begin_inset space ~
\end_inset

is read, 
\begin_inset Formula $q_{3}$
\end_inset

 appears only once in the next.
 This is because the two originally distinct runs are now equivalent.
 This lets the algorithm keep a reduced list of current states, and justifies
 the runtime complexity presented.
\end_layout

\begin_layout Standard
One interesting implementation of the Thompson algorithm views an NFA as
 a program that can be executed by a virtual machine on a string.
 This method is described in 
\begin_inset CommandInset citation
LatexCommand cite
key "cox_regular_2009"

\end_inset

.
 
\end_layout

\begin_layout Subsubsection
The Virtual Machine Implementation
\end_layout

\begin_layout Standard
In this implementation, an NFA (or a regex) is converted into a program,
 written in a simple assembly language with few instructions.
 The basic instructions are character match (CHAR), string match (MATCH),
 and control flow instructions (SPLIT and JUMP).
 A virtual machine is provided, which treats each concurrent run on a string
 
\begin_inset Formula $\mathbf{s}$
\end_inset

 as a conceptual thread.
 The virtual machine advances all the threads in lockstep, in the spirit
 of the Thompson approach.
 Different threads that reach the same instruction in a program are merged.
 
\end_layout

\begin_layout Standard
The main advantage of this method is that it is easy to enrich the assembly
 language with new instructions, in order to support new features.
 To execute new instructions, modifying the virtual machine is required.
 For instance, capturing groups can be implemented by equipping each thread
 with an array of saved pointers that are grouped by two: the first element
 would point to the beginning of a span of text and the second one would
 point to its end.
 Then, a SAVE instruction could be added, that would make the virtual machine
 record the current position in the input into the pointer specified by
 the instruction.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture} 
\backslash
matrix [ampersand replacement=
\backslash
&]{ 	
\backslash
node {0}; 
\backslash
& 
\backslash
node {CHAR a};    
\backslash

\backslash
 	
\backslash
node {1}; 
\backslash
& 
\backslash
node {SPLIT 0, 2};
\backslash

\backslash
 	
\backslash
node {2}; 
\backslash
& 
\backslash
node {SPLIT 3, 5};
\backslash

\backslash
 	
\backslash
node {3}; 
\backslash
& 
\backslash
node {CHAR b};    
\backslash

\backslash
 	
\backslash
node {4}; 
\backslash
& 
\backslash
node {JUMP 2};    
\backslash

\backslash
 	
\backslash
node {5}; 
\backslash
& 
\backslash
node {MATCH};     
\backslash

\backslash
 	
\backslash
node {}; 
\backslash
& 
\backslash
node {};     
\backslash

\backslash
 	
\backslash
node {}; 
\backslash
& 
\backslash
node {};     
\backslash

\backslash
 	
\backslash
node {}; 
\backslash
& 
\backslash
node {};     
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

}; 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:prog"

\end_inset

A program for the regex 
\begin_inset Formula $\textrm{a}^{+}\textrm{b}^{\ast}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hspace{}
\length 2cm
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture} 
\backslash
matrix [ampersand replacement=
\backslash
&]{ 
\end_layout

\begin_layout Plain Layout

	
\backslash
node{0}; 
\backslash
& 
\backslash
node {SAVE 0};    
\backslash

\backslash
 	
\backslash
node{1}; 
\backslash
& 
\backslash
node {CHAR a};    
\backslash

\backslash
 	
\backslash
node{2}; 
\backslash
& 
\backslash
node {SPLIT 1, 3};
\backslash

\backslash
 	
\backslash
node{3}; 
\backslash
& 
\backslash
node {SAVE 1};    
\backslash

\backslash
 	
\backslash
node{4}; 
\backslash
& 
\backslash
node {SAVE 2};    
\backslash

\backslash
 	
\backslash
node{5}; 
\backslash
& 
\backslash
node {SPLIT 6, 8};
\backslash

\backslash
 	
\backslash
node{6}; 
\backslash
& 
\backslash
node {CHAR b};    
\backslash

\backslash
 	
\backslash
node{7}; 
\backslash
& 
\backslash
node {JUMP 5};    
\backslash

\backslash
 	
\backslash
node{8}; 
\backslash
& 
\backslash
node {SAVE 3};    
\backslash

\backslash
 	
\backslash
node{9}; 
\backslash
& 
\backslash
node {MATCH};     
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

}; 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:prog-capt"

\end_inset

A program for the regex 
\begin_inset Formula $\left(\textrm{a}^{+}\right)\left(\textrm{b}^{\ast}\right)$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Example-programs."

\end_inset

Example programs.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Example
The program (a) in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Example-programs."

\end_inset

 can be used to match the regular expression 
\begin_inset Formula $\textrm{a}^{+}\textrm{b}^{*}$
\end_inset

.
 SPLIT instructions explicitly divide a thread into two, telling each of
 the generated threads which position in the program to reach.
 The program (b) in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Example-programs."

\end_inset

 matches the same expression as program (a), but it retains the substrings
 matching the subexpressions between parentheses too.
\end_layout

\begin_layout Example
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\backslash
begin{tikzpicture} 
\backslash
matrix [ampersand replacement=
\backslash
&]{ 
\end_layout

\begin_layout Plain Layout

	
\backslash
node{0}; 
\backslash
& 
\backslash
node {SPLIT 1, 8};    
\backslash

\backslash
 	
\backslash
node{1}; 
\backslash
& 
\backslash
node {CHAR a};    
\backslash

\backslash
 	
\backslash
node{2}; 
\backslash
& 
\backslash
node {SPLIT 1, 3};
\backslash

\backslash
 	
\backslash
node{3}; 
\backslash
& 
\backslash
node {SPLIT 4, 6};    
\backslash

\backslash
 	
\backslash
node{4}; 
\backslash
& 
\backslash
node {CHAR a};    
\backslash

\backslash
 	
\backslash
node{5}; 
\backslash
& 
\backslash
node {JUMP 7};
\backslash

\backslash
 	
\backslash
node{6}; 
\backslash
& 
\backslash
node {CHAR b};    
\backslash

\backslash
 	
\backslash
node{7}; 
\backslash
& 
\backslash
node {JUMP 12};    
\backslash

\backslash
 	
\backslash
node{8}; 
\backslash
& 
\backslash
node {SPLIT 9, 11};    
\backslash

\backslash
 	
\backslash
node{9}; 
\backslash
& 
\backslash
node {CHAR a};     
\backslash

\backslash
 	
\backslash
node{10}; 
\backslash
& 
\backslash
node {JUMP 8};     
\backslash

\backslash
 	
\backslash
node{11}; 
\backslash
& 
\backslash
node {CHAR c};     
\backslash

\backslash
 	
\backslash
node{12}; 
\backslash
& 
\backslash
node {SPLIT 13, 15};     
\backslash

\backslash
 	
\backslash
node{13}; 
\backslash
& 
\backslash
node {CHAR a};     
\backslash

\backslash
 	
\backslash
node{14}; 
\backslash
& 
\backslash
node {JUMP 12};     
\backslash

\backslash
 	
\backslash
node{15}; 
\backslash
& 
\backslash
node {MATCH};     
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

}; 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:prog-aut"

\end_inset

A program for the automaton 
\begin_inset Formula $A$
\end_inset

 of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Example-Thompson"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Example
The program shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:prog-aut"

\end_inset

 corresponds to the automaton 
\begin_inset Formula $A$
\end_inset

 of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Example-Thompson"

\end_inset

.
 Notice how the 
\begin_inset Formula $\epsilon$
\end_inset

-transition between 
\begin_inset Formula $q_{0}$
\end_inset

 and 
\begin_inset Formula $q_{2}$
\end_inset

 is automatically omitted from the program.
 Blocks of SPLIT instructions correspond to multiple outgoing transitions
 from a state.
 JUMP instructions are used to merge execution branches.
 
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Implementation"

\end_inset

Implementation
\end_layout

\begin_layout Standard
In the system, core spanners are represented by well-behaved eVset-automata,
 for which a set of string equality constraints can be specified on pairs
 of their span variables.
 A final projection, if present, is handled separately.
 Moreover, the implementation fixes 
\begin_inset Formula $\textrm{SVars}=\mathbb{N}$
\end_inset

.
 Hence, span variables are identified by nonnegative integers.
 The execution approach used by the system is radically different from the
 one of SystemT, because instead of realizing algebraic operators as operations
 to apply to the outputs of their arguments as SystemT does, they are simulated
 with the constructions presented in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:EVST-wb"

\end_inset

.
 The system can be used in two modes: 
\end_layout

\begin_layout Description
compilation
\begin_inset space ~
\end_inset

mode: reads an AQL core query and produces an equivalent core spanner representa
tion, using the constructions of Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:EVST-wb"

\end_inset

;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Description
evaluation
\begin_inset space ~
\end_inset

mode: evaluates a core spanner representation on a series of text documents,
 returning, for each of them, a 
\begin_inset Formula $\left(V,\mathbf{s}\right)$
\end_inset

-relation as output.
\end_layout

\begin_layout Standard
The system is single-threaded.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture} 
\backslash
node[rectangle, draw,outer sep=5pt,inner sep=10pt] (a) [align=center] {AQL
 Core 
\backslash

\backslash
 Query}; 
\backslash
node (sp) [outer sep=15pt,inner sep=10pt, align=center, below=of a, draw,
 minimum height=4em, minimum width=3em,  	        fill=white,  	       
 double copy shadow={shadow xshift=4pt,  	                     shadow yshift=4pt
, fill=white, draw}] {Spanner 
\backslash

\backslash
 Repr.
 1}; 
\backslash
node[outer sep=8pt, inner sep=20pt, rectangle, draw, very thick ] (mod)
 [below right=of a, yshift=45pt] {
\backslash
textbf{COMPILATION}}; 
\backslash
node[rectangle, draw,outer sep=5pt,inner sep=10pt] (out) [right=of mod,
 align=center] {Output 
\backslash

\backslash
 Spanner 
\backslash

\backslash
 Repr.};  
\backslash
path [->] (a) edge node {} (mod); 
\backslash
path [->, dashed] (sp) edge node {} (a); 
\backslash
path [->] (sp) edge node {} (mod); 
\backslash
path [->] (mod) edge node {} (out); 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Compilation-mode."

\end_inset

Compilation mode.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture} 
\backslash
node[outer sep=8pt, inner sep=20pt, rectangle, draw, very thick ] (mod)
 {
\backslash
textbf{EVALUATION}}; 
\backslash
node[rectangle, draw,outer sep=5pt,inner sep=10pt] (r1) [above right=of
 mod, align=center, yshift=-38pt] {$R_1$};  
\backslash
node[outer sep=5pt] (sepr) [below=of r1, align=center, yshift=30pt] {
\backslash
textbf{.} 
\backslash

\backslash
 
\backslash
textbf{.} 
\backslash

\backslash
 
\backslash
textbf{.}};  
\backslash
node[rectangle, draw,outer sep=5pt,inner sep=10pt] (rn) [below right=of
 mod, align=center, yshift=38pt] {$R_n$};  
\backslash
node[rectangle, draw,outer sep=5pt,inner sep=10pt] (d1) [above left=of mod,
 align=center, yshift=-38pt] {$D_1$};  
\backslash
node[outer sep=5pt] (sep) [below=of d1, align=center, yshift=30pt] {
\backslash
textbf{.} 
\backslash

\backslash
 
\backslash
textbf{.} 
\backslash

\backslash
 
\backslash
textbf{.}};  
\backslash
node[rectangle, draw,outer sep=5pt,inner sep=10pt] (dn) [below left=of mod,
 align=center, yshift=38pt] {$D_n$};  
\backslash
node[rectangle, draw,outer sep=5pt,inner sep=10pt] (sp) [align=center, above=of
 d1, xshift=10pt,yshift=-20pt] {Spanner 
\backslash

\backslash
 Repr.}; 
\backslash
draw [->] (sp) -| (mod); 
\backslash
path [->] (d1) edge node {} (mod); 
\backslash
path [->] (dn) edge node {} (mod); 
\backslash
path [->] (mod) edge node {} (r1); 
\backslash
path [->] (mod) edge node {} (rn); 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Evaluation-mode."

\end_inset

Evaluation mode.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Overview of the system.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Compilation Mode
\end_layout

\begin_layout Standard
The compilation mode allows to easily compose spanner representations to
 obtain more complex ones.
 A high-level description of the composition process is shown in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Compilation-mode."

\end_inset

.
 It is performed according to an input AQL query, written in an ad-hoc syntax
 that linearizes its operator tree.
 A query specification consists of two parts: an initial part where a set
 of input spanners is specified and another part containing a series of
 operations to be performed on spanners from the input set
\emph on
.
 
\emph default
As mentioned, input spanners are encoded by spanner representations belonging
 to 
\begin_inset Formula $\textrm{VA}_{\textrm{WSet}}^{\left\{ \varsigma^{=}\right\} }$
\end_inset

.
 Any potential final projection involving variables that are used in one
 or more string equality selections is handled separately.
 The next example discusses a sample AQL query, formulated in the syntax
 expected by the system.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikz[level distance=2cm, inner sep=10pt]   	
\backslash
node[rectangle, draw, align=left] {S1 = <
\backslash
emph{path/to/file}> 
\backslash

\backslash
  	S2 = <
\backslash
emph{path/to/file}> 
\backslash

\backslash
 	S3 = <
\backslash
emph{path/to/file}> 
\backslash

\backslash
 	S4 = <
\backslash
emph{path/to/file}> 
\backslash

\backslash
 - 
\backslash

\backslash
 	R1 = S1 $
\backslash
bowtie$ S2 
\backslash

\backslash
 	R2 = S3 $
\backslash
bowtie$ S4 
\backslash

\backslash
 	R3 = R1 $
\backslash
cup$ R2};
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:sample-aqls"

\end_inset

A sample AQL query, written in the syntax used by the system.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
Consider the query representation shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:sample-aqls"

\end_inset

.
 In this representation, four spanners, with identifiers S1, S2, S3 and
 S4, are included by initializing the corresponding variables with the paths
 of the files containing their representations.
 Then the separating character 
\begin_inset Quotes eld
\end_inset

-
\begin_inset Quotes erd
\end_inset

 is inserted to mark the beginning of the series of operations to be performed
 on the input spanners.
 Here we have the following operations: natural join between S1 and S2 (result
 assigned to variable R1), natural join between S3 and S4 (result assigned
 to R2), and union between R1 and R2 (result assigned to R3).
 The operations are compiled in order of appearance.
 In general, the spanner representation resulting from the last operation
 is returned as output, while intermediate results are discarded.
\end_layout

\begin_layout Standard
The compilation mode supports all the operators described in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Algebras-of-Spanners"

\end_inset

.
 For projection, union and natural join, the constructions described in
 Theorems 
\begin_inset CommandInset ref
LatexCommand ref
reference "ext-proj"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "ext-union"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "ext-join"

\end_inset

 are respectively used (keep in mind that input spanners are represented
 by well-behaved eVset-automata).
 String equality selection operations are simply reported in the resulting
 representation, for use of the evaluation engine.
 
\end_layout

\begin_layout Standard
In addition to the operators that we saw so far, a specialized join operator
 was implemented.
 It is based on a predicate which may be referred to as 
\begin_inset Quotes eld
\end_inset

followedBy(
\series bold
min
\series default
,
\series bold
 max
\series default
)
\begin_inset Quotes erd
\end_inset

: according to it, two spans from two different input relations are combined
 if and only if they are distant from each other at least 
\series bold
min
\series default
 characters and at most 
\series bold
max
\series default
 characters.
 This kind of join is supported by SystemT, and it is often used in AQL
 queries (see 
\begin_inset CommandInset citation
LatexCommand cite
key "4497502"

\end_inset

).
 Given two unary core spanners 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, with 
\begin_inset Formula $\textrm{SVars}\left(A\right)=\left\{ x\right\} $
\end_inset

, 
\begin_inset Formula $\textrm{SVars}\left(B\right)=\left\{ y\right\} $
\end_inset

 and 
\begin_inset Formula $x\neq y$
\end_inset

, we can express the described join construction, with 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 as arguments, by the following core spanner:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
C=\pi_{\left\{ z\right\} }\left(A\bowtie S_{\textrm{followedBy}(\textrm{\textbf{min}},\textrm{\textbf{max}})}^{x,y,z}\bowtie B\right)\label{eq:sep}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where:
\end_layout

\begin_layout Itemize
for a given string 
\begin_inset Formula $\mathbf{s}$
\end_inset

 and any two 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuples 
\begin_inset Formula $\mu_{A}\in A\left(\mathbf{s}\right),\mu_{B}\in B\left(\mathbf{s}\right)$
\end_inset

 such that 
\begin_inset Formula $\mu_{A}\left(x\right)=\left[i_{b},i_{e}\right\rangle $
\end_inset

, 
\begin_inset Formula $\mu_{B}\left(y\right)=\left[j_{b},j_{e}\right\rangle $
\end_inset

 and 
\series bold
min
\series default

\begin_inset Formula $\leq j_{b}-i_{e}\leq$
\end_inset


\series bold
max
\series default
, 
\begin_inset Formula $C\left(\mathbf{s}\right)$
\end_inset

 contains a tuple 
\begin_inset Formula $\mu_{C}$
\end_inset

 such that 
\begin_inset Formula $\mu_{C}\left(z\right)=\left[i_{b},j_{e}\right\rangle $
\end_inset

, and no additional tuples;
\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{\textrm{followedBy}(\textrm{\textbf{min}},\textrm{\textbf{max}})}^{x,y,z}$
\end_inset

 is the contextual core spanner that realizes the join, parametrized by
 the input variables 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

, the output variable 
\begin_inset Formula $z$
\end_inset

, 
\series bold
min 
\series default
and 
\series bold
max
\series default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto, font=
\backslash
large]  
\backslash
node[state,initial]  (q_0)                {}; 
\backslash
node[state]          (q_1) [right=of q_0] {}; 
\backslash
node[state]          (q_2) [right=of q_1] {};  
\backslash
node		      (sep) [below=60pt of q_2, align=center] {
\backslash
textbf{.} 
\backslash

\backslash
 
\backslash
textbf{.} 
\backslash

\backslash
 
\backslash
textbf{.}};  
\backslash
node[state]          (q_4) [below=60pt of sep] {};  
\backslash
node[state]	      (q_5) [left=60pt of q_4] {};  
\backslash
node		      (sep2) [left=60pt of q_5, align=center] {
\backslash
textbf{.
  .
  .}};  
\backslash
node[state]	      (q_6) [left=60pt of sep2] {};  
\backslash
node[state,accepting](q_7) [left=of q_6] {};   
\backslash
path[->] (q_0) edge              node        {$
\backslash
left
\backslash
{ x
\backslash
vdash, z
\backslash
vdash
\backslash
right
\backslash
} $} (q_1)  		edge [loop above] node        {$
\backslash
Sigma$} ()  	  (q_1) edge 	          node        {$
\backslash
left
\backslash
{ 
\backslash
dashv x 
\backslash
right
\backslash
} $} (q_2)  		edge [loop above] node        {$
\backslash
Sigma$} ()  	  (q_2) edge 		  node        {$
\backslash
Sigma$} (sep)   	  (sep) edge              node        {$
\backslash
Sigma$} (q_4)  	  (q_4) edge [bend right=60] node[swap]      {$
\backslash
left
\backslash
{ y
\backslash
vdash 
\backslash
right
\backslash
} $} (q_6)  	  (q_4) edge              node        {$
\backslash
Sigma$} (q_5)  	  (q_5) edge [bend right=30] node[swap]      {$
\backslash
left
\backslash
{ y
\backslash
vdash 
\backslash
right
\backslash
} $} (q_6)  	  (q_5) edge              node        {$
\backslash
Sigma$} (sep2) 	  (sep2) edge 		  node        {$
\backslash
Sigma$} (q_6)  	  (q_6) edge [loop above] node        {$
\backslash
Sigma$} ()  	  (q_6) edge 	          node        {$
\backslash
left
\backslash
{ 
\backslash
dashv y, 
\backslash
dashv z 
\backslash
right
\backslash
} $} (q_7) 	  (q_7) edge [loop above] node        {$
\backslash
Sigma$} ();
\end_layout

\begin_layout Plain Layout


\backslash
draw [gray,decorate,decoration={brace,amplitude=5pt,raise=20pt}] (q_2) 
 -- (q_4)     node [black,midway,right=25pt] {
\backslash
footnotesize 
\backslash
textbf{min} times}; 
\backslash
draw [gray,decorate,decoration={brace,amplitude=5pt,raise=20pt}] (q_4) 
 -- (q_6)     node [black,midway,below=25pt] {
\backslash
footnotesize 
\backslash
textbf{max}$-$
\backslash
textbf{min} times}; 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:sep"

\end_inset

A well-behaved eVset-automaton representing 
\begin_inset Formula $S_{\textrm{followedBy}(\textrm{\textbf{min}},\textrm{\textbf{max}})}^{x,y,z}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S_{\textrm{followedBy}(\textrm{\textbf{min}},\textrm{\textbf{max}})}^{x,y,z}$
\end_inset

 can be represented by the well-behaved eVset-automaton shown in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:sep"

\end_inset

.
 In the system, the join operation that we are discussing is compiled exactly
 by following formula 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:sep"

\end_inset

.
 More precisely, we have that:
\end_layout

\begin_layout Itemize
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are encoded by members of 
\begin_inset Formula $\textrm{VA}_{\textrm{WSet}}$
\end_inset

 (no string equality selections are possible since they are unary);
\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{\textrm{followedBy}(\textrm{\textbf{min}},\textrm{\textbf{max}})}^{x,y,z}$
\end_inset

 is represented by the automaton of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:sep"

\end_inset

;
\end_layout

\begin_layout Itemize
the operators 
\begin_inset Formula $\pi$
\end_inset

 and 
\begin_inset Formula $\bowtie$
\end_inset

 are simulated with the constructions described in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:EVST-wb"

\end_inset

 of the previous chapter.
 
\end_layout

\begin_layout Standard
Notice that this construction only works if 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 support unanchored matching, i.e., the corresponding eVset-automata have
 universal loop transitions on their initial and accepting states.
 A concrete example of the described join follows.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\backslash
resizebox{.75
\backslash
textwidth}{!}{
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[shorten >=1pt,node distance=2.5cm,on grid,auto]  
\backslash
node[state,initial]  (q_0)                      {}; 
\backslash
node[state]          (q_1) [right=of q_0] {}; 
\backslash
node[state]          (q_2) [above right=of q_1] {};  
\backslash
node[state]          (q_3) [right=of q_2] {};  
\backslash
node[state]          (q_4) [right=of q_3] {};  
\backslash
node[state]          (q_5) [below right=of q_4] {};  
\backslash
node[state]          (q_6) [below right=of q_1] {};  
\backslash
node[state]          (q_7) [right=of q_6] {};  
\backslash
node[state]          (q_8) [right=of q_7] {};  
\backslash
node[state, accepting](q_9) [right=of q_5] {};  
\backslash
path[->] (q_0) edge              node        {$
\backslash
left
\backslash
{ x
\backslash
vdash
\backslash
right
\backslash
} $} (q_1) 	  	edge [loop above] node        {$
\backslash
Sigma$} () 	  (q_1) edge              node        {l} (q_2) 	  (q_2) edge
              node        {i} (q_3) 	  (q_3) edge              node    
    {k} (q_4) 	  (q_4) edge              node        {e} (q_5) 	  (q_1)
 edge              node        {h} (q_6) 	  (q_6) edge              node
        {a} (q_7) 	  (q_7) edge              node        {t} (q_8) 	  (q_8)
 edge              node        {e} (q_5) 	  (q_5) edge              node
        {$
\backslash
left
\backslash
{ 
\backslash
dashv x 
\backslash
right
\backslash
} $} (q_9) 	  (q_9) edge [loop above] node        {$
\backslash
Sigma$} (); 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:impl-ex-a"

\end_inset

A well-behaved eVset-automaton 
\begin_inset Formula $A$
\end_inset

, accepting the words 'like' and 'hate'.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\backslash
resizebox{
\backslash
textwidth}{!}{
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[shorten >=1pt,node distance=2.5cm,on grid,auto]  
\backslash
node[state,initial]  (q_0)                      {}; 
\backslash
node[state]          (q_1) [right=of q_0] {}; 
\backslash
node[state]          (q_2) [above right=of q_1] {};  
\backslash
node[state]          (q_3) [right=of q_2] {};  
\backslash
node[state]          (q_4) [right=of q_3] {};  
\backslash
node[state]          (q_5) [right=of q_4] {};  
\backslash
node[state]          (q_6) [right=of q_5] {};  
\backslash
node[state]          (q_7) [below right=of q_6] {};  
\backslash
node[state]          (q_8) [below right=of q_1] {}; 
\backslash
node[state]          (q_9) [right=of q_8] {};  
\backslash
node[state]          (q_10) [right=of q_9] {};  
\backslash
node[state]          (q_11) [right=of q_10] {};  
\backslash
node[state]          (q_12) [right=of q_11] {};   
\backslash
node[state, accepting](q_13) [right=of q_7] {};  
\backslash
path[->] (q_0) edge              node        {$
\backslash
left
\backslash
{ y
\backslash
vdash
\backslash
right
\backslash
} $} (q_1) 	  	edge [loop above] node        {$
\backslash
Sigma$} () 	  (q_1) edge              node        {a} (q_2) 	  (q_2) edge
              node        {c} (q_3) 	  (q_3) edge              node    
    {t} (q_4) 	  (q_4) edge              node        {i} (q_5) 	  (q_5)
 edge              node        {o} (q_6) 	  (q_6) edge              node
        {n} (q_7) 	  (q_1) edge              node        {h} (q_8) 	  (q_8)
 edge              node        {o} (q_9) 	  (q_9) edge              node
        {r} (q_10) 	  (q_10) edge              node        {r} (q_11) 	
  (q_11) edge              node        {o} (q_12) 	  (q_12) edge       
       node        {r} (q_7) 	  (q_7) edge              node        {$
\backslash
left
\backslash
{ 
\backslash
dashv y 
\backslash
right
\backslash
} $} (q_13) 	  (q_13) edge [loop above] node        {$
\backslash
Sigma$} (); 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:impl-ex-b"

\end_inset

A well-behaved eVset-automaton B, accepting the words 'action' and 'horror'.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\backslash
resizebox{
\backslash
textwidth}{!}{
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[shorten >=1pt,node distance=2.5cm,on grid,auto]  
\backslash
node[state,initial]  (q_0)                      {}; 
\backslash
node[state]          (q_1) [right=of q_0] {}; 
\backslash
node[state]          (q_2) [above right=of q_1] {};  
\backslash
node[state]          (q_3) [right=of q_2] {};  
\backslash
node[state]          (q_4) [right=of q_3] {};  
\backslash
node[state]          (q_5) [below right=of q_4] {};  
\backslash
node[state]          (q_6) [below right=of q_1] {};  
\backslash
node[state]          (q_7) [right=of q_6] {};  
\backslash
node[state]          (q_8) [right=of q_7] {};  
\backslash
node[state]	      (q_9) [right=of q_5] {};  
\backslash
node[state]	      (q_10) [below=of q_9] {};  
\backslash
node[state, draw=none](q_11) [below=of q_10, align=center] {
\backslash
textbf{.} 
\backslash

\backslash
 
\backslash
textbf{.} 
\backslash

\backslash
 
\backslash
textbf{.}};  
\backslash
node[state]	      (q_12) [below=of q_11] {};  
\backslash
node[state]	      (q_13) [above left=of q_12] {};  
\backslash
node[state]	      (q_14) [left=of q_13] {};  
\backslash
node[state]	      (q_15) [left=of q_14] {};  
\backslash
node[state]	      (q_16) [left=of q_15] {};  
\backslash
node[state]	      (q_17) [left=of q_16] {};  
\backslash
node[state]	      (q_18) [below left=of q_17] {};  
\backslash
node[state]	      (q_19) [below left=of q_12] {};  
\backslash
node[state]	      (q_20) [left=of q_19] {};  
\backslash
node[state]	      (q_21) [left=of q_20] {};  
\backslash
node[state]	      (q_22) [left=of q_21] {};  
\backslash
node[state]	      (q_23) [left=of q_22] {};  
\backslash
node[state,accepting](q_24) [left=of q_18] {};  
\backslash
path[->] (q_0) edge              node        {$
\backslash
left
\backslash
{ x
\backslash
vdash , z
\backslash
vdash 
\backslash
right
\backslash
} $} (q_1) 	  	edge [loop above] node        {$
\backslash
Sigma$} () 	  (q_1) edge              node        {l} (q_2) 	  (q_2) edge
              node        {i} (q_3) 	  (q_3) edge              node    
    {k} (q_4) 	  (q_4) edge              node        {e} (q_5) 	  (q_1)
 edge              node        {h} (q_6) 	  (q_6) edge              node
        {a} (q_7) 	  (q_7) edge              node        {t} (q_8) 	  (q_8)
 edge              node        {e} (q_5) 	  (q_5) edge              node
        {$
\backslash
left
\backslash
{ 
\backslash
dashv x 
\backslash
right
\backslash
} $} (q_9) 	  (q_9) edge 		  node        {$
\backslash
Sigma$} (q_10) 	  (q_10) edge 		  node        {$
\backslash
Sigma$} (q_11) 	  (q_10) edge [bend left=45] node     {$
\backslash
left
\backslash
{ y
\backslash
vdash
\backslash
right
\backslash
} $} (q_12) 	  (q_11) edge 		  node        {$
\backslash
Sigma$} (q_12) 	  (q_12) edge              node        {a} (q_13) 	  (q_13)
 edge              node        {c} (q_14) 	  (q_14) edge              node
        {t} (q_15) 	  (q_15) edge              node        {i} (q_16) 	
  (q_16) edge              node        {o} (q_17) 	  (q_17) edge       
       node        {n} (q_18) 	  (q_12) edge              node        {h}
 (q_19) 	  (q_19) edge              node        {o} (q_20) 	  (q_20) edge
              node        {r} (q_21) 	  (q_21) edge              node  
      {r} (q_22) 	  (q_22) edge              node        {o} (q_23) 	  (q_23)
 edge              node        {r} (q_18) 	  (q_18) edge              node
        {$
\backslash
left
\backslash
{ 
\backslash
dashv y,  
\backslash
dashv z 
\backslash
right
\backslash
} $} (q_24) 	  (q_24) edge [loop above] node        {$
\backslash
Sigma$} ();
\end_layout

\begin_layout Plain Layout


\backslash
draw [gray,decorate,decoration={brace,amplitude=5pt,raise=80pt}] (q_10)
  -- (q_12)     node [black,midway,right=85pt] {
\backslash
footnotesize 7 times}; 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:impl-ex-c"

\end_inset

A well-behaved eVset-automaton 
\begin_inset Formula $C$
\end_inset

, with 
\begin_inset Formula $\left\llbracket C\right\rrbracket =\pi_{\left\{ z\right\} }\left(\left\llbracket A\right\rrbracket \bowtie S_{\textrm{followedBy}(1,8)}^{x,y,z}\bowtie\left\llbracket B\right\rrbracket \right)$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:impl-ex"

\end_inset

The join of two automata 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 based on the predicate 
\begin_inset Formula $\textrm{followedBy}\left(1,8\right)$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textbf{String s}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\backslash
resizebox{
\backslash
textwidth}{!}{
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="30">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row topspace="default" bottomspace="default" interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
l
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
k
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
,
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
u
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
t
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
21
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
23
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
26
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
27
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
29
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\backslash
resizebox{.98
\backslash
textwidth}{!}{
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="26">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row topspace="default" bottomspace="default" interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
l
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
l
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
_
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
l
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
k
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
33
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
34
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
35
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
38
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
39
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
41
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
42
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
43
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
44
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
45
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
46
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
47
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
48
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
49
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
51
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
52
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
53
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
54
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
55
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
56
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="3cm">
<column alignment="center" valignment="top" width="3cm">
<column alignment="center" valignment="top" width="3cm">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\llbracket A\right\rrbracket \left(\mathbf{s}\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\mu_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left[3,7\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\mu_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left[34,38\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\llbracket B\right\rrbracket \left(\mathbf{s}\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $y$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\mu_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left[13,19\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\mu_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left[43,49\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\llbracket C\right\rrbracket \left(\mathbf{s}\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $z$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\mu_{5}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left[3,19\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\mu_{6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Formula $\left[34,49\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:impl-ex-res"

\end_inset

The results of the execution of the automata 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $C$
\end_inset

 from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:impl-ex"

\end_inset

 on a string 
\begin_inset Formula $\textrm{\ensuremath{\mathbf{s}}}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Example
Consider the well-behaved eVset-automata 
\begin_inset Formula $A$
\end_inset

 from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:impl-ex-a"

\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:impl-ex-b"

\end_inset

.
 
\begin_inset Formula $A$
\end_inset

 accepts the words 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

'like'
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

'hate'
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, while 
\begin_inset Formula $B$
\end_inset

 accepts 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

'action'
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

'horror'
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
 Notice that they both support unanchored matching.
 The well-behaved eVset-automaton 
\begin_inset Formula $C$
\end_inset

 from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:impl-ex-c"

\end_inset

 simulates the join of the spanners represented by 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, based on the predicate 
\begin_inset Formula $\textrm{followedBy}\left(1,8\right)$
\end_inset

.
 We have that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left\llbracket C\right\rrbracket =\pi_{\left\{ z\right\} }\left(\left\llbracket A\right\rrbracket \bowtie S_{\textrm{followedBy}(1,8)}^{x,y,z}\bowtie\left\llbracket B\right\rrbracket \right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:impl-ex-res"

\end_inset

 shows the results of the execution of the mentioned automata on a string
 
\begin_inset Formula $\textrm{\ensuremath{\mathbf{s}}}$
\end_inset

.
 
\begin_inset Formula $A$
\end_inset

 spans the tuples 
\begin_inset Formula $\mu_{1}$
\end_inset

 and 
\begin_inset Formula $\mu_{2}$
\end_inset

.
 We have that 
\begin_inset Formula $\mu_{1}\left(x\right)=\left[3,7\right\rangle $
\end_inset


\size small
, corresponding to the snippet 
\size default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\size small
'like'
\size default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\size small
and 
\size default

\begin_inset Formula $\mu_{2}\left(x\right)=\left[34,38\right\rangle $
\end_inset

, corresponding to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

'hate'
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
 Similarly, the tuples 
\begin_inset Formula $\mu_{3}$
\end_inset

 and 
\begin_inset Formula $\mu_{4}$
\end_inset

, spanned by 
\begin_inset Formula $B$
\end_inset

, contain the spans corresponding to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

'action'
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset

and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

'horror'
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, respectively.
 
\begin_inset Formula $C$
\end_inset

 spans 
\size small

\begin_inset Formula $\mu_{5}$
\end_inset

 and 
\begin_inset Formula $\mu_{6}$
\end_inset

, that correspond, respectively, to the snippets 
\size default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\size small
'like_many_action'
\size default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\size small
and 
\size default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\size small
'hate_all_horror'
\size default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\size small
.
 Thus, we have that 
\size default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\left\llbracket C\right\rrbracket \left(\textrm{\ensuremath{\mathbf{s}}}\right)=\pi_{\left\{ z\right\} }\left(\left\llbracket A\right\rrbracket \left(\textrm{\ensuremath{\mathbf{s}}}\right)\bowtie S_{\textrm{followedBy}(1,8)}^{x,y,z}\left(\textrm{\ensuremath{\mathbf{s}}}\right)\bowtie\left\llbracket B\right\rrbracket \left(\textrm{\ensuremath{\mathbf{s}}}\right)\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

.
 Notice how the distance constraint in the join of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 allows to join only the spans that are semantically correlated, avoiding
 to include in 
\begin_inset Formula $\left\llbracket C\right\rrbracket \left(\mathbf{s}\right)$
\end_inset

 the tuple 
\begin_inset Formula $\mu$
\end_inset

 with 
\begin_inset Formula $\mu\left(z\right)=\left[3,49\right\rangle $
\end_inset

, corresponding to the snippet 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

'like_many...
 all_horror'
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

, which would have been present if the join had been realized as in Example
 
\begin_inset CommandInset ref
LatexCommand ref
reference "join-ex"

\end_inset

 from Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Algebras-of-Spanners"

\end_inset

, where the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset


\begin_inset Formula $\textrm{followedBy}\left(\textrm{\textbf{min},\textbf{max}}\right)$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
em 
\end_layout

\end_inset

 predicate is not used.
\end_layout

\begin_layout Subsection
Evaluation Mode
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Formula $E\longleftarrow\left\{ \textrm{core spanner representation}\right\} $
\end_inset


\end_layout

\begin_layout Plain Layout
for document in inputDirectory do
\end_layout

\begin_layout Plain Layout
begin
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left\{ \textrm{Read document into main memory}\right\} $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $R\longleftarrow E\left(\textrm{document}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left\{ \textrm{Write \ensuremath{R} to disk}\right\} $
\end_inset


\end_layout

\begin_layout Plain Layout
end
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:The-execution-algorithm"

\end_inset

The execution algorithm of a core spanner representation on a set of input
 documents.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The evaluation mode requires as input a core spanner representation and
 the path of the directory containing the text documents to span.
 For each of these documents, an output span relation, resulting from the
 evaluation of the input spanner, is returned.
 The process is illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Evaluation-mode."

\end_inset

.
 The execution algorithm, represented by Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:The-execution-algorithm"

\end_inset

, is similar to that of SystemT (see Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Annotating-all-local"

\end_inset

 in Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Execution-Model"

\end_inset

).
 In particular, Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:The-execution-algorithm"

\end_inset

 conforms to document-at-a-time processing as well.
 The main difference with SystemT is that the results are written to a separate
 file, instead of annotating the input documents.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
The engine that evaluates a spanner representation on a document draws inspirati
on from the Thompson approach, described in Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-Thompson-Approach"

\end_inset

.
 The procedure defined by this approach cannot be used as is.
 The reason is that, when evaluating an eVset-automaton 
\begin_inset Formula $A$
\end_inset

 on a string 
\begin_inset Formula $\textrm{\ensuremath{\mathbf{s}}}$
\end_inset

, we are interested in all the 
\begin_inset Formula $\mathbf{s}$
\end_inset

-tuples defined by the runs belonging to 
\begin_inset Formula $\textrm{ARuns}\left(A,\mathbf{s}\right)$
\end_inset

, instead of a single one.
 Therefore, the implementation of the engine does not discard any of the
 feasible runs in 
\begin_inset Formula $\textrm{ARuns}\left(A,\mathbf{s}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Initially, the implementation followed the Virtual Machine method: a core
 spanner representation was converted into an NFA program and executed by
 a modified implementation of the virtual machine.
 However this implementation revealed itself to be slow.
 Thus, the engine was changed to use input eVset-automata directly: in this
 implementation, a set of current runs is maintained, and each run is advanced
 by following the outgoing transitions of its current state.
 All the runs are advanced in lockstep.
 There's another difference with the original Thompson approach: operation
 transitions, which may be considered as a special kind of 
\begin_inset Formula $\epsilon$
\end_inset

-transitions, are not followed iteratively, thus different runs may point
 to different positions of the input string at the same moment.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
The main motivation for developing this system was to look for evidence
 of performance benefits over the algebraic approach of SystemT.
 Thus, after the system was finished, I developed a set of AQL queries to
 be executed on a specific text corpus.
 The details will be given in the next chapter.
 I wanted to compare the performance of the evaluation approach described
 in this dissertation with the algebraic approach.
 Therefore, I developed a subsystem that takes the approach of SystemT.
 I did not use SystemT directly because I wanted to ensure a genuine comparison,
 that would provide insight on the differences of the two approaches considered.
 I believe that my subsystem manages to do so, for two reasons.
 First, it uses the same evaluation engine of the runtime system to execute
 basic span extractors in a query.
 Moreover, it does not include all the optimization techniques that SystemT
 has.
 Thus, it eliminates any possible factor that could interfere with a true
 comparison.
 I describe the subsystem in the next subsection.
\end_layout

\begin_layout Subsubsection
A Subsystem for the Algebraic Approach
\end_layout

\begin_layout Standard
The subsystem works by following Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:The-execution-algorithm"

\end_inset

 as well, but it executes AQL query representations directly, instead of
 spanner representations.
 The execution of an AQL query representation is as follows: the input spanners
 it points to are evaluated with the engine I have just described, then
 the operations contained in the query are performed.
 Each supported algebraic operator has an implementation that takes one
 or more 
\begin_inset Formula $\left(V,\mathbf{s}\right)$
\end_inset

-relations as input and returns a new 
\begin_inset Formula $\left(V,\mathbf{s}\right)$
\end_inset

-relation.
 The details of the implementations are not very interesting, except for
 two cases: natural join and the special join combining spans based on their
 relative distance.
 In the first case, I used a hash-join algorithm, with the hash function
 assigning values to the tuples of the input 
\begin_inset Formula $\left(V,\mathbf{s}\right)$
\end_inset

-relations based on the values of the common variables.
 This choice was made for two reasons: it was particularly easy to realize
 and hash-join algorithms generally have better performance than more generic
 join algorithms, as, e.g., nested-loop join algorithms.
 For the second case, another quite suitable implementation was chosen,
 inspired by sort-merge join algorithms.
 Again, this family of algorithms is in general preferable to nested-loop
 joins.
 In order to describe the concrete algorithm, let us consider two input
 unary relations 
\begin_inset Formula $R_{1}$
\end_inset

 and 
\begin_inset Formula $R_{2}$
\end_inset

, assigning spans to variables 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

, respectively.
 Let us assume that 
\begin_inset Formula $R_{1}$
\end_inset

 is the left argument to the join and 
\begin_inset Formula $R_{2}$
\end_inset

 is the right one.
 Then the operation is performed according to Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:sort-merge"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset


\begin_inset Formula $L_{1}\leftarrow$
\end_inset

a list containing the elements of 
\begin_inset Formula $R_{1}$
\end_inset

 sorted by second index of the spans assigned to 
\begin_inset Formula $x$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset


\begin_inset Formula $L_{2}\leftarrow$
\end_inset

a list containing the elements of 
\begin_inset Formula $R_{2}$
\end_inset

 sorted by first index of the spans assigned to 
\begin_inset Formula $y$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset


\begin_inset Formula $R_{3}\leftarrow\emptyset$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
WHILE{
\end_layout

\end_inset


\begin_inset Formula $\left|L_{1}\right|>0$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
AND 
\end_layout

\end_inset


\begin_inset Formula $\left|L_{2}\right|>0$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
WHILE{
\end_layout

\end_inset


\begin_inset Formula $\left|L_{2}\right|>0$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\left[i_{b},i_{e}\right\rangle \leftarrow L_{1}\textrm{.head}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\left[j_{b},j_{e}\right\rangle \leftarrow L_{2}\textrm{.head}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
IF{
\end_layout

\end_inset


\begin_inset Formula $\textrm{min}\leq j_{b}-i_{e}\leq\textrm{max}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $R_{3}\leftarrow R_{3}\cup\left\{ \left[i_{b},j_{e}\right\rangle \right\} $
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $L_{2}\leftarrow L_{2}\textrm{.tail}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ELSE
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset

 
\series bold
break
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ENDWHILE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
IF{
\end_layout

\end_inset


\begin_inset Formula $\left|L_{1}\right|>0$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
AND 
\end_layout

\end_inset


\begin_inset Formula $\left|L_{2}\right|>0$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\left[i_{b},i_{e}\right\rangle \leftarrow L_{1}\textrm{.head}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\left[j_{b},j_{e}\right\rangle \leftarrow L_{2}\textrm{.head}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
IF{
\end_layout

\end_inset


\begin_inset Formula $j_{b}-i_{e}<\textrm{min}$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $L_{2}\leftarrow L_{2}\textrm{.tail}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ELSE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $L_{1}\leftarrow L_{1}\textrm{.tail}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ENDWHILE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
RETURN
\end_layout

\end_inset

 
\begin_inset Formula $R_{3}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:sort-merge"

\end_inset

Algorithm to join 
\begin_inset Formula $R_{1}$
\end_inset

 and 
\begin_inset Formula $R_{2}$
\end_inset

 according to the followedBy(min, max) predicate.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
This chapter described the details of the implementation of the runtime
 system.
 The next chapter describes the experiments that were made with it and the
 results that were obtained.
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Experiments"

\end_inset

Experiments
\end_layout

\begin_layout Standard
After the development of the system, an experimental validation phase followed.
 The experiments were designed to test whether the evaluation approach described
 in this paper brings performance benefits over the approach of SystemT.
 As mentioned, a subsystem that takes the algebraic approach used in SystemT,
 but evaluates basic span extractors with the same engine of the runtime
 system, was developed in order to make a true comparison.
 In particular, the subsystem does not support the optimization techniques
 described in 
\begin_inset CommandInset citation
LatexCommand cite
key "4497502,Krishnamurthy:2009:SSD:1519103.1519105"

\end_inset

.
 The outline of the chapter follows.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:exp-setup"

\end_inset

 contains a detailed discussion of the experimental setup.
 In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:exp-res"

\end_inset

,  I discuss the results of the execution of the experiments.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:exp-setup"

\end_inset

Setup
\end_layout

\begin_layout Standard
I performed the experiments on a document corpus consisting of blog entries,
 organized in 19230 files, each containing posts from the same author.
 The corpus was originally proposed in 
\begin_inset CommandInset citation
LatexCommand cite
key "841842cf899c42e9b88c7a8cdac64180"

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The corpus is available at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://u.cs.biu.ac.il/~koppel/BlogCorpus.htm
\end_layout

\end_inset


\end_layout

\end_inset

.
 Its total size is 806,2 MB.
 All the queries were run on a machine with a 2,7 GHz Intel i7-2620M processor
 and 4 GB of RAM.
 The next subsection describes the queries in detail.
\end_layout

\begin_layout Subsection
Queries
\end_layout

\begin_layout Standard
The queries are about finding informal movie reviews in a text.
 They are built by combining these basic span extractors:
\end_layout

\begin_layout Description
Action extracts verbs usually associated with movies (e.g., 
\begin_inset Quotes eld
\end_inset

watch
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

rent
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Description
Aspect extracts mentions of aspects of a movie (e.g., 
\begin_inset Quotes eld
\end_inset

cast
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

plot
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Description
Attribute extracts attributes (e.g., 
\begin_inset Quotes eld
\end_inset

funny
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

boring
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Description
Genre extracts mentions of the most common movie genres (e.g., 
\begin_inset Quotes eld
\end_inset

action
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

comedy
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Description
Movie extracts synonyms of the word 
\begin_inset Quotes eld
\end_inset

movie
\begin_inset Quotes erd
\end_inset

 (e.g., 
\begin_inset Quotes eld
\end_inset

flick
\begin_inset Quotes erd
\end_inset

, but also 
\begin_inset Quotes eld
\end_inset

movie
\begin_inset Quotes erd
\end_inset

 itself), and also related words like 
\begin_inset Quotes eld
\end_inset

dvd
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Description
Name extracts digrams that potentially represent full names (e.g., 
\begin_inset Quotes eld
\end_inset

Brad Pitt
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Description
PlotClue extracts words that hint to a synopsis (e.g., 
\begin_inset Quotes eld
\end_inset

story
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

begins
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

ending
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Description
Role extracts mentions of roles both in the plot of a movie (e.g., 
\begin_inset Quotes eld
\end_inset

protagonist
\begin_inset Quotes erd
\end_inset

) and in its realization (e.g., 
\begin_inset Quotes eld
\end_inset

director
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Description
RoleClue extracts words hinting to a description of a role (e.g., 
\begin_inset Quotes eld
\end_inset

role
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

play
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Description
Sentiment extracts verbs expressing feelings (e.g., 
\begin_inset Quotes eld
\end_inset

loved
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

liked
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Description
Title extracts titles (e.g., 
\begin_inset Quotes eld
\end_inset

The Matrix
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Annie Hall
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
A well-behaved eVset-automaton representing each of these extractors was
 developed.
 Each automaton assigns the spans it matches to a single span variable,
 different from those of the others.
 The automata for 
\series bold
Name
\series default
 and 
\series bold
Title
\series default
 encode regular expressions that try to identify entities of interest by
 exploiting their usual structure, while all the other automata look for
 sets of fixed words, thus they simulate dictionary matchers.
 They are implemented as prefix trees
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
See, e.g., 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Trie
\end_layout

\end_inset

.
\end_layout

\end_inset

.
 As an example, given an eVset-automaton 
\begin_inset Formula $A$
\end_inset

, with 
\begin_inset Formula $\textrm{SVars}\left(A\right)=\left\{ x\right\} $
\end_inset

, that extracts the words 'middle', 'midway' and 'misfire', the structure
 of 
\begin_inset Formula $A$
\end_inset

 is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:aut-dict"

\end_inset

.
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\backslash
resizebox{
\backslash
textwidth}{!}{
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[shorten >=1pt,node distance=2.5cm,on grid,auto]  
\backslash
node[state,initial]  (q_0)                      {}; 
\backslash
node[state]          (q_1) [right=of q_0] {}; 
\backslash
node[state]          (q_2) [right=of q_1] {};  
\backslash
node[state]          (q_3) [right=of q_2] {};  
\backslash
node[state]          (q_4) [above right=of q_3] {};  
\backslash
node[state]          (q_5) [right=of q_4,xshift=0.7cm] {};  
\backslash
node[state]          (q_6) [right=of q_5,xshift=0.7cm] {};  
\backslash
node[state]          (q_7) [right=of q_9,xshift=3cm] {};  
\backslash
node[state]          (q_8) [below right=of q_4,xshift=0.7cm] {};  
\backslash
node[state]	      (q_9) [right=of q_8,xshift=0.7cm] {};  
\backslash
node[state]	      (q_10) [below right=of q_3] {};  
\backslash
node[state]	      (q_11) [right=of q_10] {};  
\backslash
node[state]	      (q_12) [right=of q_11] {};  
\backslash
node[state]	      (q_13) [right=of q_12] {};  
\backslash
node[state,accepting](q_14) [right=of q_7] {};  
\backslash
path[->] (q_0) edge              node        {$
\backslash
left
\backslash
{ x
\backslash
vdash 
\backslash
right
\backslash
} $} (q_1) 	  	edge [loop above] node        {$
\backslash
Sigma$} () 	  (q_1) edge              node        {m} (q_2) 	  (q_2) edge
              node        {i} (q_3) 	  (q_3) edge              node    
    {d} (q_4) 	  (q_3) edge              node        {s} (q_10) 	  (q_4)
 edge              node        {d} (q_5) 	  (q_4) edge              node
        {w} (q_8) 	  (q_5) edge              node        {l} (q_6) 	  (q_6)
 edge              node        {e} (q_7) 	  (q_7) edge              node
        {$
\backslash
left
\backslash
{ 
\backslash
dashv x 
\backslash
right
\backslash
} $} (q_14) 	  (q_8) edge              node        {a} (q_9) 	  (q_9) edge
 		  node        {y} (q_7) 	  (q_10) edge 		  node        {f} (q_11) 	 
 (q_11) edge 		  node        {i} (q_12) 	  (q_12) edge              node
        {r} (q_13) 	  (q_13) edge              node        {e} (q_7) 	 
 (q_14) edge [loop above] node        {$
\backslash
Sigma$} (); 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:aut-dict"

\end_inset

An automaton 
\begin_inset Formula $A$
\end_inset

, that simulates a dictionary matcher.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
I now describe the queries, using the syntax from Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Algebra-of-Operators"

\end_inset

.
 The queries are divided in groups.
 The first group contains only binary joins, that can be described with
 the following formulas:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
Q_{1} & = & \varepsilon_{\textrm{\textbf{Action}}}\bowtie_{10}\varepsilon_{\textrm{\textbf{Title}}}\\
Q_{2} & = & \varepsilon_{\textrm{\textbf{Attribute}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{Movie}}}\\
Q_{3} & = & \varepsilon_{\textrm{\textbf{Genre}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{Movie}}}\\
Q_{4} & = & \varepsilon_{\textrm{\textbf{Movie}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Title}}}
\end{eqnarray*}

\end_inset

where the 
\begin_inset Formula $\varepsilon$
\end_inset

 operators were implemented by the corresponding automata and the 
\begin_inset Formula $\bowtie_{d}$
\end_inset

 operator was realized by the join specialized on the predicate 
\begin_inset Quotes eld
\end_inset

followedBy
\begin_inset Formula $\left(\textrm{\textbf{min}},\textrm{\textbf{max}}\right)$
\end_inset


\begin_inset Quotes erd
\end_inset

, with 
\series bold
min
\begin_inset Formula $=0$
\end_inset


\series default
 and 
\series bold
max
\begin_inset Formula $=d$
\end_inset


\series default
.
 
\end_layout

\begin_layout Standard
The queries of the second group are unions of binary joins:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
Q_{5} & = & Q_{1}\cup Q_{2}\cup\left(\varepsilon_{\textrm{\textbf{Role}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Name}}}\right)\\
Q_{6} & = & Q_{1}\cup Q_{3}\cup\left(\varepsilon_{\textrm{\textbf{Sentiment}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{Movie}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Role}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Name}}}\right)\cup\\
 &  & \left(\varepsilon_{\textrm{\textbf{Aspect}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Attribute}}}\right)\\
Q_{7} & = & Q_{6}\cup\left(\varepsilon_{\textrm{\textbf{Title}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{PlotClue}}}\right)\\
Q_{8} & = & Q_{7}\cup\left(\varepsilon_{\textrm{\textbf{Sentiment}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{Aspect}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Name}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Attribute}}}\right)\\
Q_{9} & = & \beta\left(\varOmega_{o}\left(Q_{1}\cup Q_{2}\cup Q_{3}\cup\left(\varepsilon_{\textrm{\textbf{Sentiment}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{Movie}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Role}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Name}}}\right)\cup\right.\right.\\
 &  & \left(\varepsilon_{\textrm{\textbf{Movie}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{Action}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Title}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{RoleClue}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Title}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{Movie}}}\right)\cup\\
 &  & \left(\varepsilon_{\textrm{\textbf{Title}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{Attribute}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Name}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Role}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Attribute}}}\bowtie_{50}\varepsilon_{\textrm{\textbf{Name}}}\right)\cup\\
 &  & \left(\varepsilon_{\textrm{\textbf{Sentiment}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Name}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Name}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Attribute}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Action}}}\bowtie_{10}\varepsilon_{\textrm{\textbf{Name}}}\right)\cup\\
 &  & \left(\varepsilon_{\textrm{\textbf{Action}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Movie}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Movie}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{PlotClue}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Title}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{PlotClue}}}\right)\cup\\
 &  & \left(\varepsilon_{\textrm{\textbf{Role}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{Attribute}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Movie}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{Name}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Name}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{Movie}}}\right)\cup\\
 &  & \left.\left.\left(\varepsilon_{\textrm{\textbf{Attribute}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{Role}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Movie}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{Title}}}\right)\right)\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
The operator tree of query 
\begin_inset Formula $Q_{6}$
\end_inset

 is represented in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:q6"

\end_inset

.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\backslash
resizebox{
\backslash
textwidth}{!}{
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikz [level distance=1.6cm, level 1/.style={sibling distance=9em}, level 2/.style={
sibling distance=4.5em}]  	
\backslash
node{$
\backslash
cup$} 		child { node {$
\backslash
bowtie_{
\backslash
preceq_{10}}$} 			child { node {$
\backslash
varepsilon_{
\backslash
textbf{Action}}$}  				edge from parent [<-] 			} 			child { node {$
\backslash
varepsilon_{
\backslash
textbf{Title}}$}  				edge from parent [<-] 			} 			edge from parent [<-]
 		} 		child { node {$
\backslash
bowtie_{
\backslash
preceq_{60}}$} 			child { node {$
\backslash
varepsilon_{
\backslash
textbf{Genre}}$}  				edge from parent [<-] 			} 			child { node {$
\backslash
varepsilon_{
\backslash
textbf{Movie}}$}  				edge from parent [<-] 			} 			edge from parent [<-]
 		}	 		child { node {$
\backslash
bowtie_{
\backslash
preceq_{60}}$} 			child { node {$
\backslash
varepsilon_{
\backslash
textbf{Sentiment}}$}  				edge from parent [<-] 			} 			child { node {$
\backslash
varepsilon_{
\backslash
textbf{Movie}}$}  				edge from parent [<-] 			} 			edge from parent [<-]
 		} 		child { node {$
\backslash
bowtie_{
\backslash
preceq_{40}}$} 			child { node {$
\backslash
varepsilon_{
\backslash
textbf{Role}}$}  				edge from parent [<-] 			} 			child { node {$
\backslash
varepsilon_{
\backslash
textbf{Name}}$}  				edge from parent [<-] 			} 			edge from parent [<-]
 		}	 		child { node {$
\backslash
bowtie_{
\backslash
preceq_{40}}$} 			child { node {$
\backslash
varepsilon_{
\backslash
textbf{Aspect}}$} 			} 			child { node {$
\backslash
varepsilon_{
\backslash
textbf{Attribute}}$} 				edge from parent [<-] 			} 			edge from parent
 [<-] 		};
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:q6"

\end_inset

 The operator tree of query 
\begin_inset Formula $Q_{6}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

As the reader can see, queries from 
\begin_inset Formula $Q_{5}$
\end_inset

 to 
\begin_inset Formula $Q_{9}$
\end_inset

 are ordered by increasing size.
 Many individual joins are reused among different queries.
 Query 
\begin_inset Formula $Q_{9}$
\end_inset

 has so many joins because it was meant as a real-life query, which tries
 to maximize the output entities.
 For the same reason, The 
\begin_inset Formula $\varOmega_{o}$
\end_inset

 operator, which consolidates overlapping spans, and the 
\begin_inset Formula $\beta$
\end_inset

 operator, which identifies groups of contiguous spans, were used in the
 query.
 The 
\begin_inset Formula $\beta$
\end_inset

 operator had the following parameters: a maximum distance between two spans
 of 170 characters, and a minimum number of spans per extracted group of
 2.
 Confronted to query 
\begin_inset Formula $Q_{9}$
\end_inset

, all the other queries might seem incomplete, as they don't use any operators
 to aggregate parts of reviews.
 Nonetheless, such aggregation operators are not covered by the runtime
 system, because their relationship with core spanners was not analyzed.
 In fact, the runtime system borrows the implementations for these operators
 from the subsystem, so including them in the queries is not interesting
 for the purpose of comparing the two different approaches.
\end_layout

\begin_layout Standard
Another thing worth noticing in the last group of queries is that they contain
 progressively more duplicate instances of span extractors.
 We will see, in the discussion of the experimental results in the next
 section, that this fact affects the relative performance of the two approaches
 in a very important way.
 Let us quantify the amount of repeated span extractor instances in a query
 with a parameter, which we may call the 
\emph on
redundancy
\emph default
 of a query.
 Given a query 
\begin_inset Formula $Q$
\end_inset

, we define its redundancy by the following formula:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
r\left(Q\right)=\frac{\textrm{\#span extractor instances in }Q}{\textrm{\#individual span extractors in }Q}-1
\end{equation}

\end_inset

The higher the value of this parameter, the more a query is redundant.
 As the reader can verify, for any query 
\begin_inset Formula $Q$
\end_inset

 that is non-redundant, we have that 
\begin_inset Formula $r\left(Q\right)=0$
\end_inset

.
 For queries from 
\begin_inset Formula $Q_{5}$
\end_inset

 to 
\begin_inset Formula $Q_{9}$
\end_inset

, 
\begin_inset Formula $r$
\end_inset

 takes these values:
\end_layout

\begin_layout Itemize
\begin_inset Formula $r\left(Q_{5}\right)=0$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $r\left(Q_{6}\right)=\frac{1}{9}\thickapprox0.11$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $r\left(Q_{7}\right)=\frac{2}{10}=0.2$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $r\left(Q_{8}\right)=\frac{5}{10}=0.5$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $r\left(Q_{9}\right)=\frac{34}{10}=3.4$
\end_inset


\end_layout

\begin_layout Standard
The next set of queries is made of ternary joins.
 The reader can assume the 
\begin_inset Formula $\bowtie_{d}$
\end_inset

 operator to be left-associative.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
Q_{10} & = & \varepsilon_{\textrm{\textbf{Action}}}\bowtie_{10}\varepsilon_{\textrm{\textbf{Title}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Attribute}}}\\
Q_{11} & = & \varepsilon_{\textrm{\textbf{Name}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{RoleClue}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Role}}}\\
Q_{12} & = & \varepsilon_{\textrm{\textbf{Sentiment}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{Genre}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{Movie}}}
\end{eqnarray*}

\end_inset

The last group of queries contains unions of ternary joins, ordered by increasin
g size and redundancy.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
Q_{13} & = & Q_{10}\cup Q_{12}\\
Q_{14} & = & Q_{13}\cup Q_{11}\\
Q_{15} & = & Q_{14}\cup\left(\varepsilon_{\textrm{\textbf{Movie}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Attribute}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Aspect}}}\right)\\
Q_{16} & = & Q_{15}\cup\left(\varepsilon_{\textrm{\textbf{Name}}}\bowtie_{30}\varepsilon_{\textrm{\textbf{Attribute}}}\bowtie_{30}\varepsilon_{\textrm{\textbf{Role}}}\right)
\end{eqnarray*}

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikz [level distance=1.6cm, level 1/.style={sibling distance=9em}, level 2/.style={
sibling distance=3.7em}, level 3/.style={sibling distance=4.5em}]  	
\backslash
node{$
\backslash
cup$} 		child { node {$
\backslash
bowtie_{
\backslash
preceq_{40}}$} 			child { node {$
\backslash
bowtie_{
\backslash
preceq_{10}}$} 				child { node {$
\backslash
varepsilon_{
\backslash
textbf{Action}}$} 				edge from parent [<-] 				} 				child {	node {$
\backslash
varepsilon_{
\backslash
textbf{Title}}$} 				edge from parent [<-] 				} 				edge from parent [<-]
 			} 			child { node {$
\backslash
varepsilon_{
\backslash
textbf{Attribute}}$} 				edge from parent [<-] 			} 			edge from parent
 [<-] 		} 		child { node {$
\backslash
bowtie_{
\backslash
preceq_{60}}$} 			child { node {$
\backslash
bowtie_{
\backslash
preceq_{60}}$} 				child { node {$
\backslash
varepsilon_{
\backslash
textbf{Sentiment}}$} 				edge from parent [<-] 				} 				child {	node {$
\backslash
varepsilon_{
\backslash
textbf{Genre}}$} 				edge from parent [<-] 				} 				edge from parent [<-]
 			} 			child { node {$
\backslash
varepsilon_{
\backslash
textbf{Movie}}$} 				edge from parent [<-] 			} 			edge from parent [<-]
 		};
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:q13"

\end_inset

The operator tree of query 
\begin_inset Formula $Q_{13}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset

The operator tree of query 
\begin_inset Formula $Q_{13}$
\end_inset

 is represented in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:q13"

\end_inset

.
 The values of the 
\begin_inset Formula $r$
\end_inset

 parameter for queries 
\begin_inset Formula $Q_{13}$
\end_inset

 to 
\begin_inset Formula $Q_{16}$
\end_inset

 are the following:
\end_layout

\begin_layout Itemize
\begin_inset Formula $r\left(Q_{13}\right)=0$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $r\left(Q_{14}\right)=0$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $r\left(Q_{15}\right)=0.2$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $r\left(Q_{16}\right)=0.5$
\end_inset


\end_layout

\begin_layout Standard
In the next section, I discuss the results of the execution of the presented
 queries both with the runtime system and with the subsystem for the algebraic
 approach.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:exp-res"

\end_inset

Experimental Results
\end_layout

\begin_layout Standard
The running times reported in this sections are not average values.
 Instead, they result from individual runs of each query.
 Nonetheless, I reran the queries for which there was a sensible difference
 between the approach described in this dissertation and the algebraic approach,
 with a refinement: the time needed to get the text contained in the files
 of the corpus was excluded.
 Rerunning the queries confirmed the results appearing in this section,
 up to the excluded I/O time and small variations due to the machine.
 To put the results of the experiments in the right perspective, keep in
 mind that the corpus that was used is composed of 19230 text files, for
 a total size of 806,2 MB.
 Before starting with the queries, let us have a look at the running times
 of the individual span extractors, shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:perf-sp"

\end_inset

.
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pgfplotstableread[row sep=
\backslash

\backslash
,col sep=&]{     interval      & baseT 
\backslash

\backslash
     Action        & 13.03 
\backslash

\backslash
     Aspect        & 16.75 
\backslash

\backslash
     Attribute     & 18.67 
\backslash

\backslash
     Genre         & 20.23 
\backslash

\backslash
     Movie         & 13.30 
\backslash

\backslash
     Name          & 12.38 
\backslash

\backslash
     PlotClue      & 16.83 
\backslash

\backslash
     Role          & 14.32 
\backslash

\backslash
     RoleClue 	  & 12.25 
\backslash

\backslash
     Sentiment     & 15.45 
\backslash

\backslash
     Title         & 12.03 
\backslash

\backslash
     }
\backslash
mydata
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}     
\backslash
begin{axis}[             ybar, 	    ymajorgrids,             bar width=.5cm,
             width=
\backslash
textwidth,             height=.5
\backslash
textwidth,             symbolic x coords={Action,Aspect,Attribute,Genre,Movie,Na
me,PlotClue,Role,RoleClue,Sentiment,Title},             xtick=data, 	  
  xticklabel style={ 		inner sep=0pt, 		anchor=north east, 		rotate=45 	
    },             nodes near coords align={vertical},             ymin=0,ymax=2
5,             ylabel={Running Time (min.)},         ]         
\backslash
addplot table[x=interval,y=baseT]{
\backslash
mydata};     
\backslash
end{axis} 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:perf-sp"

\end_inset

Running times of the span extractors.
\end_layout

\end_inset


\end_layout

\end_inset

 The average running time is about 15 minutes.
 In the case of the extractors that imitate dictionary matchers, the runtime
 seems to be related to the number of words they can match.
 As an example, the three most expensive extractors
\series bold
, Aspect
\series default
, 
\series bold
Attribute
\series default
 and 
\series bold
Genre
\series default
, can match respectively 12, 18, and 23 words, while  two of the less expensive
 ones, 
\series bold
Action
\series default
 and 
\series bold
RoleClue
\series default
, match 3 and 2 words, respectively.
 More generally, the running time of an extractor seems to be proportional
 to the number of runs that the corresponding eVset-automaton tries during
 execution.
\end_layout

\begin_layout Standard
Let us now discuss the running times of queries 
\begin_inset Formula $Q_{1}$
\end_inset

 to 
\begin_inset Formula $Q_{4}$
\end_inset

, shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:perf-q1"

\end_inset

.
 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pgfplotstableread[row sep=
\backslash

\backslash
,col sep=&]{     interval & cls & vst 
\backslash

\backslash
     1     & 22.93  & 13.23 
\backslash

\backslash
     3     & 29.33 & 18.25 
\backslash

\backslash
     5     & 31.48 & 20.13 
\backslash

\backslash
     7  	  & 26.95 & 13.77 
\backslash

\backslash
	     }
\backslash
mydata
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}     
\backslash
begin{axis}[ 	    legend style={at={(0.5,-0.15)},anchor=north,legend columns=0,
 	      draw=none,/tikz/every even column/.append style={column sep=0.5cm}},
 	    legend cell align=left,             ybar, 	    ymajorgrids,      
       bar width=.5cm,             width=
\backslash
textwidth,             height=.5
\backslash
textwidth,             xtick=data,    	    xticklabels={$Q_1$,$Q_2$,$Q_3$,$Q_4$}
,             nodes near coords align={vertical},             ymin=0,ymax=35,
             xmin=0,xmax=8,             ylabel={Running Time (min.)},   
      ]         
\backslash
addplot table[x=interval,y=cls]{
\backslash
mydata}; 	
\backslash
addplot table[x=interval,y=vst]{
\backslash
mydata}; 	
\backslash
legend{Algebra, {EVset-automaton}}     
\backslash
end{axis} 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:perf-q1"

\end_inset

The running times of queries 
\begin_inset Formula $Q_{1}$
\end_inset

 to 
\begin_inset Formula $Q_{4}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 There are some useful observations we can make.
 First of all, the running time of a join evaluated with the algebraic subsystem
 roughly corresponds to the sum of the running times of the individual span
 extractors.
 This tells us that the time spent combining spans is negligible, compared
 to the time needed to evaluate span extractors.
 This observation is consistent with Remarks 
\begin_inset CommandInset ref
LatexCommand ref
reference "small-relations"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "runtime-dom"

\end_inset

 from Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:AQL-opt"

\end_inset

, and with the fact that the sizes of the files containing the snippets
 resulting from the evaluation of the single span extractors are very small
 compared to the size of the corpus, as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:perf-size"

\end_inset

.
 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pgfplotstableread[row sep=
\backslash

\backslash
,col sep=&]{     interval      & baseT 
\backslash

\backslash
     Action        & 9 
\backslash

\backslash
     Aspect        & 5.1 
\backslash

\backslash
     Attribute     & 9.1 
\backslash

\backslash
     Genre         & 8.9 
\backslash

\backslash
     Movie         & 3.8 
\backslash

\backslash
     Name          & 71.6 
\backslash

\backslash
     PlotClue      & 24.2 
\backslash

\backslash
     Role          & 2.4 
\backslash

\backslash
     RoleClue 	  & 4.8 
\backslash

\backslash
     Sentiment     & 7.5 
\backslash

\backslash
     Title         & 15 
\backslash

\backslash
     Corpus       & 806.2 
\backslash

\backslash
     }
\backslash
mydata
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}     
\backslash
begin{axis}[             ybar, 	    ymajorgrids,             bar width=.5cm,
             width=
\backslash
textwidth,             height=.5
\backslash
textwidth,             symbolic x coords={Action,Aspect,Attribute,Genre,Movie,Na
me,PlotClue,Role,RoleClue,Sentiment,Title,Corpus},             xtick=data,
 	    xticklabel style={ 		inner sep=0pt, 		anchor=north east, 		rotate=45
 	    },             nodes near coords align={vertical},             ymin=0,ymax
=820,             ylabel={Size (MB)},         ]         
\backslash
addplot table[x=interval,y=baseT]{
\backslash
mydata};     
\backslash
end{axis} 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:perf-size"

\end_inset

The sizes of the outputs resulting from the execution of the span extractors,
 compared to the size of the corpus.
\end_layout

\end_inset


\end_layout

\end_inset

 Evaluating a single join with an eVset-automaton seems to be always more
 efficient than using the algebraic approach.
 Hence, it must be that an eVset-automaton implementing the join tries less
 runs than the total runs of two eVset-automata corresponding to the span
 extractors in the join.
 Consider, for instance, query 
\begin_inset Formula $Q_{1}$
\end_inset

.
 During evaluation, the eVset-automaton corresponding to 
\begin_inset Formula $Q_{1}$
\end_inset

 will first look for an instance of an action and only if it finds one it
 will look for a movie title.
 Moreover, all the title instances that are not preceded by an action are
 naturally ignored.
 Although the finding of an action will cause the generation of 10 new runs,
 in order to try to match a title between 0 and 10 characters away (see
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:sep"

\end_inset

), this seems to be still less costly than evaluating 
\series bold
Action
\series default
 and 
\series bold
Title 
\series default
independently.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:perf-q5"

\end_inset

 reports the running times of queries 
\begin_inset Formula $Q_{5}$
\end_inset

 to 
\begin_inset Formula $Q_{9}$
\end_inset

.
 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pgfplotstableread[row sep=
\backslash

\backslash
,col sep=&]{     interval  & cls   & vst   & vstF  
\backslash

\backslash
     1   & 71.15 & 46 & 0 
\backslash

\backslash
     3   & 108.02 & 88.63 & 73.92 
\backslash

\backslash
     5   & 134.33 & 97.87 & 86.17 
\backslash

\backslash
     7   & 136.38 & 135.17 & 100.98 
\backslash

\backslash
     9   & 117.67 & 381.02 & 188.15 
\backslash

\backslash
     }
\backslash
mydata
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}     
\backslash
begin{axis}[ 	    legend style={at={(0.5,-0.15)},anchor=north,legend columns=0,
 	      draw=none,/tikz/every even column/.append style={column sep=0.5cm}},
 	    legend cell align=left,             ybar, 	    ymajorgrids,      
       bar width=.5cm,             width=
\backslash
textwidth,             height=.7
\backslash
textwidth,             xtick=data,    	    xticklabels={$Q_5$,$Q_6$,$Q_7$,$Q_8$,
$Q_9$},             nodes near coords align={vertical},             ymin=0,ymax=
400,             xmin=0,xmax=10,             ylabel={Running Time (min.)},
         ]         
\backslash
addplot table[x=interval,y=cls]{
\backslash
mydata}; 	
\backslash
addplot table[x=interval,y=vst]{
\backslash
mydata}; 	
\backslash
addplot table[x=interval,y=vstF]{
\backslash
mydata}; 	
\backslash
legend{Algebra, {EVset-automaton}, {EVset-automaton (factorized)}}	    
 
\backslash
end{axis} 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:perf-q5"

\end_inset

The running times of queries 
\begin_inset Formula $Q_{5}$
\end_inset

 to 
\begin_inset Formula $Q_{9}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset

 Remember that these queries are ordered by increasing size and redundancy.
 In particular, redundancy plays a central role here.
 There seems to be a clear trend: the more a query is redundant, the less
 efficient will be the evaluation of the corresponding eVset-automaton.
 In the worst case (
\begin_inset Formula $Q_{9}$
\end_inset

), this inefficiency is very marked.
 The explanation of this phenomenon is two-folded.
 On the one hand, the cost of evaluating a query with the algebraic subsystem
 is mostly determined by the cost of the single span extractors.
 This means that modifying a query with an additional join, without introducing
 new span extractors, is almost effortless.
 
\begin_inset Newline newline
\end_inset

Indeed, Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:perf-q5"

\end_inset

 shows that the running times obtained with the algebraic subsystem benefit
 from redundancy, and it is not surprising that query 
\begin_inset Formula $Q_{9}$
\end_inset

 is not more expensive than the others.
 On the other hand, an eVset-automaton corresponding to any of these queries
 does not have the possibility to reuse the results of individual span extractor
s, because it matches 
\emph on
entire join patterns independently
\emph default
 
\emph on
from each other
\emph default
.
 Thus, the running time of an eVset-automaton is proportional to the number
 of joins it contains, as we can see from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:perf-q5"

\end_inset

.
 In general, from the point of view of the string evaluation engine, the
 total number of runs that are performed on an input document seems to be
 crucial in determining the runtime of a query.
 As the number of joins in the query increases, the total runs tried by
 the corresponding automaton increase too.
 These considerations suggest that one of the key strengths of SystemT is
 its natural ability to extract basic span relations once and use them in
 different parts of a query.
 This feature is unfortunately missing from the runtime system.
 Nonetheless, in general it is possible to transform a query in such a way
 that its redundancy is reduced, without altering its semantics.
 Consider the following modifications of queries 
\begin_inset Formula $Q_{6}$
\end_inset

 to 
\begin_inset Formula $Q_{9}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
Q_{6}' & = & Q_{1}\cup\left(\left(\varepsilon_{\textrm{\textbf{Genre}}}\cup\varepsilon_{\textrm{\textbf{Sentiment}}}\right)\bowtie_{60}\varepsilon_{\textrm{\textbf{Movie}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Role}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Name}}}\right)\cup\\
 &  & \left(\varepsilon_{\textrm{\textbf{Aspect}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Attribute}}}\right)\\
Q_{7}' & = & Q_{6}'\cup\left(\varepsilon_{\textrm{\textbf{Title}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{PlotClue}}}\right)\\
Q_{8}' & = & Q_{1}\cup\left(\left(\varepsilon_{\textrm{\textbf{Genre}}}\cup\varepsilon_{\textrm{\textbf{Sentiment}}}\right)\bowtie_{60}\varepsilon_{\textrm{\textbf{Movie}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Role}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Name}}}\right)\cup\\
 &  & \left(\left(\varepsilon_{\textrm{\textbf{Aspect}}}\cup\varepsilon_{\textrm{\textbf{Name}}}\right)\bowtie_{40}\varepsilon_{\textrm{\textbf{Attribute}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Title}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{PlotClue}}}\right)\cup\\
 &  & \left(\varepsilon_{\textrm{\textbf{Sentiment}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{Aspect}}}\right)\\
Q_{9}' & = & \beta\left(\varOmega_{o}\left(\left(\varepsilon_{\textrm{\textbf{Movie}}}\bowtie_{60}\left(\varepsilon_{\textrm{\textbf{Action}}}\cup\varepsilon_{\textrm{\textbf{Name}}}\cup\varepsilon_{\textrm{\textbf{PlotClue}}}\cup\varepsilon_{\textrm{\textbf{Title}}}\right)\right)\cup\right.\right.\\
 &  & \left(\varepsilon_{\textrm{\textbf{Action}}}\bowtie_{10}\left(\varepsilon_{\textrm{\textbf{Name}}}\cup\varepsilon_{\textrm{\textbf{Title}}}\right)\right)\cup\\
 &  & \left(\left(\varepsilon_{\textrm{\textbf{Attribute}}}\cup\varepsilon_{\textrm{\textbf{Genre}}}\cup\varepsilon_{\textrm{\textbf{Name}}}\cup\varepsilon_{\textrm{\textbf{Sentiment}}}\cup\varepsilon_{\textrm{\textbf{Title}}}\right)\bowtie_{60}\varepsilon_{\textrm{\textbf{Movie}}}\right)\cup\\
 &  & \left(\left(\varepsilon_{\textrm{\textbf{Role}}}\cup\varepsilon_{\textrm{\textbf{Title}}}\right)\bowtie_{60}\varepsilon_{\textrm{\textbf{Attribute}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Name}}}\bowtie_{40}\left(\varepsilon_{\textrm{\textbf{Attribute}}}\cup\varepsilon_{\textrm{\textbf{Role}}}\right)\right)\cup\\
 &  & \left(\left(\varepsilon_{\textrm{\textbf{Role}}}\cup\varepsilon_{\textrm{\textbf{Sentiment}}}\right)\bowtie_{40}\varepsilon_{\textrm{\textbf{Name}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Title}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{RoleClue}}}\right)\cup\\
 &  & \left(\varepsilon_{\textrm{\textbf{Attribute}}}\bowtie_{50}\varepsilon_{\textrm{\textbf{Name}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Action}}}\bowtie_{40}\varepsilon_{\textrm{\textbf{Movie}}}\right)\cup\left(\varepsilon_{\textrm{\textbf{Title}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{PlotClue}}}\right)\cup\\
 &  & \left(\varepsilon_{\textrm{\textbf{Attribute}}}\bowtie_{60}\varepsilon_{\textrm{\textbf{Role}}}\right)\Biggr)\Biggr)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
These modified versions are equivalent to the original queries, but they
 are less redundant:
\end_layout

\begin_layout Itemize
\begin_inset Formula $r\left(Q_{6}'\right)=0<0.11\thickapprox r\left(Q_{6}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $r\left(Q_{7}'\right)=0.1<0.2=r\left(Q_{7}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $r\left(Q_{8}'\right)=0.4<0.5=r\left(Q_{8}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $r\left(Q_{9}'\right)=2.3<3.4=r\left(Q_{9}\right)$
\end_inset


\end_layout

\begin_layout Standard
As we can see from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:perf-q5"

\end_inset

, the transformations have a positive effect on the running times.
 All they do is 
\emph on
factorize
\emph default
 the common arguments to different joins in a query, with the constraints
 that the distance parameter of the joins is the same, and that the factorized
 arguments are in the same position in the joins.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:perf-q5"

\end_inset

 suggests that this technique can bring modest to huge benefits to the performan
ce of the runtime system, depending on the amount of redundancy that is
 eliminated.
 Nonetheless, in a generic query, it probably will not be able to eliminate
 all the redundancy.
 It is the case for query 
\begin_inset Formula $Q_{9}$
\end_inset

, where the running time of the runtime system becomes comparable with that
 of the algebraic subsystem, although it is still worse.
 On average, the speedup does not seem to change significantly when we apply
 factorization (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:perf-speed"

\end_inset

), but the reason might be that the set of queries used to calculate the
 average are, in general, not very redundant.
 The introduction of more redundant queries could probably increase the
 speedup significantly.
\end_layout

\begin_layout Standard
The results for queries 
\begin_inset Formula $Q_{10}$
\end_inset

 to 
\begin_inset Formula $Q_{12}$
\end_inset

 are shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:perf-q10"

\end_inset

.
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pgfplotstableread[row sep=
\backslash

\backslash
,col sep=&]{     interval  & cls   & vst  
\backslash

\backslash
     1   & 38.52 & 14.08 
\backslash

\backslash
     3   & 34.55 & 14.10 
\backslash

\backslash
     5  & 50.08 & 16.6 
\backslash

\backslash
     }
\backslash
mydata
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}     
\backslash
begin{axis}[ 	    legend style={at={(0.5,-0.15)},anchor=north,legend columns=0,
 	      draw=none,/tikz/every even column/.append style={column sep=0.5cm}},
 	    legend cell align=left,             ybar, 	    ymajorgrids,      
       bar width=.5cm,             width=
\backslash
textwidth,             height=.5
\backslash
textwidth,             xtick=data,             xticklabels={$Q_{10}$,$Q_{11}$,$Q
_{12}$},             nodes near coords align={vertical},             ymin=0,ymax
=60,             xmin=0,xmax=6,             ylabel={Running Time (min.)},
         ]         
\backslash
addplot table[x=interval,y=cls]{
\backslash
mydata}; 	
\backslash
addplot table[x=interval,y=vst]{
\backslash
mydata}; 	
\backslash
legend{Algebra, {EVset-automaton}}     
\backslash
end{axis} 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:perf-q10"

\end_inset

Running times of queries 
\begin_inset Formula $Q_{10}$
\end_inset

 to 
\begin_inset Formula $Q_{12}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 Non-redundant ternary joins seem to be faster with the runtime system,
 and, on average, the speedup with respect to the algebraic subsystem is
 greater than that obtained for binary joins (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:perf-speed"

\end_inset

).
 This is explained with the observation that a ternary join pattern is more
 restrictive than a binary one.
 Hence, on average, an eVset-automaton that implements a ternary join will
 try a smaller percentage of the total amount of runs tried by the individual
 span extractors.
 
\end_layout

\begin_layout Standard
Finally, Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:perf-q13"

\end_inset

 shows the running times 
\begin_inset Formula $Q_{13}$
\end_inset

 to 
\begin_inset Formula $Q_{16}$
\end_inset

 (that are ordered by increasing size and redundancy).
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pgfplotstableread[row sep=
\backslash

\backslash
,col sep=&]{     interval  & cls   & vst  
\backslash

\backslash
     1  & 82.63 & 30.98 
\backslash

\backslash
     3  & 117.57 & 47.72 
\backslash

\backslash
     5  & 132.18 & 61.7 
\backslash

\backslash
     7  & 133.63 & 79.05 
\backslash

\backslash
     }
\backslash
mydata
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}     
\backslash
begin{axis}[ 	    legend style={at={(0.5,-0.15)},anchor=north,legend columns=0,
 	      draw=none,/tikz/every even column/.append style={column sep=0.5cm}},
 	    legend cell align=left,             ybar, 	    ymajorgrids,      
       bar width=.5cm,             width=
\backslash
textwidth,             height=.5
\backslash
textwidth,             xtick=data,              xticklabels={$Q_{13}$,$Q_{14}$,$
Q_{15}$,$Q_{16}$},             nodes near coords align={vertical},     
        ymin=0,ymax=150,             xmin=0,xmax=8,             ylabel={Running
 Time (min.)},         ]         
\backslash
addplot table[x=interval,y=cls]{
\backslash
mydata}; 	
\backslash
addplot table[x=interval,y=vst]{
\backslash
mydata}; 	
\backslash
legend{Algebra, {EVset-automaton}}     
\backslash
end{axis} 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:perf-q13"

\end_inset

Running times of queries 
\begin_inset Formula $Q_{13}$
\end_inset

 to 
\begin_inset Formula $Q_{16}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 Although a query with a great redundancy is missing in this case, the examples
 reported suggest that the runtime system is less sensitive to redundancy,
 when the input queries are unions of ternary joins.
 For instance, queries 
\begin_inset Formula $Q_{8}$
\end_inset

 and 
\begin_inset Formula $Q_{16}$
\end_inset

 have approximately the same size: they employ the same amount of span extractor
s, they contain an almost equal number of 
\begin_inset Formula $\bowtie_{d}$
\end_inset

 operators (
\begin_inset Formula $Q_{16}$
\end_inset

 has two more) and 
\begin_inset Formula $r\left(Q_{8}\right)=r\left(Q_{16}\right)=0.5$
\end_inset

, but the speedup with respect to the algebraic approach is greater for
 
\begin_inset Formula $Q_{16}$
\end_inset

.
\end_layout

\begin_layout Standard
This situation suggests a trend: the longer the chain of joins, the greater
 performance gain over the algebraic approach.
 In spite of this consideration, longer join chains were not tried, because
 they hardly seem useful in the context of this benchmark: they would probably
 be effective when the entities we want to find have a complex and, above
 all, repetitive structure, but this is not the case for informal movie
 reviews contained in blog posts, whose structure might be complex, but
 is in general very variable.
 Already for queries 
\begin_inset Formula $Q_{13}$
\end_inset

 to 
\begin_inset Formula $Q_{16}$
\end_inset

, the sizes of the results are considerably smaller than, for instance,
 those of queries 
\begin_inset Formula $Q_{5}$
\end_inset

 to 
\begin_inset Formula $Q_{9}$
\end_inset

 (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:perf-size2"

\end_inset

).
 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pgfplotstableread[row sep=
\backslash

\backslash
,col sep=&]{     interval  & cls     
\backslash

\backslash
     1  & 1.60  
\backslash

\backslash
     3  & 2.1  
\backslash

\backslash
     5  & 4.5  
\backslash

\backslash
     7  & 6.7  
\backslash

\backslash
     9  & 6.1  
\backslash

\backslash
     11 & 0.06  
\backslash

\backslash
     13 & 0.14  
\backslash

\backslash
     15 & 0.16  
\backslash

\backslash
     17 & 0.18  
\backslash

\backslash
     }
\backslash
mydata
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}     
\backslash
begin{axis}[             ybar, 	    ymajorgrids,             bar width=.5cm,
             width=
\backslash
textwidth,             height=.5
\backslash
textwidth,             xtick=data,              xticklabels={$Q_{5}$,$Q_{6}$,$Q_
{7}$,$Q_{8}$,$Q_{9}$,$Q_{13}$,$Q_{14}$,$Q_{15}$,$Q_{16}$},             nodes
 near coords align={vertical},             ymin=0,ymax=8,             xmin=0,xma
x=18,             ylabel={Size (MB)},         ]         
\backslash
addplot table[x=interval,y=cls]{
\backslash
mydata};     
\backslash
end{axis} 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:perf-size2"

\end_inset

The sizes of the outputs of queries 
\begin_inset Formula $Q_{5}$
\end_inset

 to 
\begin_inset Formula $Q_{9}$
\end_inset

 and 
\begin_inset Formula $Q_{13}$
\end_inset

 to 
\begin_inset Formula $Q_{16}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pgfplotstableread[row sep=
\backslash

\backslash
,col sep=&]{     interval  & cls     
\backslash

\backslash
     1  & 1.72  
\backslash

\backslash
     3  & 1.10  
\backslash

\backslash
     5  & 1.25  
\backslash

\backslash
     7  & 2.73  
\backslash

\backslash
     9  & 2.24  
\backslash

\backslash
     }
\backslash
mydata
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}     
\backslash
begin{axis}[             ybar, 	    ymajorgrids,             bar width=.5cm,
             width=
\backslash
textwidth,             height=.5
\backslash
textwidth,             xtick=data,              xticklabels={{$Q_{1}$-$Q_{4}$},{
$Q_{5}$-$Q_{9}$},{$Q_{6}$-$Q_{9}$ (fact.)}, 		{$Q_{10}$-$Q_{12}$},{$Q_{13}$-$Q_{1
6}$}},             nodes near coords align={vertical},             ymin=0,ymax=3
,             xmin=0,xmax=10,             ylabel={Average Speedup},    
     ]         
\backslash
addplot table[x=interval,y=cls]{
\backslash
mydata};     
\backslash
end{axis} 
\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:perf-speed"

\end_inset

Average speedup of the runtime system w.r.t.
 the algebraic subsystem for the groups of queries in the benchmark.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
This benchmark highlights the key strengths of the two approaches for running
 AQL queries belonging to its core fragment, namely the one originally proposed
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Fagin:2015:DSF:2772377.2699442"

\end_inset

 and the algebraic one (
\begin_inset CommandInset citation
LatexCommand cite
key "4497502,Krishnamurthy:2009:SSD:1519103.1519105"

\end_inset

).
 The results suggest that a runtime system based on well-behaved eVset-automata
 can efficiently evaluate a join pattern, and its efficiency increases as
 longer chains of joins are used.
 Nonetheless, it cannot naturally exploit the redundancy of a query, although
 we saw that there exist ways to reduce it.
 On the other hand, the ability to avoid redundant work is a core aspect
 of the algebraic approach, and it can make a significant difference in
 large queries.
 In general, the runtime of a query seems to be determined by the amount
 of runs tried by the corresponding automaton, in the case of the runtime
 system, and by the total runs tried by the automata contained in the query,
 for the algebraic subsystem.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand include
filename "conclusion.lyx"

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "survey,systemT1,systemT2,spanners,datalog,regex,vm,regex2,obdd,kleenex,blogs,lms,ie"
options "apalike"

\end_inset


\end_layout

\end_body
\end_document
