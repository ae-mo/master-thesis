<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="http://www.nongnu.org/elyxer/">
<meta name="create-date" content="2016-07-16">
<link rel="stylesheet" href="http://elyxer.nongnu.org/lyx.css" type="text/css" media="all">
<title>Engineering a Runtime System for AQL</title>
</head>
<body>
<div id="globalWrapper">
<h1 class="title">
<span lang="en">Engineering a Runtime System for AQL</span>
</h1>
<h2 class="author">
Andrea Morciano
</h2>
<div class="Degree">
Docteur en XXX<br>
(Département XXX, Faculté XXX)
</div>
<div class="Dedication">
To my parents.
</div>
<div class="Acknowledgments">
Thank you, my advisor!
</div>
<div class="Unindented">
<div class="vspace" style="height: 4cm*;">

</div>

</div>
<div class="Indented">
<i>&ldquo;A great citation here</i>&rdquo;\begin_inset Separator latexpar\end_inset
</div>
<div class="Indented">
<div class="right">
X
</div>

</div>
<div class="abstract">
<p class="abstract-message">
Abstract
</p>
abstract of the thesis
</div>
<div class="fulltoc">
<div class="tocheader">
Table of Contents
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Chapter-1">Chapter 1: <span lang="en">Introduction</span></a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-1.1">Section 1.1: <span lang="en">Problem</span></a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-1.2">Section 1.2: <span lang="en">Objective</span></a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-1.3">Section 1.3: <span lang="en">Outline</span></a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-1.4">Section 1.4: <span lang="en">Contributions</span></a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-1.5">Section 1.5: <span lang="en">Publications</span></a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-1.6">Section 1.6: <span lang="en">Notations</span></a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-2">Chapter 2: Information Extraction</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-2.1">Section 2.1: Definition</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-2.2">Section 2.2: Example Applications</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-2.3">Section 2.3: Issues</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-2.3.1">Subsection 2.3.1: Accuracy</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-2.3.2">Subsection 2.3.2: Running Time</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-2.4">Section 2.4: Entity Extraction</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-2.4.1">Subsection 2.4.1: Rule-based Methods</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-2.4.2">Subsection 2.4.2: Statistical Methods</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-2.5">Section 2.5: Relationship Extraction</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-2.5.1">Subsection 2.5.1: Predicting the Relationship between an a Pair of Entities</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-2.5.2">Subsection 2.5.2: Finding All Possible Entity Pairs Belonging to a Relationship</a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-3">Chapter 3: SystemT and AQL</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-3.1">Section 3.1: SystemT</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-3.1.1">Subsection 3.1.1: Architecture</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.1.2">Subsection 3.1.2: Data Model</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.1.3">Subsection 3.1.3: Execution Model</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.1.4">Subsection 3.1.4: Algebra of Operators </a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.1.5">Subsection 3.1.5: Optimization Techniques</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-3.2">Section 3.2: AQL</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-3.3">Section 3.3: A Formalism for AQL’s Core: Variable Stack Automata and Variable Set Automata</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-3.3.1">Subsection 3.3.1: Basic Definitions</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.3.2">Subsection 3.3.2: Spanner Representations</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.3.3">Subsection 3.3.3: Algebras of Spanners</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.3.4">Subsection 3.3.4: Regular Spanners</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.3.5">Subsection 3.3.5: Core Spanners</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.3.6">Subsection 3.3.6: Difference</a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-4">Chapter 4: A Runtime System for AQL’s Core</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-4.1">Section 4.1: Extended Vset-automata</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-4.2">Section 4.2: Well-Behaved Extended Vset-Automata</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-4.3">Section 4.3: Methods for NFA execution</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-4.3.1">Subsection 4.3.1: The Thompson Approach</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.3.2">Subsection 4.3.2: Ordered Binary Decision Diagrams</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.3.3">Subsection 4.3.3: Kleenex</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-4.4">Section 4.4: Implementation</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-5">Chapter 5: <span lang="en">Conclusions</span></a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-5.1">Section 5.1: <span lang="en">Discussion</span></a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-5.2">Section 5.2: <span lang="en">Future Works</span></a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-5.3">Section 5.3: <span lang="en">Promising Directions</span></a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Appendix-A">Appendix A: Do we need an Appendix?</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#Index">Index</a>
</div>

</div>
<div class="fulltoc">
<div class="tocheader">
List of Figures
</div>
<div class="toc">
<a class="Link" href="#fig:tokenization">Figure 2.1: Decomposition of a sentence into a sequence of tokens.</a>
</div>
<div class="toc">
<a class="Link" href="#fig:segmentation2">Figure 2.2: Segmentation of a sentence.</a>
</div>
<div class="toc">
<a class="Link" href="#fig:query1">Figure 3.1: <span class="tiny">Yesterday I . It is about the relationship between a TV writer and his girlfriend, who wants to become an actress. I really . Although the sometimes, the . I’d recommend it to anyone.</span> Extraction of informal movie reviews.</a>
</div>
<div class="toc">
<a class="Link" href="#fig:AQL">Figure 3.2: Parts of the annotator from Figure  expressed in AQL.</a>
</div>
<div class="toc">
<a class="Link" href="#fig:running-ex">Figure 3.3: A string <span class="formula"></span> and the span relation obtained by applying spanner <span class="formula"></span> to <span class="formula"></span>.</a>
</div>
<div class="toc">
<a class="Link" href="#fig:parse">Figure 3.4:  A <span class="formula"></span>-parse <span class="formula"></span> for string <span class="formula"></span> (see Figure ).</a>
</div>
<div class="toc">
<a class="Link" href="#fig:vstk">Figure 3.5: A vstk-automaton <span class="formula"></span> with <span class="formula"></span>, where <span class="formula"></span> is the regex formula of  (see Example ).</a>
</div>
<div class="toc">
<a class="Link" href="#fig:vset">Figure 3.6: A vset-automaton <span class="formula"></span> with <span class="formula"></span>, for <span class="formula"></span> (this image is taken from ).</a>
</div>
<div class="toc">
<a class="Link" href="#fig:evset">Figure 4.1: An eVset-automaton <span class="formula"></span>.</a>
</div>
<div class="toc">
<a class="Link" href="#evset-2">Figure 4.2: An eVset-automaton <span class="formula"></span>.</a>
</div>
<div class="toc">
<a class="Link" href="#Figure-4.3">Figure 4.3: Example of the Thompson algorithm.</a>
</div>
<div class="toc">
<a class="Link" href="#Figure-4.4">Figure 4.4: Example programs.</a>
</div>
<div class="toc">
<a class="Link" href="#Figure-4.5">Figure 4.5: A program for the automaton <span class="formula"></span> of Figure .</a>
</div>

</div>
<div class="fulltoc">
<div class="tocheader">
List of Tables
</div>

</div>
<div class="Unindented">

</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-1">1</a> <span lang="en">Introduction</span>
</h1>
<h2 class="Section">
<a class="toc" name="toc-Section-1.1">1.1</a> <span lang="en">Problem</span>
</h2>
<div class="Unindented">
<span lang="en">citation example <span class="bibcites">[<a class="bibliocite" name="cite-1" href="#biblio-1">1</a>]</span></span>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-1.2">1.2</a> <span lang="en">Objective</span>
</h2>
<div class="Unindented">
<span lang="en">index example<a class="IndexReference" name="entry-example-0" href="#index-example">↓</a></span>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-1.3">1.3</a> <span lang="en">Outline</span>
</h2>
<div class="Unindented">
<span lang="en">blabla</span>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-1.4">1.4</a> <span lang="en">Contributions</span>
</h2>
<div class="Unindented">
<span lang="en">blabla</span>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-1.5">1.5</a> <span lang="en">Publications</span>
</h2>
<div class="Unindented">
<span lang="en">blabla</span>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-1.6">1.6</a> <span lang="en">Notations</span>
</h2>
<div class="Unindented">
<span lang="en">blabla</span>
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-2">2</a> Information Extraction
</h1>
<div class="Unindented">
In this chapter, I give a generic introduction to Information Extraction. This Chapter is a re-elaboration of <span class="bibcites">[<a class="bibliocite" name="cite-8" href="#biblio-8"><span class="bib-index">8</span></a>]</span>. Please refer to the original source for a more comprehensive and detailed overview. The figures and examples appearing in this Chapter are mine.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-2.1">2.1</a> Definition
</h2>
<div class="Unindented">
Information Extraction (IE) is the discipline that addresses the task of extracting structured information from unstructured sources automatically. Sources usually take the form of text documents. The most explored aspect of IE is the extraction of <i>named entities.</i> Another main topic, that has become object of research only in recent years, is the extraction of <i>relationships</i> between entities. IE is a field with contributions from many different communities: Machine Learning, Information Retrieval, Database, Web, Document Analysis. The interest towards it is motivated by the constantly increasing amount of data that is generated by our society. Manual analysis has become infeasible. IE promises to bring value to many application domains, most notably the enterprise world and the Web.
</div>
<div class="Indented">
<div class="defskip"> </div>
</div>
<div class="Indented">
There are two prominent approaches to IE: 
</div>
<div class="Description">
<span class="Description-entry"><i>rule-based</i></span> which define a set of rules that the output has to respect. The rules can be manually coded or learnt from examples;
</div>
<div class="Description">
<span class="Description-entry"><i>statistical</i></span> which seek to identify a decomposition of unstructured text and to label its components.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-2.2">2.2</a> Example Applications
</h2>
<div class="Paragraph">
<a class="toc" name="toc-Paragraph-1"></a>News Tracking
</div>
<div class="Unindented">
The activity of tracking events in news articles. It can result in a lot of useful services, like automatic creation of multimedia news, linking articles to information pages on the entities found, etc.
</div>
<div class="Paragraph">
<a class="toc" name="toc-Paragraph-2"></a>Data Cleaning
</div>
<div class="Unindented">
Extracting structured forms from flat data strings (containing, e.g., addresses). It allows more effective deduplication of information, among the other things.
</div>
<div class="Paragraph">
<a class="toc" name="toc-Paragraph-3"></a>Citation Databases
</div>
<div class="Unindented">
Articles, conference sites, individual research sites and similar are explored to obain formatted citations of publications, later stored in publicly accessible databases. They are capable to forward references and may provide aggregate statistics and scoring information. See, for instance, Google Scholar (<a class="FlexURL" href="https://scholar.google.com/">https://scholar.google.com/</a>).
</div>
<div class="Paragraph">
<a class="toc" name="toc-Paragraph-4"></a>Relationship Web Search
</div>
<div class="Unindented">
Relationship extraction would be a very useful feature to integrate into web search engines, as the keyword search that they offer at present time is only good for entity identification.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-2.3">2.3</a> Issues
</h2>
<div class="Unindented">
The main issues that have to be dealt with when performing IE can be divided in two categories: <i>accuracy</i> and <i>running time</i>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.3.1">2.3.1</a> Accuracy
</h3>
<div class="Unindented">
We measure the accuracy of an IE task with two quantities:
</div>
<ul>
<li>
<i>precision</i>: the percentage of correctly extracted entities among the extracted entities;
</li>
<li>
<i>recall</i>: the percentage of entities extracted among all the existing entities in the input source.
</li>

</ul>
<div class="Unindented">
The main difficulties to achieving a good level of accuracy are:
</div>
<ul>
<li>
the availability of a great set of clues that might be very different in nature (e. g. orghographic properties, part of speech, typical words, etc.) and that might be difficult to combine;
</li>
<li>
the difficulty of finding out missed extractions;
</li>
<li>
the fact that with the advancement of research the extracted data structures keep increasing in complexity (for instance it is becoming more difficult to identify the boundaries of an entity in a text).
</li>

</ul>
<div class="Unindented">
While it is possible to reach a very good level of accuracy for entity extraction (<span class="formula">90%</span>), relationship extraction is still quite unreliable (<span class="formula">50 − 70%</span> accuracy), mainly due to its intrinsic complexity.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.3.2">2.3.2</a> Running Time
</h3>
<div class="Unindented">
In its initial phase IE was interesting only to research communities. Nowadays companies, because of the enormous amount of data they need to process on a regular basis, are concerned with IE too, and <i>scalability</i> has become a central issue, while many IE systems don’t address the problem of efficiently carrying out extraction tasks with sufficient attention. Efficiency is influenced most notably by the efficiency of the following tasks:
</div>
<ul>
<li>
filtering documents in order to actually examine only the ones that have good chances to contain the desired information;
</li>
<li>
focusing on the parts of a document that contain relevant information;
</li>
<li>
processing steps, like database querying, that are typically very expensive and that might have to be performed on the selected pieces of input.
</li>

</ul>
<div class="Unindented">
Recently many solutions have been proposed to target the scalability issue; one of these is SystemT.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-2.4">2.4</a> Entity Extraction<a class="Label" name="sec:Entity-Extraction"> </a>
</h2>
<div class="Unindented">
Named entities are elements of interest in a text. Example of entities are person names, street addresses, institutions, countries, and so on. In this section and in the next one, I assume that the output of an extraction task is a series of labels inserted into an input text document (that becomes <i>annotated</i>), although there are other possible output formats.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.4.1">2.4.1</a> Rule-based Methods
</h3>
<div class="Unindented">
Rule-based methods employ sets of predicates that are &ldquo;fired&rdquo; independently. When a portion of input text satisfies a predicate, the predicate’s associated action is executed. A predicate can be represented in the following generic form:
</div>
<div class="Indented">
<div class="formula">
<a class="eqnumber" name="eq-2.1">(2.1) </a><span class="textrm">"Contextual Pattern</span>⟶<span class="textrm">Action"</span>
</div>
Contextual patterns are a way to identify entitities by exploiting their properties or the context in which they are usually met. The most common formalism used to express them is that of <i>regular expressions</i> over tokens of the input. Actions mark the entities that have been identified, and might consist in storing them in a database or adding delimiters directly in the text.
</div>
<div class="Indented">
Most systems in this category present a <i>cascaded structure</i>: an input document goes through a series of processing phases, and the output of a phase is the input of the next one. A famous example is that of <i>cascading grammars</i>: formal grammars are evaluated in sequence on the input.
</div>
<div class="Indented">
As I said, a contextual pattern seeks for (groups of) tokens that have certain features. In the case of entity extraction, features can be classified in the following categories:
</div>
<ul>
<li>
string representation;
</li>
<li>
orthography (e.g. small case, mixed case, number, etc.);
</li>
<li>
part of speech;
</li>
<li>
list of dictionaries they’re contained into;
</li>
<li>
annotation obtained in previous phases.
</li>

</ul>
<div class="Unindented">
Rules can be hand-coded by experts or learned through learning algorithms. In the second case the goal is to cover each of the entities of interest in the training set with at least one rule. The obtained rules should have good recall and precision on new input. Moreover, when learning a set of rules, we would like to achieve a good level of <i>generalizability</i>, that is: we would like to find the minimum set of rules accounting for the maximum portion of training data, with high precision. There are two main strategies for rule learning: <i>bottom-up</i> (start from very specific rules and make them more and more general) and <i>top-down</i> (start with rules covering all existing instances, then specialize them).
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-1"></a>Example Rules
</h4>
<div class="Unindented">
For the examples I use an idealized syntax, as in <span class="bibcites">[<a class="bibliocite" name="cite-8" href="#biblio-8"><span class="bib-index">8</span></a>]</span>.
</div>
<div class="Example">
Consider the task of identifying all mentions ISO standards in a text. A rule for this purpose could be:
</div>
<div class="Example">
<div class="formula">
<a class="eqnumber" name="eq-2.2">(2.2) </a><span class="environment"><span class="arrayrow">
<span class="arraycell align-l">
<span class="symbol">(</span><span class="symbol">{</span><span class="textrm">String</span> = <span class="textrm">"ISO"</span><span class="symbol">}</span><span class="symbol">{</span><span class="textrm">String</span> = <span class="textrm">"/IEC"</span><span class="symbol">}</span><span class="symbol">{</span><span class="textrm">?</span><span class="symbol">}</span><span class="symbol">{</span><span class="textrm">String</span> = <span class="textrm">"/ASTM"</span><span class="symbol">}</span><span class="symbol">{</span><span class="textrm">?</span><span class="symbol">}</span><span class="rightdot"></span>
</span>

</span>
<span class="arrayrow">
<span class="arraycell align-l">
 
</span>

</span>
<span class="arrayrow">
<span class="arraycell align-l">
<span class="leftdot"></span><span class="symbol">{</span><span class="textrm">Orthography type</span> = <span class="textrm">number</span><span class="symbol">}</span><span class="symbol">{</span><span class="symbol">{</span><span class="textrm">String</span> = <span class="textrm">":"</span><span class="symbol">}</span><span class="symbol">{</span><span class="textrm">Orthography type</span> = <span class="textrm">number</span><span class="symbol">}</span><span class="symbol">}</span><span class="symbol">{</span><span class="textrm">?</span><span class="symbol">}</span><span class="symbol">)</span>
</span>

</span>
<span class="arrayrow">
<span class="arraycell align-l">
 
</span>

</span>
<span class="arrayrow">
<span class="arraycell align-l">
⟶<span class="textrm">ISO Standards</span>
</span>

</span>
</span>
</div>

</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Example">
Multiple entities can be matched at once. Imagine we need to find mentions of (simple) street addresses in a text consisting of a street name and a street number. A rule that matches the name and number separatedly could be:
</div>
<div class="Example">
<div class="formula">
<a class="eqnumber" name="eq-2.3">(2.3) </a><span class="environment"><span class="arrayrow">
<span class="arraycell align-l">
<span class="symbol">(</span><span class="symbol">{</span><span class="textrm">Orthography type</span> = <span class="textrm">mixed case word</span><span class="symbol">}</span><span class="symbol">{</span><span class="textrm">*</span><span class="symbol">}</span><span class="symbol">)</span><span class="textrm">: Name</span><span class="symbol">(</span><span class="symbol">{</span><span class="textrm">String</span> = <span class="textrm">","</span><span class="symbol">}</span><span class="symbol">)</span>
</span>

</span>
<span class="arrayrow">
<span class="arraycell align-l">
 
</span>

</span>
<span class="arrayrow">
<span class="arraycell align-l">
<span class="symbol">(</span><span class="symbol">{</span><span class="textrm">Orthography type</span> = <span class="textrm">number</span><span class="symbol">}</span><span class="symbol">)</span><span class="textrm">: Number</span>
</span>

</span>
<span class="arrayrow">
<span class="arraycell align-l">
 
</span>

</span>
<span class="arrayrow">
<span class="arraycell align-l">
⟶<span class="textrm">Street Name</span> = :<span class="textrm">Name, </span><span class="textrm">Street Number</span> = :<span class="textrm">Number</span>
</span>

</span>
</span>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.4.2">2.4.2</a> Statistical Methods
</h3>
<div class="Unindented">
Statistical methods aim to decompose the source, assigning a label to each element in the decomposition. We distinguish between three types of statistical models:
</div>
<ul>
<li>
<i>Token-level models</i>: they assign a label to each token of the source. Since entities are usually comprised of multiple adjacent tokens, the tags used are of the forms &ldquo;entity_begin&rdquo;, &ldquo;entity_continue&rdquo;, &ldquo;entity_end&rdquo;;
</li>
<li>
<i>Segment-level models</i>: they try to find the best segmentation of the source text;
</li>
<li>
<i>Grammar-based models: </i>they use formal grammars, outputting parse trees. All the valid parses are considered for an input document, assigning a score to each. The parse with the highest score is retained.
</li>

</ul>
<div class="Unindented">
I now give a brief description of Token-level Models and Segment-level Models.
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-2"></a>Token-Level Models<a class="Label" name="subsec:Token-Level-Models"> </a>
</h4>
<div class="Paragraph">
<a class="toc" name="toc-Paragraph-5"></a>Features
</div>
<div class="Unindented">
The clues that these models exploit are of the form <div class="formula">
<a class="eqnumber" name="eq-2.4">(2.4) </a><i>f</i>:<span class="symbol">(</span><b>x</b>, <i>y</i>, <i>i</i><span class="symbol">)</span>⟼ℝ
</div>
where <span class="formula"><b>x</b></span> is a sequence of tokens, <span class="formula"><i>i</i></span> is a position in <span class="formula"><b>x</b></span> and <span class="formula"><i>y</i></span> is a candidate label for the token at <span class="formula"><i>i</i></span>. We distinguish between these types of features:
</div>
<ul>
<li>
<i>word features</i>;
</li>
<li>
<i>orthographic features;</i>
</li>
<li>
<i>dictionary lookup features.</i>
</li>

</ul>
<div class="Unindented">
<div class="float">
<a class="Label" name="fig:tokenization"> </a><div class="figure">
Yesterday I watched a movie called &ldquo;The Matrix&rdquo;<table>
<tr>
<td align="center" valign="top">
i
</td>
<td align="center" valign="top">
1
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
3
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
5
</td>
<td align="center" valign="top">
6
</td>
<td align="center" valign="top">
7
</td>
<td align="center" valign="top">
8
</td>
<td align="center" valign="top">
9
</td>
<td align="center" valign="top">
10
</td>

</tr>
<tr>
<td align="center" valign="top">
x
</td>
<td align="center" valign="top">
Yesterday
</td>
<td align="center" valign="top">
I
</td>
<td align="center" valign="top">
watched
</td>
<td align="center" valign="top">
a
</td>
<td align="center" valign="top">
movie
</td>
<td align="center" valign="top">
called
</td>
<td align="center" valign="top">
&ldquo;
</td>
<td align="center" valign="top">
The
</td>
<td align="center" valign="top">
Matrix
</td>
<td align="center" valign="top">
&ldquo;
</td>

</tr>
<tr>
<td align="center" valign="top">
y
</td>
<td align="center" valign="top">
<span class="formula"><i>y</i><sub>1</sub></span>
</td>
<td align="center" valign="top">
<span class="formula"><i>y</i><sub>2</sub></span>
</td>
<td align="center" valign="top">
<span class="formula"><i>y</i><sub>3</sub></span>
</td>
<td align="center" valign="top">
<span class="formula"><i>y</i><sub>4</sub></span>
</td>
<td align="center" valign="top">
<span class="formula"><i>y</i><sub>5</sub></span>
</td>
<td align="center" valign="top">
<span class="formula"><i>y</i><sub>6</sub></span>
</td>
<td align="center" valign="top">
<span class="formula"><i>y</i><sub>7</sub></span>
</td>
<td align="center" valign="top">
<span class="formula"><i>y</i><sub>8</sub></span>
</td>
<td align="center" valign="top">
<span class="formula"><i>y</i><sub>9</sub></span>
</td>
<td align="center" valign="top">
<span class="formula"><i>y</i><sub>10</sub></span>
</td>

</tr>

</table>
<div class="caption">
Figure 2.1 Decomposition of a sentence into a sequence of tokens.
</div>

</div>

</div>

</div>
<div class="Example">
Consider the sentence shown in Figure <a class="Reference" href="#fig:tokenization">2.1↑</a> and its corresponding decomposition. An example of word feature at position 5 is
</div>
<div class="Example">
<div class="formula">
<i>f</i><sub>1</sub><span class="symbol">(</span><i>y</i>, <b>x</b>, <i>i</i><span class="symbol">)</span> = <span class="symbol">⟦</span><i>x</i><sub><i>i</i></sub><span class="textrm"> equals "Matrix"</span><span class="symbol">⟧</span>⋅<span class="symbol">⟦</span><i>y</i> = <span class="textrm">Movie</span><span class="symbol">⟧</span>
</div>
where <span class="formula"><span class="symbol">⟦</span><i>P</i><span class="symbol">⟧</span> = 1</span> if predicate <span class="formula"><i>P</i></span> is true, and 0 otherwise. An orthographic feature might be
</div>
<div class="Example">
<div class="formula">
<i>f</i><sub>2</sub><span class="symbol">(</span><i>y</i>, <b>x</b>, <i>i</i><span class="symbol">)</span> = <span class="symbol">⟦</span><i>x</i><sub><i>i</i></sub><i>x</i><sub><i>i</i> + 1</sub><span class="textrm">  matches INITIAL_QUOTE CapsWord</span><span class="symbol">⟧</span>⋅<span class="symbol">⟦</span><i>y</i> = <span class="textrm">Movie</span><span class="symbol">⟧</span>.
</div>

</div>
<div class="Example">
Finally, an example of dictionary lookup feature is
</div>
<div class="Example">
<div class="formula">
<i>f</i><sub>3</sub><span class="symbol">(</span><i>y</i>, <b>x</b>, <i>i</i><span class="symbol">)</span> = <span class="symbol">⟦</span><i>x</i><sub><i>i</i></sub><span class="textrm"> in Movie_dictionary</span><span class="symbol">⟧</span>⋅<span class="symbol">⟦</span><i>y</i> = <span class="textrm">Movie</span><span class="symbol">⟧</span>.
</div>

</div>
<div class="Paragraph">
<a class="toc" name="toc-Paragraph-6"></a>Models for Labeling Tokens
</div>
<div class="Unindented">
The best models are the ones that take into account dependencies between tokens, among which we may find:
</div>
<ul>
<li>
<i>ordered classifiers</i>;
</li>
<li>
<i>Hidden Markov models;</i>
</li>
<li>
<i>Maximum Entropy Taggers;</i>
</li>
<li>
<i>Conditional Markov Models;</i>
</li>
<li>
<i>Conditional Random Fields </i>(the state of the art).
</li>

</ul>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-3"></a>Segment-Level Models
</h4>
<div class="Paragraph">
<a class="toc" name="toc-Paragraph-7"></a>Features
</div>
<div class="Unindented">
In these models the label for a segment depends on the properties of its tokens and on the previous segment. We can describe a segment <span class="formula"><i>s</i><sub><i>j</i></sub></span> as:<div class="formula">
<a class="eqnumber" name="eq:segment">(2.5) </a><i>s</i><sub><i>j</i></sub> = <span class="symbol">(</span><i>y</i><sub><i>i</i></sub>, <i>l</i><sub><i>j</i></sub>, <i>u</i><sub><i>j</i></sub><span class="symbol">)</span>
</div>
where <span class="formula"><i>y</i><sub><i>i</i></sub></span> is the proposed label for <span class="formula"><i>s</i><sub><i>j</i></sub></span> and <span class="formula"><i>l</i><sub><i>j</i></sub>, <i>u</i><sub><i>j</i></sub></span> are the start and end positions of <span class="formula"><i>s</i><sub><i>j</i></sub></span>. Therefore, a feature is of the form:<div class="formula">
<a class="eqnumber" name="eq-2.6">(2.6) </a><i>f</i><span class="symbol">(</span><i>y</i><sub><i>i</i></sub>, <i>y</i><sub><i>i</i> − 1</sub>, <b> x</b>, <i>l</i><sub><i>j</i></sub>, <i>u</i><sub><i>j</i></sub><span class="symbol">)</span>
</div>
where <span class="formula"><b>x</b></span> is the input sequence of tokens, <span class="formula"><i>y</i><sub><i>i</i> − 1</sub></span> is the proposed label for the previous segment and the other symbols are defined as for Equation <a class="Reference" href="#eq:segment">2.5↑</a>. Besides token-level features (see Subsection <a class="Reference" href="#subsec:Token-Level-Models">2↑</a>), we can exploit the following feature types:
</div>
<ul>
<li>
<i>Similarity to an entity in a database;</i>
</li>
<li>
<i>Length of the segment.</i>
</li>

</ul>
<div class="Unindented">
<div class="float">
<a class="Label" name="fig:segmentation2"> </a><div class="figure">
&ldquo;The Matrix&rdquo; by The Wachowski Brothers<table>
<tr>
<td align="center" valign="top">
i
</td>
<td align="center" valign="top">
<div class="PlainVisible">
<table>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
1
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
2
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
3
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
4
</div>

</td>

</tr>

</table>

</div>

</td>
<td align="center" valign="top">
5
</td>
<td align="center" valign="top">
<div class="PlainVisible">
<table>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
6
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
7
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
8
</div>

</td>

</tr>

</table>

</div>

</td>

</tr>
<tr>
<td align="center" valign="top">
x
</td>
<td align="center" valign="top">
&ldquo;The Matrix&rdquo;
</td>
<td align="center" valign="top">
by
</td>
<td align="center" valign="top">
The Wachowski Brothers
</td>

</tr>
<tr>
<td align="center" valign="top">
<span class="formula"><span class="symbol">(</span><i>l</i><sub><i>j</i></sub>, <i>u</i><sub><i>j</i></sub>, <i>y</i><sub><i>i</i></sub><span class="symbol">)</span></span>
</td>
<td align="center" valign="top">
<span class="formula">1, 4, <i>M</i></span>
</td>
<td align="center" valign="top">
<span class="formula">5, 5, <i>O</i></span>
</td>
<td align="center" valign="top">
<span class="formula">6, 8, <i>D</i></span>
</td>

</tr>

</table>
<div class="caption">
Figure 2.2 Segmentation of a sentence.
</div>

</div>

</div>

</div>
<div class="Example">
Consider the sentence in Figure <a class="Reference" href="#fig:segmentation2">2.2↑</a> and its corresponding segmentation, which identifies a movie and a director. A basic feature similarity feature for the director could be:
</div>
<div class="Example">
<div class="formula">
<i>f</i><span class="symbol">(</span><i>y</i><sub><i>i</i></sub>, <i>y</i><sub><i>i</i> − 1</sub>, <b> x</b>, 6, 8<span class="symbol">)</span> = <span class="symbol">⟦</span><i>x</i><sub>6</sub><i>x</i><sub>7</sub><i>x</i><sub>8</sub><span class="textrm">  appears in a list of movie directors</span><span class="symbol">⟧</span>⋅<span class="symbol">⟦</span><i>y</i><sub><i>i</i></sub> = <span class="textrm">Director</span><span class="symbol">⟧</span>.
</div>

</div>
<div class="Example">
A more realistic feature would make use of some similarity function, rather than requiring an extact match. An example of length feature is
</div>
<div class="Example">
<div class="formula">
<i>f</i><span class="symbol">(</span><i>y</i><sub><i>i</i></sub>, <i>y</i><sub><i>i</i> − 1</sub>, <b> x</b>, <i>l</i>, <i>u</i><span class="symbol">)</span> = <span class="symbol">⟦</span><i>u</i> − <i>l</i> = 3<span class="symbol">⟧</span>⋅<span class="symbol">⟦</span><i>y</i><sub><i>i</i></sub> = <span class="textrm">Director</span><span class="symbol">⟧</span>.
</div>

</div>
<div class="Example">
<div class="defskip"> </div>
</div>
<div class="Unindented">
There exist also global segmentation models, that try to find the best segmentation of a token sequence by maximizing a target function.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-2.5">2.5</a> Relationship Extraction
</h2>
<div class="Unindented">
When exctracting relationships between entities, we might face three types of specific tasks:
</div>
<ol>
<li>
given a pair of entities, find the relationship between them;
</li>
<li>
given an entity <span class="formula"><i>e</i></span> and a relationship <span class="formula"><i>r</i></span>, find all the other entities <span class="formula"><i>e</i>’</span> such that <span class="formula"><span class="symbol">(</span><i>e</i>, <i>e</i>’<span class="symbol">)</span> ∈ <i>r</i></span>;
</li>
<li>
given a big and open-ended input and a relationship <span class="formula"><i>r</i></span> find all pairs of entities <span class="formula"><i>e</i>’, <i>e</i>’’</span> such that <span class="formula"><span class="symbol">(</span><i>e</i>’, <i>e</i>’’<span class="symbol">)</span> ∈ <i>r</i></span>.
</li>

</ol>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.5.1">2.5.1</a> Predicting the Relationship between an a Pair of Entities
</h3>
<div class="Unindented">
For the first task, we can exploit the following resources:
</div>
<ul>
<li>
<i>surface tokens</i>: tokens that are usually placed between entities. They are strong clues;
</li>
<li>
<i>part of speech tags </i>(the most important being verbs);
</li>
<li>
<i>syntactic parse tree</i>: allows grouping words in phrase types, e.g. noun phrases, propositional phrases, and so on;
</li>
<li>
<i>dependency graph</i>: it is a less expensive structure to compute than the parse tree and it links a word to those that depend on it.
</li>

</ul>
<div class="Unindented">
The main methods available to carry out the task are:
</div>
<ul>
<li>
<i>Feature-based methods</i>, that simply transform the clues mentioned above for usage by conventional classifier models;
</li>
<li>
<i>Kernel-based methods</i>, that use kernel functions to encode the similarity between two graphs;
</li>
<li>
<i>Rule-based methods</i>, creating rules over structures around pairs of entities.
</li>

</ul>
<div class="Unindented">
The second task is a special case of the third, and won’t be treated here.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-2.5.2">2.5.2</a> Finding All Possible Entity Pairs Belonging to a Relationship
</h3>
<div class="Unindented">
The third task can be met especially when dealing with the Web. Usually we can exploit the following resources to fulfill it:
</div>
<ul>
<li>
the <i>types of arguments</i> of <span class="formula"><i>r</i></span> (that might need specific recognition patterns);
</li>
<li>
a <i>seed database</i> of pairs of entities belonging to <span class="formula"><i>r</i></span>;
</li>
<li>
<i>manually coded patterns</i>.
</li>

</ul>
<div class="Unindented">
The generic procedure that is used in this case can be described with these steps:
</div>
<ol>
<li>
Use the seed database to learn the relevant extraction patterns;
</li>
<li>
Use the obtained patterns to define candidate triples of the form <span class="formula"><span class="symbol">(</span><i>e</i>’, <i>e</i>’’, <i>r</i><span class="symbol">)</span></span>;
</li>
<li>
Retain a subset of the candidate triples, using a statistical test.
</li>

</ol>
<div class="Unindented">
There exist also rule-based methods for the task. 
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-3">3</a> SystemT and AQL
</h1>
<div class="Unindented">
In this chapter, I give a description of <i>SystemT</i> and its extraction rule language <i>AQL</i> (Annotation Query Language), and of a new way of evaluating AQL queries, that uses a formalism derived from <i>Finite State Automata</i>. This chapter is a re-elaboration from <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>, <a class="bibliocite" name="cite-7" href="#biblio-7"><span class="bib-index">7</span></a>, <a class="bibliocite" name="cite-5" href="#biblio-5"><span class="bib-index">5</span></a>]</span>. In particular, the mathematical statements from <a class="Reference" href="#first-stat">3.1.2↓</a> to <a class="Reference" href="#.last-stat">3.3.6↓</a> are taken or adapted from <span class="bibcites">[<a class="bibliocite" name="cite-5" href="#biblio-5"><span class="bib-index">5</span></a>]</span>, except for Remarks <a class="Reference" href="#first-rem">3.1.5↓</a> to <a class="Reference" href="#last-rem">3.1.5↓</a>, that come from <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span>. Please refer to the original sources for more details on the topic. The figures and examples appearing in this chapter are mine, except when I explicitly state otherwise.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.1">3.1</a> SystemT
</h2>
<div class="Unindented">
As I mentioned in the previous chapter, scalability is now a main concern in IE. Companies rely on IE for many tasks; a prominent example is <i>Business Intelligence</i>. Unfortunately, many systems developed in the past don’t address this issue correctly. Traditionally, most rule-based system rely on cascading grammars: formal grammars are executed in sequence on the input, each grammar representing a stage that takes as input the ouput of the previous one. Rules in such grammars are matched using regular expressions: if a part of the input text satisfies the regular expression associated with a rule, that rule is activated (i.e. &ldquo;fires&rdquo;) and the corresponding action is executed. Evaluating a grammar on a document tends to be costly, because simply evaluating a single rule might require scanning the whole document. On large datasets, the running time becomes enormous. What’s more, these kind of systems are not able to fulfill the expressivity requirements of the complex extraction tasks.
</div>
<div class="Indented">
SystemT was developed at IBM to address these issues. This system is based on a new approach to extraction rules: the <i>algebraic approach</i>. Here, data manipulations are viewed as operations in a (relational) algebra. Extraction tasks are defined using <i>annotators</i> (see Section <a class="Reference" href="#sec:Entity-Extraction">2.4↑</a>) whose rules are viewed as <i>queries</i> on input documents, that act as virtual databases. Complex annotators are obtained by combining simple ones by means of <i>relational operators</i>. By doing so, all the optimization techniques used in regular databases become available, but new techniques are possible too, due to the characteristics of text documents. Another advantage of SystemT is that it is capable to handle <i>overlapping rule matchings</i>, due to rulels being fired independently, which are difficult to resolve in cascading grammars, where they tipically require disambiguation policies that only partially solve the problem.
</div>
<div class="Indented">
I now give an overview of SystemT’s high-level structure. Then, I talk about its data model, execution model and algebra. For more information on SystemT and AQL, please refer to <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>, <a class="bibliocite" name="cite-7" href="#biblio-7"><span class="bib-index">7</span></a>]</span>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.1.1">3.1.1</a> Architecture
</h3>
<div class="Unindented">
These are the main components of SystemT:
</div>
<div class="Description">
<span class="Description-entry">Development Environment:</span> allows constructing annotators for extraction tasks. Rules are expressed in AQL, and compiled into an algebra. It supports an iterative development process.
</div>
<div class="Description">
<span class="Description-entry">Optimizer:</span> seeks for the best query plan for an extraction task, evaluating the most convenient optimization techniques in a cost-based manner.
</div>
<div class="Description">
<span class="Description-entry">Runtime Environment:</span> given a query plan, it instantiates the physical operators corresponding to the logical ones in the plan, then it proceeds evaluating it on input documents.
</div>
<div class="Unindented">
Once the development of an annotator is complete, it is <i>published</i> to the optimizer and runtime. After optimization, the runtime evaluates it on a continuous stream of documents.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.1.2">3.1.2</a> Data Model<a class="Label" name="subsec:Data-Model"> </a>
</h3>
<div class="Unindented">
SystemT uses an <i>object-relational</i> data model for annotations on a text document, that allows applying logical operators over it. Operators can be composed. There is an important assumption to mention before continuing: an extraction task over a set of documents is performed on one document at a time. This means that any relationships between entities in different documents are disregarded. This assumption is crucial to some optimization techniques that SystemT uses. While there exist tasks where considering these relationships would be useful (think of the Web), still a large number of relevant tasks can be carried out this way. In the following, I report the definitions of the basic data types in the data model of SystemT.
</div>
<div class="Indented">
<div class="defskip"> </div>
</div>
<div class="Indented">
I consider a finite alphabet <span class="formula">Σ</span> of symbols (characters). <span class="formula">Σ<sup>*</sup></span> denotes the set of all strings of finite length over <span class="formula">Σ</span>. A document is modeled as one such string. 
</div>
<div class="Definition">
<a class="Label" name="first-stat"> </a>A document is a string <span class="formula"><b>s</b> ∈ Σ<sup>*</sup></span>.
</div>
<div class="Unindented">
The most basic data type is the <i>span</i>.
</div>
<div class="Definition">
Given a string <span class="formula"><b>s</b> = <i>σ</i><sub>1</sub>...<i>σ</i><sub><i>n</i></sub></span> where <span class="formula">∀<i>i</i></span>, <span class="formula"><i>σ</i><sub><i>i</i></sub> ∈ Σ</span>, with length<span class="formula"><span class="symbol">|</span><b>s</b><span class="symbol">|</span> = <i>n</i></span> and whose characters are indexed in the natural way, a span is a substring <span class="formula"><span class="symbol">[</span><i>i</i>, <i>j</i><span class="symbol">⟩</span></span>, where <span class="formula"><i>i</i></span>, <span class="formula"><i>j</i></span> are indices of <span class="formula"><i>s</i></span> satisfying <span class="formula">1 ≤ <i>i</i> ≤ <i>j</i> ≤ <i>n</i> + 1</span>. A span of <span class="formula"><b>s</b></span> is also denoted as <span class="formula"><b>s</b><sub><span class="symbol">[</span><i>i</i>, <i>j</i><span class="symbol">⟩</span></sub></span>.
</div>
<div class="Unindented">
Spans can be aggregated in <i>tuples</i>, which are finite sequences of spans<i>. </i>Let us denote the set of all possible spans of a string <span class="formula"><b>s</b></span> by <span class="formula"><span class="textrm">Spans</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span> and by <span class="formula"><span class="textrm">SVars</span></span> an infinite set of span variables, which can be assigned spans. A <span class="formula"><span class="symbol">(</span><i>V</i>, <b>s</b><span class="symbol">)</span> − <span class="textrm">tuple</span></span> is defined as follows:
</div>
<div class="Definition">
Given a set <span class="formula"><i>V</i> ⊆ <span class="textrm">SVars</span></span>, <span class="formula"><i>V</i></span> being finite, and a string <span class="formula"><b>s</b> ∈ <span class="limits"><span class="limit">∑</span></span><sup>*</sup></span>, a <span class="formula"><span class="symbol">(</span><i>V</i>, <b>s</b><span class="symbol">)</span> − <span class="textrm">tuple</span></span> is a mapping <span class="formula"><i>μ</i>:<i>V</i>⟼<span class="textrm">Spans</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span>. When <span class="formula"><i>V</i></span> is clear from the context, we might call <span class="formula"><i>μ</i></span> simply a <span class="formula"><b>s</b> − <span class="textrm">tuple</span></span>.
</div>
<div class="Unindented">
A set of tuples is called a <i>relation. </i>Here, we focus on <i>span relations</i>, which are formally defined as <span class="formula"><span class="symbol">(</span><i>V</i>, <b>s</b><span class="symbol">)</span> − <span class="textrm">relations</span></span>.
</div>
<div class="Definition">
<a class="Label" name="span-relation"> </a>A <span class="formula"><span class="symbol">(</span><i>V</i>, <b>s</b><span class="symbol">)</span> − <span class="textrm">relation</span></span> is a set of <span class="formula"><span class="symbol">(</span><i>V</i>, <b>s</b><span class="symbol">)</span> − <span class="textrm">tuples</span></span>. As before, we can speak of <span class="formula"><b>s</b> − <span class="textrm">relation</span></span> when <span class="formula"><i>V</i></span> is clear.
</div>
<div class="Unindented">
Each operator in the algebra of SystemT takes one or more span relations as input and outputs a single span relation.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.1.3">3.1.3</a> Execution Model<a class="Label" name="subsec:Execution-Model"> </a>
</h3>
<div class="Unindented">
A single document is conceived as a <i>local annotation database</i>, to which annotators are applied in order to build <i>views</i>. In general, a local database fits into main memory. Local databases are contained in a <i>global annotation database</i>. The runtime of SystemT takes a global database and it annotates its local databases. The procedure is described by Algorithm <a class="Reference" href="#alg:Annotating-all-local">3.1↓</a>.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="alg:Annotating-all-local"> </a><div class="algorithm">
<div class="PlainVisible">
<span class="formula"><i>E</i>⟵<span class="symbol">{</span><span class="textrm">algebra expression</span><span class="symbol">}</span></span><br>
for localDB in globalDB do<br>
begin
</div>
<ol>
<li>
<span class="formula"><span class="symbol">{</span><span class="textrm">Read localDB into main memory</span><span class="symbol">}</span></span>
</li>
<li>
<span class="formula"><i>R</i>⟵<i>E</i><span class="symbol">(</span><span class="textrm">localDB</span><span class="symbol">)</span></span>
</li>
<li>
<span class="formula"><span class="symbol">{</span><span class="textrm">Add <span class="ensuremath">R</span>to localDB</span><span class="symbol">}</span></span>
</li>
<li>
<span class="formula"><span class="symbol">{</span><span class="textrm">Write modified localDB to disk</span><span class="symbol">}</span></span>
</li>

</ol>
<div class="caption">
Algorithm 3.1 Annotating all local databases in a global database (taken from <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>]</span>).
</div>

</div>

</div>

</div>
<div class="Indented">
In this procedure, step 2 in the for loop is the most expensive.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.1.4">3.1.4</a> Algebra of Operators <a class="Label" name="subsec:Algebra-of-Operators"> </a>
</h3>
<div class="Unindented">
The operators of SystemT’s algebra can be classified in three groups:
</div>
<ul>
<li>
<i>relational operators;</i>
</li>
<li>
<i>span extraction operators;</i>
</li>
<li>
<i>span aggregation operators.</i>
</li>

</ul>
<div class="Unindented">
In addition, there exist some <i>span selection predicates</i> that are used for span selection.
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-4"></a>Relational Operators
</h4>
<div class="Unindented">
Relational operators are the usual operators of relational algebra that appear in classical database query plans. Important examples are:
</div>
<ul>
<li>
<i>selection</i> (<span class="formula"><i>σ</i></span>);
</li>
<li>
<i>projection </i>(<span class="formula"><i>π</i></span>);
</li>
<li>
<i>Cartesian product </i>(<span class="formula"> × </span>);
</li>
<li>
Join (<span class="formula">⋈</span>);
</li>
<li>
<i>Union</i> (<span class="formula">∪</span>);
</li>
<li>
<i>Intersection</i> (<span class="formula">∩</span>).
</li>

</ul>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--1"></a>Span Extraction Operators
</h4>
<div class="Unindented">
Loosely speaking, span extraction operators take a pattern and a document as input and output a maximal set of spans that match that pattern. There are two main span extraction operators:
</div>
<div class="Labeling">
<i>standard regular expression matcher (<span class="formula"><i>ε</i><sub><i>re</i></sub></span>)</i>: this operator takes a regular expression <span class="formula"><i>r</i></span> as input and it identifies all non-overlapping matchings of <span class="formula"><i>r</i></span> in the current document, from left to right.
</div>
<div class="Labeling">
<i>dictionary matcher (<span class="formula"><i>ε</i><sub><i>d</i></sub></span>)</i>:<i> </i>this operator outputs all the spans that match some entry in a given dictionary.
</div>
<div class="Unindented">
Although the dictionary matcher might seem useless since there is a regular expression matcher, it has some advantages over it, as the fact that it can find overlapping matchings or that it enforces the semantics of word boundaries.
</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--2"></a>Span Aggregation Operators
</h4>
<div class="Unindented">
Span aggregation operators are used to aggregate spans in a meaningful way. They are of two types:
</div>
<ul>
<li>
<i>Consolidation</i>: they are used to coalesce overlapping spans that were matched using patterns for the same concept. They are: \begin_inset Separator latexpar\end_inset<div class="Labeling">
<i>containment consolidation (<span class="formula"><i>Ω</i><sub><i>c</i></sub></span>)</i>:<i> </i>it discards a span if it is fully contained into another one.
</div>
<div class="Labeling">
<i>overlap consolidation (<span class="formula"><i>Ω</i><sub><i>o</i></sub></span>)</i>:<i> </i>it merges spans that overlap repeatedly.
</div>

</li>
<li>
<i>Block (<span class="formula"><i>β</i></span>)</i>: it matches a series of spans, each at a distance from its neighbor span(s) that is not superior to a threshold. It is thought to identify regularity. It is tuned by two parameters: a <i>distance constraint</i> to control regularity and a <i>count constraint </i>that establishes the minimum number of spans in a block.
</li>

</ul>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-5"></a>Span Selection Predicates
</h4>
<div class="Unindented">
Consider two spans <span class="formula"><i>s</i><sub>1</sub>, <i>s</i><sub>2</sub></span>. The main span predicates that may be used for selection are the following:
</div>
<div class="Labeling">
<span class="formula"><i>s</i><sub>1</sub>≼<sub><i>d</i></sub><i>s</i><sub>2</sub></span> when <span class="formula"><i>s</i><sub>1</sub>, <i>s</i><sub>2</sub></span> do not overlap, <span class="formula"><i>s</i><sub>1</sub></span> precedes <span class="formula"><i>s</i><sub>2</sub></span> and there are less than <span class="formula"><i>d</i></span> characters between them;
</div>
<div class="Labeling">
<span class="formula"><i>s</i><sub>1</sub>≃<i>s</i><sub>2</sub></span> when the two spans overlap;
</div>
<div class="Labeling">
<span class="formula"><i>s</i><sub>1</sub> ⊂ <i>s</i><sub>2</sub></span> when <span class="formula"><i>s</i><sub>1</sub></span> is strictly contained in <span class="formula"><i>s</i><sub>2</sub></span>;
</div>
<div class="Labeling">
<span class="formula"><i>s</i><sub>1</sub> ⊆ <i>s</i><sub>2</sub></span> when <span class="formula"><i>s</i><sub>1</sub></span> is strictly contained in or equals <span class="formula"><i>s</i><sub>2</sub></span>;
</div>
<div class="Labeling">
<span class="formula"><i>s</i><sub>1</sub> = <i>s</i><sub>2</sub></span> when <span class="formula"><i>s</i><sub>1</sub></span> equals <span class="formula"><i>s</i><sub>2</sub></span>.
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="fig:query1"> </a><div class="multifigure">
<span class="tiny">&ldquo;Yesterday I <b>watched ’Annie Hall’</b>. It is about the relationship between a TV writer and his girlfriend, who wants to become an actress. I really <b>loved this movie</b>. Although the <b>acting wasn’t very good </b>sometimes, the <b>dialogues were smart</b>. I’d recommend it to anyone.&rdquo;</span>span class="align-center"<span class="float">
<a class="Label" name="fig:high-level"> </a><div class="figure">
<span class="unknown">\tikz</span>[level distance=2cm] <span class="unknown">\node</span>[rectangle, draw, align=center] ReviewInstance <br> Aggregator child  node[rectangle, draw, align=center] ReviewPart <br> Extractor edge from parent [&lt;-] node[right=1.6cm, pos=1.5, draw=none, font=<span class="unknown">\tiny</span>, align=left] "watched ’Annie Hall’" <br> "loved this movie" <br> "acting wasn’t very good" <br> "dialogues were smart" edge from parent [&lt;-] node[right=1.6cm, pos=-0.7, draw=none, font=<span class="unknown">\tiny</span>, align=left] "<b>watched ’Annie Hall’</b>. <br> It is about.. <b>loved this</b> <br> <b>movie</b>. Altough the <b>acting</b> <br> <b>wasn’t very good</b>.. <br> <b>dialogues were smart</b>" ;<div class="caption">
(a) High-level structure.
</div>

</div>

</span>
<span class="float">
<a class="Label" name="fig:tree"> </a><div class="figure">
<span class="unknown">\tikz</span> [level distance=1.6cm, level 3/.style=sibling distance=6em, level 4/.style=sibling distance=2em] <span class="unknown">\node</span> <span class="formula"><i>Ω</i><sub><i>c</i></sub></span> child  node <span class="formula"><i>β</i></span> child  node <span class="formula">∪</span> child  node <span class="formula">⋈<sub>≼<sub>10</sub></sub></span> child  node <span class="formula"><i>ε</i><sub><i>d</i></sub></span> edge from parent [&lt;-] node[left,draw=none, font=<span class="unknown">\tiny</span>] Action  child  node <span class="formula"><i>ε</i><sub><i>re</i></sub></span> edge from parent [&lt;-] node[right,draw=none, font=<span class="unknown">\tiny</span>] Title  edge from parent [&lt;-] node[left, draw=none, font=<span class="unknown">\tiny</span>] ReviewPart  child  node <span class="formula">⋈<sub>≼<sub>30</sub></sub></span> child  node <span class="formula"><i>ε</i><sub><i>d</i></sub></span> edge from parent [&lt;-] node[left,draw=none, font=<span class="unknown">\tiny</span>] Aspect  child  node <span class="formula"><i>ε</i><sub><i>d</i></sub></span> edge from parent [&lt;-] node[right,draw=none, font=<span class="unknown">\tiny</span>] Attribute  edge from parent [&lt;-] node[right, draw=none, font=<span class="unknown">\tiny</span>] ReviewPart  child  node . . . . edge from parent[draw=none] child  node <span class="formula">⋈<sub>≼<sub>30</sub></sub></span> child  node <span class="formula"><i>ε</i><sub><i>d</i></sub></span> edge from parent [&lt;-] node[left,draw=none, font=<span class="unknown">\tiny</span>] Sentiment  child  node <span class="formula"><i>ε</i><sub><i>d</i></sub></span> edge from parent [&lt;-] node[right,draw=none, font=<span class="unknown">\tiny</span>] MovieKeyword  edge from parent [&lt;-] node[right, draw=none, font=<span class="unknown">\tiny</span>] ReviewPart  edge from parent [&lt;-] node[left, draw=none, font=<span class="unknown">\tiny</span>] ReviewPart  edge from parent [&lt;-] node[left, draw=none, font=<span class="unknown">\tiny</span>] ReviewInstance ;<div class="caption">
(b) Operator tree.
</div>

</div>

</span>
<div class="caption">
Figure 3.1  Extraction of informal movie reviews.
</div>

</div>

</div>

</div>
<div class="Indented">
<div class="defskip"> </div>
</div>
<div class="Example">
Consider the task of extracting informal movie reviews from blog posts. A possible annotator to perform the task is shown in Figure <a class="Reference" href="#fig:query1">3.1↑</a>. Figure <a class="Reference" href="#fig:high-level">a↑</a> shows the high-level structure of the annotator. There are two main components: the <b>ReviewPart</b> module, which extracts the text snippets that are identified as parts of a movie review, and the <b>ReviewInstance</b> module that aggregates adjacent snippets into single blocks of text. Figure <a class="Reference" href="#fig:tree">b↑</a>shows the operator tree of the annotator. Review parts are extracted by a series of join operators that combine elements of basic relations, extracted by running span extractors on the text. Subsequently, the block operator aggregates the parts, and review instances that are contained into others are discarded.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.1.5">3.1.5</a> Optimization Techniques
</h3>
<div class="Unindented">
As I mentioned in the introduction of this Chapter, SystemT can make use of the optimization techniques from traditional database systems, but there exist some peculiar aspects of SystemT and span extraction tasks that enable new optimization methods.
</div>
<div class="Remark">
<a class="Label" name="first-rem"> </a>The effect of document-at-a-time processing is that the span relations produced and consumed for a single document by operators are very small in size and often empty.<a class="Label" name="small-relations"> </a>
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Remark">
Evaluating an annotator on a large set of documents is a <i>CPU-intensive process</i>. This is because the running time is by far dominated by the execution of the operators <span class="formula"><i>ε</i><sub><i>re</i></sub></span> and <span class="formula"><i>ε</i><sub><i>d</i></sub></span>, that are applied to each document in an input set.
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Remark">
<a class="Label" name="last-rem"> </a>Spans are nothing but <i>intervals</i>, so we can exploit <i>interval algebra</i>.<a class="Label" name="interval-algebra"> </a>
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Indented">
With Remark <a class="Reference" href="#small-relations">3.1.5↑</a> and Remark <a class="Reference" href="#interval-algebra">3.1.5↑</a> in mind, running time can be reduced in a number of ways. Let us look at them briefly.
</div>
<div class="Description">
<span class="Description-entry">Regular Expression Strength Reduction</span> Some classes of regular expressions, as defined in the POSIX standard, can be executed by using <i>specialized engines, </i>that are able to improve performance. For example, an expression that looks for a finite number of strings in a text is evaluated more efficiently by a string-matching engine.
</div>
<div class="Description">
<span class="Description-entry">Shared Dictionary Matching (SDM)</span> Dictionary lookups are usually very expensive, as we need to consult the dictionary thousand of times in a typical setting. Instead of evaluating each <span class="formula"><i>ε</i><sub><i>d</i></sub></span> operator in an extraction task independently for each input document, it is evaluated once and for all at the beginning of the process, and the obtained matches are shared among the single documents.
</div>
<div class="Description">
<span class="Description-entry">Conditional Evaluation (CE)</span> As we know, an annotator is evaluated indipendently on each input document. Thus, by employing some heuristic, it can be guessed if a (sub)query will give any matches in a document without loss of generality, and in case it does not, it is not evaluated on it.
</div>
<div class="Description">
<span class="Description-entry">Restricted Span Extraction (RSE)</span> It consists in executing expensive operations on selected regions of a document. It is used for <i>join</i> operators involving dictionary a matching operator in their arguments. One input operator is evaluated on the whole document, while the others are modified to consider only some neighborhood of the results from the first one. These neighborhoods are established by some ad hoc heuristic.
</div>
<div class="Unindented">
The techniques described allow the use of a <i>cost-based plan optimizer</i>: in a query plan, the subgraphs suitable for optimization are identified, and all the possible optimized plans for them are formulated. In the end, the best ones are retained. Results of sample experiments on a large dataset are decribed in <span class="bibcites">[<a class="bibliocite" name="cite-4" href="#biblio-4"><span class="bib-index">4</span></a>, <a class="bibliocite" name="cite-7" href="#biblio-7"><span class="bib-index">7</span></a>]</span>.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.2">3.2</a> AQL
</h2>
<div class="Unindented">
AQL is the concrete language used by SystemT to express annotators, designed to support the execution model described in Subsection <a class="Reference" href="#subsec:Execution-Model">3.1.3↑</a>. It is a <i>declarative language</i> with a syntax very similar to that of SQL. It supports all the operators presented in Subsection <a class="Reference" href="#subsec:Algebra-of-Operators">3.1.4↑</a>. When coding an extraction task in AQL, we can build a series of views of a document, of progressively higher abstraction level. Higher-level views are tipically based on lower-level views. The content of a view corresponds with annotations in the text. An input document is modeled as a view too, which is provided by default. The main advantages of AQL are:
</div>
<ul>
<li>
it allows formulating complex low-level patterns in a declarative fashion;
</li>
<li>
it enables <i>modularization </i>and <i>reuse</i> of the queries, making development and maintance of complex high-level structures easier.
</li>

</ul>
<div class="Unindented">
<div class="float">
<a class="Label" name="fig:AQL"> </a><div class="figure">
span class="align-center"<span class="unknown">\tikz</span>[level distance=2cm] <span class="unknown">\node</span>[rectangle, draw, align=left] —<span class="unknown">\emph</span>Define a dictionary of actions <br> <b>create</b> dictionary Action as (’saw’, ’watched’, .. ); <br> <br> —<span class="unknown">\emph</span>Use a regular expression to find movie titles <br> <b>create view</b> Title <b>as</b> <br> <b>extract</b> regex /["’][A-Z]<span class="formula">\</span>w+(s+<span class="formula">\</span>w+){0,3}["’]/ <br>    <b>on</b> D.text <br>    <b>as</b> title <br> <b>from</b> Document D; <br> <br> —<span class="unknown">\emph</span>A single ReviewPart rule. It looks for instances <br> —<span class="unknown">\emph</span>of Action followed within 10 characters by a title <br> <b>create view</b> ReviewPart <b>as</b> <br> <b>select</b> CombineSpans(A.act, T.title) <b>as</b> part <br> <b>from</b> <br>    (<b>extract</b> dictionary ’Action’ <b>on</b> D.text <b>as</b> act <br>     <b>from</b> Document D) A, Title T <br> <b>where</b> <br>    Follows(A.act, T.title, 0, 10) <br> <b>consolidate on</b> CombineSpans(A.act, T.title);;<div class="caption">
Figure 3.2 Parts of the annotator from Figure <a class="Reference" href="#fig:query1">3.1↑</a> expressed in AQL.
</div>

</div>

</div>

</div>
<div class="Example">
The AQL code in Figure <a class="Reference" href="#fig:AQL">3.2↑</a> realizes the first join from the left in Figure <a class="Reference" href="#fig:tree">b↑</a>.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.3">3.3</a> A Formalism for AQL’s Core: Variable Stack Automata and Variable Set Automata
</h2>
<div class="Unindented">
In <span class="bibcites">[<a class="bibliocite" name="cite-5" href="#biblio-5"><span class="bib-index">5</span></a>]</span>, a formal model capturing the core functionality of AQL is described. The authors show a way to represent annotators expressed in AQL by means of modified finite state automata, namely <i>variable stack automata</i> and <i>variable set automata</i>. I now resume the formal model, and look at the relative expressive power of its main elements.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.3.1">3.3.1</a> Basic Definitions
</h3>
<div class="Unindented">
I consider <span class="formula"><i>Σ</i></span> and <span class="formula"><i>Σ</i><sup>∗</sup></span>, defined as in Subsection <a class="Reference" href="#subsec:Data-Model">3.1.2↑</a>. Let us start with the definition of a language.
</div>
<div class="Definition">
A language L is a subset of <span class="formula"><i>Σ</i><sup>∗</sup></span>.
</div>
<div class="Unindented">
An important concept is that of regular expressions, which can be defined by describing their language.
</div>
<div class="Definition">
Regular expressions over <span class="formula"><i>Σ</i></span> are the strings that belong to the language <span class="formula"><i>γ</i></span> defined as:<div class="formula">
<a class="eqnumber" name="eq-3.1">(3.1) </a><i>γ</i>: = <span class="textrm">Ø</span>∣<i>ϵ</i>∣<i>σ</i>∣<i>γ</i>∨<i>γ</i>∣<i>γ</i>⋅<i>γ</i>∣<i>γ</i><sup>∗</sup>
</div>

</div>
<div class="Definition">
where:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>Ø</i></span> is the empty language;
</li>
<li>
<span class="formula"><i>ϵ</i></span> is the empty string;
</li>
<li>
<span class="formula"><i>σ</i> ∈ <i>Σ</i></span>;
</li>
<li>
<span class="formula">∨</span> is the ordinary disjunction operator;
</li>
<li>
<span class="formula">⋅</span> is the concatenation operator;
</li>
<li>
<span class="formula">∗</span> is the Kleene Star operator.
</li>

</ul>

</li>

</ul>
<div class="Unindented">
Additionally, we might use <span class="formula"><i>γ</i><sup> + </sup></span> as a shortcut for <span class="formula"><i>γ</i>⋅<i>γ</i><sup>∗</sup></span>, and <span class="formula"><i>Σ</i></span> as an abbreviation of <span class="formula"><i>σ</i><sub>1</sub>∨...∨<i>σ</i><sub><i>n</i></sub></span> (with a slight abuse of notation). The language <span class="formula">ℒ<span class="symbol">(</span><i>γ</i><span class="symbol">)</span></span> of a regular expression <span class="formula"><i>γ</i></span> is the set of strings <span class="formula"><b>s</b></span> over <span class="formula"><i>Σ</i></span> that are matched by that expression. A language <span class="formula"><i>L</i></span> is <i>regular</i> if <span class="formula"><i>L</i> = ℒ<span class="symbol">(</span><i>γ</i><span class="symbol">)</span></span> for some regular expression <span class="formula"><i>γ</i></span>. We also need the definition of a <i>string relation</i>.
</div>
<div class="Definition">
A n-ary string relation is a subset of <span class="formula"><span class="symbol">(</span><i>Σ</i><sup>∗</sup><span class="symbol">)</span><sup><i>n</i></sup></span>.
</div>
<div class="Unindented">
An interesting class of string relations is that of recognizable relations, denoted as <span class="formula"><span class="textrm">REC</span></span>.
</div>
<div class="Definition">
Given a k-ary string relation <span class="formula"><i>R</i></span>, <span class="formula"><i>R</i></span> is recognizable if it is representable by a finite union the form:<div class="formula">
<a class="eqnumber" name="eq-3.2">(3.2) </a>∪<i>L</i><sub>1</sub> × ... × <i>L</i><sub><i>k</i></sub>
</div>

</div>
<div class="Definition">
where each <span class="formula"><i>L</i></span><span class="formula"><sub><i>i</i></sub></span> is a regular language.
</div>
<div class="Unindented">
I have already mentioned span relations (Definition <a class="Reference" href="#span-relation">3.1.2↑</a>). They allow giving a precise definition of annotators, by introducing the concept of <i>document spanner</i>.
</div>
<div class="Definition">
Given a string <span class="formula"><b>s</b></span>, a document spanner P is a function that maps <span class="formula"><b>s</b></span> to a <span class="formula"><span class="symbol">(</span><i>V</i>, <i>s</i><span class="symbol">)</span> − <span class="textrm">relation</span></span> <span class="formula"><i>r</i></span> , where <span class="formula"><i>V</i>: = <span class="textrm">Svars</span><span class="symbol">(</span><i>P</i><span class="symbol">)</span></span>. We have <span class="formula"><i>r</i> = <i>P</i><span class="symbol">(</span><b>s</b><span class="symbol">)</span>.</span> We say <span class="formula"><i>P</i></span> is n-ary if <span class="formula"><span class="symbol">|</span><i>V</i><span class="symbol">|</span> = <i>n</i></span>.
</div>
<div class="Definition">
<div class="float">
<a class="Label" name="fig:running-ex"> </a><div class="figure">
span class="align-center"<b>String s</b><span class="noindent"><span class="unknown">\resizebox</span></span><span class="unknown">\textwidth</span>!<table>
<tr>
<td align="center" valign="top">
<b>I</b>
</td>
<td align="center" valign="top">
<b>_</b>
</td>
<td align="center" valign="top">
<b>w</b>
</td>
<td align="center" valign="top">
<b>a</b>
</td>
<td align="center" valign="top">
<b>t</b>
</td>
<td align="center" valign="top">
<b>c</b>
</td>
<td align="center" valign="top">
<b>h</b>
</td>
<td align="center" valign="top">
<b>e</b>
</td>
<td align="center" valign="top">
<b>d</b>
</td>
<td align="center" valign="top">
<b>_</b>
</td>
<td align="center" valign="top">
<b>&ldquo;</b>
</td>
<td align="center" valign="top">
<b>T</b>
</td>
<td align="center" valign="top">
<b>h</b>
</td>
<td align="center" valign="top">
<b>e</b>
</td>
<td align="center" valign="top">
<b>_</b>
</td>
<td align="center" valign="top">
<b>M</b>
</td>
<td align="center" valign="top">
<b>a</b>
</td>
<td align="center" valign="top">
<b>t</b>
</td>
<td align="center" valign="top">
<b>r</b>
</td>
<td align="center" valign="top">
<b>i</b>
</td>
<td align="center" valign="top">
<b>x</b>
</td>
<td align="center" valign="top">
<b>&ldquo;</b>
</td>
<td align="center" valign="top">
<b>_</b>
</td>
<td align="center" valign="top">
<b>t</b>
</td>
<td align="center" valign="top">
<b>h</b>
</td>
<td align="center" valign="top">
<b>e</b>
</td>
<td align="center" valign="top">
<b>n</b>
</td>
<td align="center" valign="top">
<b>_</b>
</td>
<td align="center" valign="top">
<b>w</b>
</td>
<td align="center" valign="top">
<b>e</b>
</td>
<td align="center" valign="top">
<b>_</b>
</td>
<td align="center" valign="top">
<b>s</b>
</td>
<td align="center" valign="top">
<b>a</b>
</td>
<td align="center" valign="top">
<b>w</b>
</td>
<td align="center" valign="top">
<b>_</b>
</td>
<td align="center" valign="top">
<b>&ldquo;</b>
</td>
<td align="center" valign="top">
<b>A</b>
</td>
<td align="center" valign="top">
<b>n</b>
</td>
<td align="center" valign="top">
<b>n</b>
</td>
<td align="center" valign="top">
<b>i</b>
</td>
<td align="center" valign="top">
<b>e</b>
</td>
<td align="center" valign="top">
<b>_</b>
</td>
<td align="center" valign="top">
<b>H</b>
</td>
<td align="center" valign="top">
<b>a</b>
</td>
<td align="center" valign="top">
<b>l</b>
</td>
<td align="center" valign="top">
<b>l</b>
</td>
<td align="center" valign="top">
<b>&ldquo;</b>
</td>

</tr>
<tr>
<td align="center" valign="top">
1
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
3
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
5
</td>
<td align="center" valign="top">
6
</td>
<td align="center" valign="top">
7
</td>
<td align="center" valign="top">
8
</td>
<td align="center" valign="top">
9
</td>
<td align="center" valign="top">
10
</td>
<td align="center" valign="top">
11
</td>
<td align="center" valign="top">
12
</td>
<td align="center" valign="top">
13
</td>
<td align="center" valign="top">
14
</td>
<td align="center" valign="top">
15
</td>
<td align="center" valign="top">
16
</td>
<td align="center" valign="top">
17
</td>
<td align="center" valign="top">
18
</td>
<td align="center" valign="top">
19
</td>
<td align="center" valign="top">
20
</td>
<td align="center" valign="top">
21
</td>
<td align="center" valign="top">
22
</td>
<td align="center" valign="top">
23
</td>
<td align="center" valign="top">
24
</td>
<td align="center" valign="top">
25
</td>
<td align="center" valign="top">
26
</td>
<td align="center" valign="top">
27
</td>
<td align="center" valign="top">
28
</td>
<td align="center" valign="top">
29
</td>
<td align="center" valign="top">
30
</td>
<td align="center" valign="top">
31
</td>
<td align="center" valign="top">
32
</td>
<td align="center" valign="top">
33
</td>
<td align="center" valign="top">
34
</td>
<td align="center" valign="top">
35
</td>
<td align="center" valign="top">
36
</td>
<td align="center" valign="top">
37
</td>
<td align="center" valign="top">
38
</td>
<td align="center" valign="top">
39
</td>
<td align="center" valign="top">
40
</td>
<td align="center" valign="top">
41
</td>
<td align="center" valign="top">
42
</td>
<td align="center" valign="top">
43
</td>
<td align="center" valign="top">
44
</td>
<td align="center" valign="top">
45
</td>
<td align="center" valign="top">
46
</td>
<td align="center" valign="top">
47
</td>

</tr>

</table>
<div class="defskip"> </div><span class="formula"><i>P</i><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span><table>
<tr>
<td align="center" valign="top">

</td>
<td align="center" valign="top">
<span class="small"><span class="formula"><i>x</i></span></span>
</td>
<td align="center" valign="top">
<span class="small"><span class="formula"><i>y</i></span></span>
</td>
<td align="center" valign="top">
<span class="small"><span class="formula"><i>z</i></span></span>
</td>

</tr>
<tr>
<td align="center" valign="top">
<span class="small"><span class="formula"><i>μ</i><sub>1</sub></span></span>
</td>
<td align="center" valign="top">
<span class="small"><span class="formula"><span class="symbol">[</span>3, 10<span class="symbol">⟩</span></span></span>
</td>
<td align="center" valign="top">
<span class="small"><span class="formula"><span class="symbol">[</span>11, 23<span class="symbol">⟩</span></span></span>
</td>
<td align="center" valign="top">
<span class="small"><span class="formula"><span class="symbol">[</span>3, 23<span class="symbol">⟩</span></span></span>
</td>

</tr>
<tr>
<td align="center" valign="top">
<span class="small"><span class="formula"><i>μ</i><sub>2</sub></span></span>
</td>
<td align="center" valign="top">
<span class="small"><span class="formula"><span class="symbol">[</span>32, 35<span class="symbol">⟩</span></span></span>
</td>
<td align="center" valign="top">
<span class="small"><span class="formula"><span class="symbol">[</span>36, 48<span class="symbol">⟩</span></span></span>
</td>
<td align="center" valign="top">
<span class="small"><span class="formula"><span class="symbol">[</span>33, 48<span class="symbol">⟩</span></span></span>
</td>

</tr>
<tr>
<td align="center" valign="top">
<span class="small"><span class="formula"><i>μ</i><sub>3</sub></span></span>
</td>
<td align="center" valign="top">
<span class="small"><span class="formula"><span class="symbol">[</span>3, 10<span class="symbol">⟩</span></span></span>
</td>
<td align="center" valign="top">
<span class="small"><span class="formula"><span class="symbol">[</span>36, 48<span class="symbol">⟩</span></span></span>
</td>
<td align="center" valign="top">
<span class="small"><span class="formula"><span class="symbol">[</span>3, 48<span class="symbol">⟩</span></span></span>
</td>

</tr>

</table>
<div class="caption">
Figure 3.3 A string <span class="formula"><b>s</b></span> and the span relation obtained by applying spanner <span class="formula"><i>P</i></span> to <span class="formula"><b>s</b></span>.
</div>

</div>

</div>

</div>
<div class="Example">
In Figure <a class="Reference" href="#fig:running-ex">3.3↑</a>, the string <span class="formula"><b>s</b></span>, on the alphabet <span class="formula">Σ = <span class="symbol">{</span><span class="textrm">A, … , Z, a, … , z, _, "</span><span class="symbol">}</span></span>, is shown. The character _ can be thought as a space. The table shown below <span class="formula"><b>s</b></span> represents the span relation <span class="formula"><i>P</i><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span>, which is the result of applying the ternary spanner <span class="formula"><i>P</i></span> to <span class="formula"><b>s</b></span>.
</div>
<div class="Unindented">
I now present two special types of spanners that will be useful later on. The first one is that of <i>Hierarchical Spanners</i>. In order to formulate their definition, we need to say when a <span class="formula"><b>s</b> − <span class="textrm">tuple</span></span> is hierarchical.
</div>
<div class="Definition">
<a class="Label" name="hierarchical-tuple"> </a>Given a string <span class="formula"><b>s</b></span>, a document spanner <span class="formula"><i>P</i></span> and an <span class="formula"><b>s</b> − <span class="textrm">tuple</span></span> <span class="formula"><i>μ</i> ∈ <i>P</i><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span>, <span class="formula"><i>μ</i></span> is hiearchical if, for every <span class="formula"><i>x</i>, <i>y</i> ∈ <span class="textrm">SVars</span><span class="symbol">(</span><i>P</i><span class="symbol">)</span></span>, one of the following conditions holds:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>μ</i><span class="symbol">(</span><i>x</i><span class="symbol">)</span> ⊇ <i>μ</i><span class="symbol">(</span><i>y</i><span class="symbol">)</span>;</span>
</li>
<li>
<span class="formula"><i>μ</i><span class="symbol">(</span><i>x</i><span class="symbol">)</span> ⊆ <i>μ</i><span class="symbol">(</span><i>y</i><span class="symbol">)</span></span>;
</li>
<li>
<span class="formula"><i>μ</i><span class="symbol">(</span><i>x</i><span class="symbol">)</span></span> is disjoint from <span class="formula"><i>μ</i><span class="symbol">(</span><i>y</i><span class="symbol">)</span></span>.
</li>

</ul>

</li>

</ul>
<div class="Unindented">
The definition of <i>hierarchical spanner</i> follows.
</div>
<div class="Definition">
<a class="Label" name="hierarchical-spanner"> </a>Given a document spanner <span class="formula"><i>P</i></span>, <span class="formula"><i>P</i></span> is hierarchical if <span class="formula">∀<b>s</b> ∈ <i>Σ</i><sup>∗</sup></span>, <span class="formula">∀<i>μ</i> ∈ <i>P</i><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span>, <span class="formula"><i>μ</i></span> is hierarchical.
</div>
<div class="Unindented">
The class of hierarchical spanners is denoted by <span class="formula"><b>HS</b></span>. The second type of spanners I introduce is that of <i>Universal Spanners</i>. Some accessory definitions are needed.
</div>
<div class="Definition">
Given a string <span class="formula"><b>s</b></span> and a document spanner <span class="formula"><i>P</i></span>, <span class="formula"><i>P</i></span> is total on <span class="formula"><b>s</b></span> if <span class="formula"><i>P</i><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span> consists of all the possible <span class="formula"><b>s</b> − <span class="textrm">tuples</span></span> on <span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><i>P</i><span class="symbol">)</span></span>.
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Definition">
Given a string <span class="formula"><b>s</b></span> and a document spanner <span class="formula"><i>P</i></span>, <span class="formula"><i>P</i></span> is hierarchically total on <span class="formula"><b>s</b></span> if <span class="formula"><i>P</i><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span> consists of all the possible hierarchical <span class="formula"><b>s</b> − <span class="textrm">tuples</span></span> on <span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><i>P</i><span class="symbol">)</span></span>.
</div>
<div class="Unindented">
There are two kinds of universal spanners: the <i>universal spanner</i> and the <i>universal hierarchical spanner</i>.
</div>
<div class="Definition">
Given a set of span variables <span class="formula"><i>Y</i></span><span class="formula"> ⊆ <span class="textrm">SVars</span></span>, the universal spanner <span class="formula">Υ<sub><i>Y</i></sub></span> over <span class="formula"><i>Y</i></span> is the unique document spanner <span class="formula"><i>P</i></span> such that <span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><i>P</i><span class="symbol">)</span> = <i>Y</i></span> and <span class="formula"><i>P</i></span> is total on every string <span class="formula"><b>s</b> ∈ <i>Σ</i><sup>∗</sup></span>. 
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Definition">
Given a set of span variables <span class="formula"><i>Y</i></span><span class="formula"> ⊆ <span class="textrm">SVars</span></span>, the universal hierarchical spanner <span class="formula">Υ<sub><i>Y</i></sub><sup><i>H</i></sup></span> over <span class="formula"><i>Y</i></span> is the unique document spanner <span class="formula"><i>P</i></span> such that <span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><i>P</i><span class="symbol">)</span> = <i>Y</i></span> and <span class="formula"><i>P</i></span> is hierarchically total on every string <span class="formula"><b>s</b> ∈ <i>Σ</i><sup>∗</sup></span>. 
</div>
<div class="Unindented">
In the following Subsection, I present the formal spanner represantations described in <span class="bibcites">[<a class="bibliocite" name="cite-5" href="#biblio-5"><span class="bib-index">5</span></a>]</span>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.3.2">3.3.2</a> Spanner Representations
</h3>
<div class="Unindented">
We saw, in Subsection <a class="Reference" href="#subsec:Algebra-of-Operators">3.1.4↑</a>, that the operations used by SystemT and AQL to extract spans relations are regular expression matching and dictionary matching. In the remainder of this paper I focus on regular expressions. AQL’s regular expressions can be seen as usual regular expressions enriched with <i>capture variables</i>, that are precisely the span variables constituting the span relations of Definition <a class="Reference" href="#span-relation">3.1.2↑</a>. In <span class="bibcites">[<a class="bibliocite" name="cite-5" href="#biblio-5"><span class="bib-index">5</span></a>]</span>, three formalisms are described, that are able to model this kind of modified regular expressions. They are:
</div>
<ul>
<li>
<i>Regex Formulas;</i>
</li>
<li>
<i>Variable Stack Automata;</i>
</li>
<li>
<i>Variable Set Automata.</i>
</li>

</ul>
<div class="Unindented">
These formalisms are also called <i>primitive spanner representations</i>.
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-6"></a>Regex Formulas
</h4>
<div class="Unindented">
In order to define a regex formula, let us introduce the concept of <i>variable regex.</i>
</div>
<div class="Definition">
A variable regex is a regular expression with capture variables that extends usual regular expressions in the following way:<div class="formula">
<a class="eqnumber" name="eq-3.3">(3.3) </a><i>γ</i>: = <span class="textrm">Ø</span>∣<i>ϵ</i>∣<i>σ</i>∣<i>γ</i>∨<i>γ</i>∣<i>γ</i>⋅<i>γ</i>∣<i>γ</i><sup>∗</sup>∣<i>x</i><span class="symbol">{</span><i>γ</i><span class="symbol">}</span>
</div>
 where:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>x</i> ∈ <span class="textrm">SVars</span></span>;
</li>
<li>
<span class="formula"><i>x</i><span class="symbol">{</span><i>γ</i><span class="symbol">}</span></span> means that we assign the result of the evaluation of <span class="formula"><i>γ</i></span> to x.
</li>

</ul>

</li>

</ul>
<div class="Unindented">
Evaluating a variable regex on a string produces a parse tree over the alphabet <span class="formula">Λ = <i>Σ</i>∪<span class="textrm">SVars</span>∪<span class="symbol">{</span> ∈ , ∨, ⋅, ∗<span class="symbol">}</span></span>. A valid parse tree for a variable regex<span class="formula"><i>γ</i></span> is called a <span class="formula"><i>γ</i> − <span class="textrm">parse</span></span>. We accept only a variable regex expression if its parses have exactly one occurence of each of the variables appearing in the expression, otherwise the variable assignment would remain unclear. Such an expression is referred to as <i>functional</i>.
</div>
<div class="Definition">
A variable regex <span class="formula"><i>γ</i></span> is functional if <span class="formula">∀<b>s</b> ∈ <i>Σ</i><sup>∗</sup></span>, <span class="formula">∀<i>γ</i> − <span class="textrm">parse </span><i>t</i></span> for <span class="formula"><b>s</b></span>, <span class="formula">∀<i>x</i> ∈ <span class="textrm">SVars</span><span class="symbol">(</span><i>γ</i><span class="symbol">)</span></span>, <span class="formula"><i>x</i></span> occurs exactly one time in <span class="formula"><i>t</i></span>.
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Definition">
A regex formula is a functional variable regex.
</div>
<div class="Unindented">
The spanner represented by a regex formula <span class="formula"><i>γ</i></span> may be denoted as <span class="formula"><span class="symbol">⟦</span><i>γ</i><span class="symbol">⟧</span></span>. We have that <span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><span class="symbol">⟦</span><i>γ</i><span class="symbol">⟧</span><span class="symbol">)</span> = <span class="textrm">SVars</span><span class="symbol">(</span><i>γ</i><span class="symbol">)</span></span>, and the span relation <span class="formula"><span class="symbol">⟦</span><i>γ</i><span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span> is the set <span class="formula"><span class="symbol">{</span><i>μ</i><sup><i>p</i></sup>∣<i>p</i><span class="textrm"> is a </span><i>γ</i> − <span class="textrm">parse for <b>s</b></span><span class="symbol">}</span></span>, where <span class="formula"><i>μ</i><sup><i>p</i></sup></span> is a tuple defined by a parse <span class="formula"><i>p</i></span>. The class of regex formulas is referred to as <span class="formula"><span class="textrm">RGX</span></span>.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="fig:parse"> </a><div class="figure">
span class="align-center"<span class="noindent"><span class="unknown">\resizebox</span></span><span class="unknown">\textwidth</span>!<span class="unknown">\tikz</span> [level distance=1.2cm] <span class="unknown">\node</span> <span class="formula">⋅</span> [sibling distance=3cm] child[level distance=1cm]  node <span class="formula">∗</span> [sibling distance=1.2cm] child  node <span class="formula">∨</span> child node[align=center] <b>I</b> <br> 1   child  node <span class="formula">∨</span> child node[align=center] <b>_</b> <br> 2    child[level distance=2cm]  node <span class="formula"><i>z</i></span> child  node <span class="formula">⋅</span> [sibling distance=3.8cm] child node <span class="formula"><i>x</i></span> [level distance = 1cm] child  node <span class="formula">⋅</span> [sibling distance=1.2cm, level distance = 2cm] child node <span class="formula">∨</span> [level distance = 1cm] child node[align=center] <b>w</b> <br> 3   child  node[align=center] <b>a</b> <br> 4 child  node[align=center] <b>t</b> <br> 5 child  node[align=center] <b>c</b> <br> 6 child  node[align=center] <b>h</b> <br> 7 child  node[align=center] <b>e</b> <br> 8 child  node[align=center] <b>d</b> <br> 9   child[level distance=1cm] node <span class="formula"> + </span> [level distance=1cm] child  node <span class="formula">∨</span> child  node[align=center] <b>_</b> <br> 10   child node <span class="formula"><i>y</i></span> child node <span class="formula">⋅</span> child[sibling distance =1.3cm, level distance=1cm]  node <span class="formula">∨</span> child  node[align=center] <b>"</b> <br> 11  child[level distance=1.2cm, sibling distance=1.2cm] node <span class="formula">⋅</span> child  node <span class="formula">∨</span> [level distance=1cm] child  node[align=center] <b>T</b> <br> 12  child  node <span class="formula">∗</span> [sibling distance=1cm, level distance=1cm] child  node <span class="formula">∨</span> child  node[align=center] <b>h</b> <br> 13  child  node <span class="formula">∨</span> child  node[align=center] <b>e</b> <br> 14    child[sibling distance =3.8cm]  node <span class="formula">∗</span> child node <span class="formula">⋅</span> [sibling distance=1.2cm, level distance=1.2cm] child  node[align=center] <b>_</b> <br> 15  child  node <span class="formula">⋅</span> [sibling distance=1.2cm] child  node <span class="formula">∨</span> child  node[align=center] <b>M</b> <br> 16  child[level distance=2.5cm, sibling distance=2.2cm]  node<span class="formula">∗</span> [level distance=1cm, sibling distance=1cm] child  node <span class="formula">∨</span> child  node[align=center] <b>a</b> <br> 17  child  node <span class="formula">∨</span> child  node[align=center] <b>t</b> <br> 18  child  node <span class="formula">∨</span> child  node[align=center] <b>r</b> <br> 19  child  node <span class="formula">∨</span> child  node[align=center] <b>i</b> <br> 20  child  node <span class="formula">∨</span> child  node[align=center] <b>x</b> <br> 21      child[sibling distance=2cm]  node <span class="formula">∨</span> [level distance =1cm] child  node[align=center] <b>"</b> <br> 22      child[level distance=1cm]  node <span class="formula">∗</span> [sibling distance=1.2cm] child  node <span class="formula">∨</span> child  node[align=center] <b>_</b> <br> 23  child  node <span class="formula">∨</span> child  node[align=center] . . .  child  node <span class="formula">∨</span> child  node[align=center] " <br> 47  ;<div class="caption">
Figure 3.4  A <span class="formula"><i>γ</i></span>-parse <span class="formula"><i>p</i></span> for string <span class="formula"><b>s</b></span> (see Figure <a class="Reference" href="#fig:running-ex">3.3↑</a>).
</div>

</div>

</div>

</div>
<div class="Example">
<a class="Label" name="ex-rgx"> </a>Consider the variable regex <span class="formula"><i>γ</i></span> defined by:
</div>
<div class="Example">
<div class="formula">
<a class="eqnumber" name="eq:rgx">(3.4) </a>Σ<sup>∗</sup>⋅<i>z</i><span class="symbol">{</span><i>x</i><span class="symbol">{</span><i>γ</i><sub><span class="textrm">action</span></sub><span class="symbol">}</span>⋅Σ<sup> + </sup>⋅<i>y</i><span class="symbol">{</span><i>γ</i><sub><span class="textrm">title</span></sub><span class="symbol">}</span><span class="symbol">}</span>⋅Σ<sup>∗</sup>
</div>

</div>
<div class="Example">
where <span class="formula"><i>γ</i><sub><span class="textrm">action</span></sub> = <span class="symbol">(</span><span class="textrm">w</span>⋅<span class="textrm">a</span>⋅<span class="textrm">t</span>⋅<span class="textrm">c</span>⋅<span class="textrm">h</span>⋅<span class="textrm">e</span>⋅<span class="textrm">d</span><span class="symbol">)</span>∨<span class="symbol">(</span><span class="textrm">s</span>⋅<span class="textrm">a</span>⋅<span class="textrm">w</span><span class="symbol">)</span></span> and <span class="formula"><i>γ</i><sub><i>title</i></sub> = <span class="textrm">"</span>⋅<span class="symbol">(</span><span class="textrm">A</span>∨…∨<span class="textrm">Z</span><span class="symbol">)</span>⋅<span class="symbol">(</span><span class="textrm">a</span>∨…∨<span class="textrm">z</span><span class="symbol">)</span><sup>∗</sup>⋅<span class="symbol">(</span>_⋅<span class="symbol">(</span><span class="textrm">A</span>∨…∨<span class="textrm">Z</span><span class="symbol">)</span>⋅<span class="symbol">(</span><span class="textrm">a</span>∨…∨<span class="textrm">z</span><span class="symbol">)</span><sup>∗</sup><span class="symbol">)</span><sup>∗</sup>⋅<span class="textrm">"</span></span>. Notice that <span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><i>γ</i><span class="symbol">)</span> = <span class="symbol">{</span><i>x</i>, <i>y</i>, <i>z</i><span class="symbol">}</span></span>. Figure <a class="Reference" href="#fig:parse">3.4↑</a> shows a <span class="formula"><i>γ</i></span>-parse <span class="formula"><i>p</i></span> for string <span class="formula"><b>s</b></span> of Figure <a class="Reference" href="#fig:running-ex">3.3↑</a>. In this parse, each variable contained in <span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><i>γ</i><span class="symbol">)</span></span> occurs exactly once. It is easy to verify that this holds for every <span class="formula"><i>γ</i></span>-parse. Hence, <span class="formula"><i>γ</i></span> is functional. We have that <span class="formula"><i>μ</i><sup><i>p</i></sup><span class="symbol">(</span><i>x</i><span class="symbol">)</span> = <span class="symbol">[</span>3, 10<span class="symbol">⟩</span></span>, <span class="formula"><i>μ</i><sup><i>p</i></sup><span class="symbol">(</span><i>y</i><span class="symbol">)</span> = <span class="symbol">[</span>11, 23<span class="symbol">⟩</span></span> and <span class="formula"><i>μ</i><sup><i>p</i></sup><span class="symbol">(</span><i>z</i><span class="symbol">)</span> = <span class="symbol">[</span>3, 23<span class="symbol">⟩</span></span>, thus <span class="formula"><i>μ</i><sup><i>p</i></sup></span> is the <span class="formula"><b>s</b></span>-tuple <span class="formula"><i>μ</i><sub>1</sub></span> from Figure <a class="Reference" href="#fig:running-ex">3.3↑</a>. Finally, considering the span relation <span class="formula"><i>P</i><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span> (Figure <a class="Reference" href="#fig:running-ex">3.3↑</a>), we have that <span class="formula"><span class="symbol">⟦</span><i>γ</i><span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span> = <i>P</i><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span>.
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-7"></a>Variable Stack Automata
</h4>
<div class="Unindented">
Variable stack automata (vstk-automata for short) are representations of document spanners by means of modified finite state automata (FSAs). Basically, a FSA is augmented with a <i>stack of span variables</i>. A variable is pushed on the stack when its corresponding span is opened, and popped when it is closed. The formal definition of a vstk-automaton follows.
</div>
<div class="Definition">
<a class="Label" name="vstk-aut"> </a>A Variable Stack Automaton is a tuple <span class="formula"><span class="symbol">(</span><i>Q</i>, <i>q</i><sub>0</sub>, <i>q</i><sub><i>f</i></sub>, <i>δ</i><span class="symbol">)</span></span>, where:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>Q</i></span> is a finite set of states;
</li>
<li>
<span class="formula"><i>q</i><sub>0</sub> ∈ <i>Q</i></span> is the initial state;
</li>
<li>
<span class="formula"><i>q</i><sub><i>f</i></sub> ∈ <i>Q</i></span> is the accepting state;
</li>
<li>
<span class="formula"><i>δ</i></span> is a finite transition relation, containing triples of the forms <span class="formula"><span class="symbol">(</span><i>q</i>, <i>σ</i>, <i>q</i>’<span class="symbol">)</span></span>, <span class="formula"><span class="symbol">(</span><i>q</i>, <i>ϵ</i>, <i>q</i>’<span class="symbol">)</span></span>, <span class="formula"><span class="symbol">(</span><i>q</i>, <i>x</i>⊢, <i>q</i>’<span class="symbol">)</span></span>, <span class="formula"><span class="symbol">(</span><i>q</i>, ⊣, <i>q</i>’<span class="symbol">)</span></span>, where:\begin_inset Separator latexpar\end_inset<ul>
<li>
<span class="formula"><i>q</i>, <i>q</i>’ ∈ <i>Q</i></span>;
</li>
<li>
<span class="formula"><i>σ</i> ∈ <i>Σ</i></span>;
</li>
<li>
<span class="formula"><i>x</i> ∈ <i>SVars</i></span>;
</li>
<li>
<span class="formula">⊢</span> is the push symbol;
</li>
<li>
<span class="formula">⊣</span> is the pop symbol.
</li>

</ul>

</li>

</ul>

</li>

</ul>
<div class="Unindented">
Notice that we don’t need to specify which variable we want to pop, as it is naturally the last that was pushed onto the stack. Given a vstk-automaton <span class="formula"><i>A</i></span>, the set of variables that appear in its transitions is denoted as <span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span>. 
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="fig:vstk"> </a><div class="figure">
span class="align-center"<span class="noindent"><span class="unknown">\resizebox</span></span><span class="unknown">\textwidth</span>!<span class="align-center"><span class="environment"><span class="arrayrow">
<span class="arraycell align-l">
[shorten
</span>
<span class="arraycell align-l">
gt; = 1pt, nodedistance = 3cm, ongrid, auto]<span class="unknown">\node</span>[state, initial](q<sub>0</sub>);<span class="unknown">\node</span>[state](q<sub>1</sub>)[right = ofq<sub>0</sub>];<span class="unknown">\node</span>[state](q<sub>2</sub>)[right = ofq<sub>1</sub>];<span class="unknown">\node</span>[state](q<sub>3</sub>)[aboveright = ofq<sub>2</sub>];<span class="unknown">\node</span>[state](q<sub>4</sub>)[right = ofq<sub>3</sub>];<span class="unknown">\node</span>[state](q<sub>5</sub>)[right = ofq<sub>4</sub>];<span class="unknown">\node</span>[state](q<sub>6</sub>)[right = ofq<sub>5</sub>];<span class="unknown">\node</span>[state](q<sub>7</sub>)[right = ofq<sub>6</sub>];<span class="unknown">\node</span>[state](q<sub>8</sub>)[right = ofq<sub>7</sub>];<span class="unknown">\node</span>[state](q<sub>9</sub>)[right = ofq<sub>2</sub>, xshift = 3.5cm];<span class="unknown">\node</span>[state](q<sub>10</sub>)[right = ofq<sub>9</sub>, xshift = 3.5cm];<span class="unknown">\node</span>[state](q<sub>11</sub>)[belowright = ofq<sub>8</sub>];<span class="unknown">\node</span>[state](q<sub>12</sub>)[below = ofq<sub>11</sub>];<span class="unknown">\node</span>[state](q<sub>13</sub>)[left = ofq<sub>12</sub>];<span class="unknown">\node</span>[state](q<sub>14</sub>)[left = ofq<sub>13</sub>];<span class="unknown">\node</span>[state](q<sub>15</sub>)[left = ofq<sub>14</sub>];<span class="unknown">\node</span>[state](q<sub>16</sub>)[left = ofq<sub>15</sub>];<span class="unknown">\node</span>[state](q<sub>17</sub>)[aboveleft = ofq<sub>16</sub>, xshift = 4cm];<span class="unknown">\node</span>[state](q<sub>18</sub>)[left = ofq<sub>17</sub>, xshift =  − 0.8cm];<span class="unknown">\node</span>[state](q<sub>19</sub>)[left = ofq<sub>16</sub>];<span class="unknown">\node</span>[state, accepting](q<sub>20</sub>)[left = ofq<sub>19</sub>];<span class="unknown">\path</span>[ − 
</span>
<span class="arraycell align-l">
gt;](q<sub>0</sub>)edgenodez⊢(q<sub>1</sub>)edge[loopabove]nodeΣ()(q<sub>1</sub>)edgenodex⊢(q<sub>2</sub>)(q<sub>2</sub>)edgenodew(q<sub>3</sub>)(q<sub>2</sub>)edgenodes(q<sub>9</sub>)(q<sub>3</sub>)edgenodea(q<sub>4</sub>)(q<sub>4</sub>)edgenodet(q<sub>5</sub>)(q<sub>5</sub>)edgenodec(q<sub>6</sub>)(q<sub>6</sub>)edgenodeh(q<sub>7</sub>)(q<sub>7</sub>)edgenodee(q<sub>8</sub>)(q<sub>8</sub>)edgenoded(q<sub>11</sub>)(q<sub>9</sub>)edgenodea(q<sub>10</sub>)(q<sub>10</sub>)edgenodew(q<sub>11</sub>)(q<sub>11</sub>)edgenode⊣(q<sub>12</sub>)(q<sub>12</sub>)edgenodeΣ(q<sub>13</sub>)(q<sub>13</sub>)edgenodey⊢(q<sub>14</sub>)edge[loopabove]nodeΣ()(q<sub>14</sub>)edgenode"(q<sub>15</sub>)(q<sub>15</sub>)edgenodeA, ..., Z(q<sub>16</sub>)(q<sub>16</sub>)edgenode_(q<sub>17</sub>)(q<sub>17</sub>)edgenodeA, ..., Z(q<sub>18</sub>)(q<sub>16</sub>)edgenode"(q<sub>19</sub>)(q<sub>18</sub>)edge[loopbelow]nodea, .., z()edgenodeϵ(q<sub>16</sub>)(q<sub>19</sub>)edgenodeϵ(q<sub>20</sub>)edge[loopabove]node⊣()(q<sub>20</sub>)edge[loopabove]nodeΣ();
</span>

</span>
</span></span><div class="caption">
Figure 3.5 A vstk-automaton <span class="formula"><i>A</i></span> with <span class="formula"><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span> = <span class="symbol">⟦</span><i>γ</i><span class="symbol">⟧</span></span>, where <span class="formula"><i>γ</i></span> is the regex formula of <a class="Reference" href="#eq:rgx">3.4↑</a> (see Example <a class="Reference" href="#ex-rgx">6↑</a>).
</div>

</div>

</div>

</div>
<div class="Example">
Figure <a class="Reference" href="#fig:vstk">3.5↑</a> shows a vstk-Automaton <span class="formula"><i>A</i></span>. Each circle represents a state. The double circle is the accepting state. A label <span class="formula"><i>a</i></span> on an edge from state <span class="formula"><i>q</i></span> to state <span class="formula"><i>q</i><sup>’</sup></span> represents the transition <span class="formula"><span class="symbol">(</span><i>q</i>, <i>a</i>, <i>q</i><sup>’</sup><span class="symbol">)</span></span>. A sequence <span class="formula"><i>σ</i><sub>1</sub>, …, <i>σ</i><sub><i>k</i></sub></span> on an edge from <span class="formula"><i>q</i></span> to <span class="formula"><i>q</i><sup>’</sup></span> is a shorthand for the <span class="formula"><i>k</i></span> transitions <span class="formula"><span class="symbol">(</span><i>q</i>, <i>a</i><sub>1</sub>, <i>q</i><sup>’</sup><span class="symbol">)</span>, …, <span class="symbol">(</span><i>q</i>, <i>a</i><sub><i>k</i></sub>, <i>q</i><sup>’</sup><span class="symbol">)</span></span>. Assuming <span class="formula">Σ = <span class="symbol">{</span><i>σ</i><sub>1</sub>, …, <i>σ</i><sub><i>l</i></sub><span class="symbol">}</span></span>, then the label <span class="formula">Σ</span> is used in place of <span class="formula"><i>σ</i><sub>1</sub>, …, <i>σ</i><sub><i>l</i></sub></span>.
</div>
<div class="Unindented">
Next, I report the definitions of a <i>configuration </i>and of a <i>run</i> of a vstk-automaton.
</div>
<div class="Definition">
<a class="Label" name="vstk-conf"> </a>Given a string <span class="formula"><b>s</b></span> with length <span class="formula"><span class="symbol">|</span><b>s</b><span class="symbol">|</span> = <i>n</i></span> and a vstk-automaton <span class="formula"><i>A</i></span> , a configuration of <span class="formula"><i>A</i></span> is a tuple <span class="formula"><i>c</i> = <span class="symbol">(</span><i>q</i>, <i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">v</span></span></i>, <i>Y</i>, <i>i</i><span class="symbol">)</span></span>, where:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>q</i> ∈ <i>Q</i></span> is the current state;
</li>
<li>
<span class="formula"><i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">v</span></span></i></span> is the current variable stack;
</li>
<li>
<span class="formula"><i>Y</i> ∈ <i>Vars</i></span><span class="formula"><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span> is the set of available variables (those not already pushed on the stack);
</li>
<li>
<span class="formula"><i>i</i> ∈ <span class="symbol">{</span>1, ..., <i>n</i> + 1<span class="symbol">}</span></span> is the position of the next character to be read in <span class="formula"><b>s</b></span>.
</li>

</ul>

</li>

</ul>
<div class="Unindented">
Here, as for regex formulas, we want the variable assignment to be clear, so once a variable is pushed on the stack, it is removed from the set of available variables, thus it can be pushed only once. For the rest, a run of a vstk-automaton is similar to those of ordinary FSAs.
</div>
<div class="Definition">
Given a string <span class="formula"><i>s</i></span> and a vstk-automaton <span class="formula"><i>A</i></span>, a run <span class="formula"><i>ρ</i></span> of <span class="formula"><i>A</i></span> on <span class="formula"><i>s</i></span> is a sequence of configurations <span class="formula"><i>c</i><sub>0</sub>, ..., <i>c</i><sub><i>m</i></sub></span> such that:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>c</i><sub>0</sub> = <span class="symbol">(</span><i>q</i><sub>0</sub>, <i>ϵ</i>, <span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span>, 1<span class="symbol">)</span></span>;
</li>
<li>
<span class="formula">∀<i>j</i> ∈ <span class="symbol">{</span>0, ..., <i>m</i> − 1<span class="symbol">}</span></span>, for <span class="formula"><i>c</i><sub><i>j</i></sub></span>=<span class="formula"><span class="symbol">(</span><i>q</i><sub><i>j</i></sub>, <i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">v<sub>j</sub></span></span></i>, <i>Y</i><sub><i>j</i></sub>, <i>i</i><sub><i>j</i></sub><span class="symbol">)</span></span>, <span class="formula"><i>c</i><sub><i>j</i> + 1</sub></span>=<span class="formula"><span class="symbol">(</span><i>q</i><sub><i>j</i> + 1</sub>, <i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">v<sub>j + 1</sub></span></span></i>, <i>Y</i><sub><i>j</i> + 1</sub>, <i>i</i><sub><i>j</i> + 1</sub><span class="symbol">)</span></span> one of the following holds:\begin_inset Separator latexpar\end_inset<ul>
<li>
<span class="formula"><i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">v<sub>j + 1</sub></span></span></i> = <i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">v<sub>j</sub></span></span></i></span>, <span class="formula"><i>Y</i><sub><i>j</i> + 1</sub> = <i>Y</i><sub><i>j</i></sub></span> and either:\begin_inset Separator latexpar\end_inset<ul>
<li>
<span class="formula"><i>i</i><sub><i>j</i> + 1</sub> = <i>i</i><sub><i>j</i></sub> + 1</span>, <span class="formula"><span class="symbol">(</span><i>q</i><sub><i>j</i></sub>, <i>s</i><sub><i>i</i><sub><i>j</i></sub></sub>, <i>q</i><sub><i>j</i> + 1</sub><span class="symbol">)</span> ∈ <i>δ</i></span>;
</li>
<li>
<span class="formula"><i>i</i><sub><i>j</i> + 1</sub> = <i>i</i><sub><i>j</i></sub></span>, <span class="formula"><span class="symbol">(</span><i>q</i><sub><i>j</i></sub>,  ∈ , <i>q</i><sub><i>j</i> + 1</sub><span class="symbol">)</span> ∈ <i>δ</i></span>.
</li>

</ul>

</li>
<li>
<span class="formula"><i>i</i><sub><i>j</i> + 1</sub> = <i>i</i><sub><i>j</i></sub></span> and for some <span class="formula"><i>x</i> ∈ <span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span> either:\begin_inset Separator latexpar\end_inset<ul>
<li>
<span class="formula"><i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">v<sub>j + 1</sub></span></span></i> = <i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">v<sub>j</sub></span></span></i>⋅<i>x</i></span>, <span class="formula"><i>x</i> ∈ <i>Y</i><sub><i>j</i></sub></span>, <span class="formula"><i>Y</i><sub><i>j</i> + 1</sub> = <i>Y</i><sub><i>j</i></sub>∖<span class="symbol">{</span><i>x</i><span class="symbol">}</span></span>, <span class="formula"><span class="symbol">(</span><i>q</i><sub><i>j</i></sub>, <i>x</i>⊢, <i>q</i><sub><i>j</i> + 1</sub><span class="symbol">)</span> ∈ <i>δ</i></span> (x is pushed on the stack);
</li>
<li>
<span class="formula"><i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">v<sub>j</sub></span></span></i> = <i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">v<sub>j + 1</sub></span></span></i>⋅<i>x</i></span>, <span class="formula"><i>x</i> ∈ <i>Y</i><sub><i>j</i></sub></span>, <span class="formula"><i>Y</i><sub><i>j</i> + 1</sub> = <i>Y</i><sub><i>j</i></sub></span>, <span class="formula"><span class="symbol">(</span><i>q</i><sub><i>j</i></sub>, ⊣, <i>q</i><sub><i>j</i> + 1</sub><span class="symbol">)</span> ∈ <i>δ</i></span> (the variable on top of the stack is popped).
</li>

</ul>

</li>

</ul>

</li>

</ul>

</li>

</ul>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Definition">
Given a string <span class="formula"><b>s</b></span> with length <span class="formula"><span class="symbol">|</span><b>s</b><span class="symbol">|</span> = <i>n</i></span> and a vstk-automaton <span class="formula"><i>A</i></span>, a run <span class="formula"><i>ρ</i> = <i>c</i><sub>0</sub>, ..., <i>c</i><sub><i>m</i></sub></span> of <span class="formula"><i>A</i></span> on <span class="formula"><b>s</b></span> is accepting if <span class="formula"><i>c</i><sub><i>m</i></sub> = <span class="symbol">(</span><i>q</i><sub><i>f</i></sub>, <i>ϵ</i>, <span class="textrm">Ø</span>, <i>n</i> + 1<span class="symbol">)</span></span>.
</div>
<div class="Unindented">
The set of all possible accepting runs of a vstk-automaton <span class="formula"><i>A</i></span> on a string <span class="formula"><b>s</b></span> is denoted as <span class="formula"><span class="textrm">ARuns</span><span class="symbol">(</span><i>A</i>, <b>s</b><span class="symbol">)</span></span>. The spanner represented by <span class="formula"><i>A</i></span> may be referred to as <span class="formula"><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span></span>. We have that <span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span><span class="symbol">)</span> = <span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span>, and the span relation <span class="formula"><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span> is the set <span class="formula"><span class="symbol">{</span><i>μ</i><sup><i>ρ</i></sup>∣<i>ρ</i> ∈ <span class="textrm">ARuns</span><span class="symbol">(</span><i>A</i>, <b>s</b><span class="symbol">)</span><span class="symbol">}</span></span>, where <span class="formula"><i>μ</i><sup><i>ρ</i></sup></span> is a tuple defined by a run <span class="formula"><i>ρ</i></span>. In particular, for every variable <span class="formula"><i>x</i> ∈ <span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span>, <span class="formula"><i>μ</i><sup><i>ρ</i></sup><span class="symbol">(</span><i>x</i><span class="symbol">)</span></span> is the span <span class="formula"><span class="symbol">[</span><i>i</i><sub><i>b</i></sub>, <i>i</i><sub><i>e</i></sub><span class="symbol">⟩</span></span>, where:
</div>
<ul>
<li>
<span class="formula"><i>c</i><sub><i>b</i></sub></span>=<span class="formula"><span class="symbol">(</span><i>q</i><sub><i>b</i></sub>, <i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">v<sub>b</sub></span></span></i>, <i>Y</i><sub><i>b</i></sub>, <i>i</i><sub><i>b</i></sub><span class="symbol">)</span></span> is the unique configuration of <span class="formula"><i>ρ</i></span> where <span class="formula"><i>x</i></span> appears in the stack for the fist time;
</li>
<li>
<span class="formula"><i>c</i><sub><i>e</i></sub></span>=<span class="formula"><span class="symbol">(</span><i>q</i><sub><i>e</i></sub>, <i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">v<sub>e</sub></span></span></i>, <i>Y</i><sub><i>e</i></sub>, <i>i</i><sub><i>e</i></sub><span class="symbol">)</span></span> is the unique configuration of <span class="formula"><i>ρ</i></span> where <span class="formula"><i>x</i></span> appears in the stack for the last time.
</li>

</ul>
<div class="Unindented">
The class of variable stack automata is called <span class="formula"><span class="textrm">VA</span><sub><span class="textrm">stk</span></sub></span>.
</div>
<div class="Example">
Consider the regex formula <span class="formula"><i>γ</i></span> from Example <a class="Reference" href="#ex-rgx">6↑</a> and the vstk-automaton <span class="formula"><i>A</i></span> from Figure <a class="Reference" href="#fig:vstk">3.5↑</a>. We have that <span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span> = <span class="symbol">{</span><i>x</i>, <i>y</i>, <i>z</i><span class="symbol">}</span></span>. The reader can verify that <span class="formula"><span class="symbol">⟦</span><i>γ</i><span class="symbol">⟧</span> = <span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span></span>.
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-8"></a>Variable Set Automata
</h4>
<div class="Unindented">
Variable Set Automata (vset-automata for short) are another formalism for representing document spanners that is based on FSAs. Vset-automata are defined in a very similar way to that of vstk-automata. The main differences are:
</div>
<ul>
<li>
the stack of span variables is replaced by a <i>set;</i>
</li>
<li>
no order is defined on the variables in the set, so when we close a variable, we need to specify which one.
</li>

</ul>
<div class="Unindented">
The following is the formal definition of a vset-automaton.
</div>
<div class="Definition">
A variable set automaton is a tuple <span class="formula"><span class="symbol">(</span><i>Q</i>, <i>q</i><sub>0</sub>, <i>q</i><sub><i>f</i></sub>, <i>δ</i><span class="symbol">)</span></span>, where:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>Q</i></span>, <span class="formula"><i>q</i><sub>0</sub></span> and <span class="formula"><i>q</i><sub><i>f</i></sub></span> are defined as in Definition <a class="Reference" href="#vstk-aut">7↑</a>;
</li>
<li>
<span class="formula"><i>δ</i></span> is the same as in Definition <a class="Reference" href="#vstk-aut">7↑</a>, except that it has triples of the form <span class="formula"><span class="symbol">(</span><i>q</i>, ⊣<i>x</i>, <i>q</i>’<span class="symbol">)</span></span>, with <span class="formula"><i>x</i> ∈ <span class="textrm">SVars</span></span>, instead of those of the form <span class="formula"><span class="symbol">(</span><i>q</i>, ⊣, <i>q</i>’<span class="symbol">)</span></span>.
</li>

</ul>

</li>

</ul>
<div class="Unindented">
We also need to slightly modify the definitions of configuration and run with respect to those of a vstk-automaton.
</div>
<div class="Definition">
Given a string <span class="formula"><b>s</b></span> with length <span class="formula"><span class="symbol">|</span><b>s</b><span class="symbol">|</span> = <i>n</i></span> and a vset-automaton <span class="formula"><i>A</i></span> , a configuration of <span class="formula"><i>A</i></span> is a tuple <span class="formula"><i>c</i> = <span class="symbol">(</span><i>q</i>, <i>V</i>, <i>Y</i>, <i>i</i><span class="symbol">)</span></span>, where:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>q</i></span>, <span class="formula"><i>i</i></span> are defined as in Definition <a class="Reference" href="#vstk-conf">7↑</a>;
</li>
<li>
<span class="formula"><i>V</i> ⊆ <span class="textrm">Vars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span> is the active variable set;
</li>
<li>
<span class="formula"><i>Y</i> ∈ <i>Vars</i></span><span class="formula"><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span> is the set of available variables (those not already inserted in the set).
</li>

</ul>

</li>

</ul>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Definition">
Given a string <span class="formula"><b>s</b></span> and a vset-automaton <span class="formula"><i>A</i></span>, a run <span class="formula"><i>ρ</i></span> of <span class="formula"><i>A</i></span> on <span class="formula"><b>s</b></span> is a sequence of configurations <span class="formula"><i>c</i><sub>0</sub>, ..., <i>c</i><sub><i>m</i></sub></span> such that:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>c</i><sub>0</sub> = <span class="symbol">(</span><i>q</i><sub>0</sub>, <span class="textrm"> Ø</span>, <span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span>, 1<span class="symbol">)</span></span>;
</li>
<li>
<span class="formula">∀<i>j</i> ∈ <span class="symbol">{</span>0, ..., <i>m</i> − 1<span class="symbol">}</span></span>, for <span class="formula"><i>c</i><sub><i>j</i></sub></span>=<span class="formula"><span class="symbol">(</span><i>q</i><sub><i>j</i></sub>, <i>V</i><sub><i>j</i></sub>, <i>Y</i><sub><i>j</i></sub>, <i>i</i><sub><i>j</i></sub><span class="symbol">)</span></span>, <span class="formula"><i>c</i><sub><i>j</i> + 1</sub></span>=<span class="formula"><span class="symbol">(</span><i>q</i><sub><i>j</i> + 1</sub>, <i>V</i><sub><i>j</i> + 1</sub>, <i>Y</i><sub><i>j</i> + 1</sub>, <i>i</i><sub><i>j</i> + 1</sub><span class="symbol">)</span></span> one of the following holds:\begin_inset Separator latexpar\end_inset<ul>
<li>
<span class="formula"><i>V</i><sub><i>j</i> + 1</sub> = <i>V</i><sub><i>j</i></sub></span>, <span class="formula"><i>Y</i><sub><i>j</i> + 1</sub> = <i>Y</i><sub><i>j</i></sub></span> and either:\begin_inset Separator latexpar\end_inset<ul>
<li>
<span class="formula"><i>i</i><sub><i>j</i> + 1</sub> = <i>i</i><sub><i>j</i></sub> + 1</span>, <span class="formula"><span class="symbol">(</span><i>q</i><sub><i>j</i></sub>, <i>s</i><sub><i>i</i><sub><i>j</i></sub></sub>, <i>q</i><sub><i>j</i> + 1</sub><span class="symbol">)</span> ∈ <i>δ</i></span>;
</li>
<li>
<span class="formula"><i>i</i><sub><i>j</i> + 1</sub> = <i>i</i><sub><i>j</i></sub></span>, <span class="formula"><span class="symbol">(</span><i>q</i><sub><i>j</i></sub>,  ∈ , <i>q</i><sub><i>j</i> + 1</sub><span class="symbol">)</span> ∈ <i>δ</i></span>.
</li>

</ul>

</li>
<li>
<span class="formula"><i>i</i><sub><i>j</i> + 1</sub> = <i>i</i><sub><i>j</i></sub></span> and for some <span class="formula"><i>x</i> ∈ <span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span> either:\begin_inset Separator latexpar\end_inset<ul>
<li>
<span class="formula"><i>x</i> ∈ <i>Y</i><sub><i>j</i></sub></span>, <span class="formula"><i>V</i><sub><i>j</i> + 1</sub> = <i>V</i><sub><i>j</i></sub>∪<span class="symbol">{</span><i>x</i><span class="symbol">}</span></span>, <span class="formula"><i>Y</i><sub><i>j</i> + 1</sub> = <i>Y</i><sub><i>j</i></sub>∖<span class="symbol">{</span><i>x</i><span class="symbol">}</span></span>, <span class="formula"><span class="symbol">(</span><i>q</i><sub><i>j</i></sub>, <i>x</i>⊢, <i>q</i><sub><i>j</i> + 1</sub><span class="symbol">)</span> ∈ <i>δ</i></span> (<span class="formula"><i>x</i></span> is inserted into the set);
</li>
<li>
<span class="formula"><i>x</i> ∈ <i>V</i><sub><i>j</i></sub></span>, <span class="formula"><i>V</i><sub><i>j</i> + 1</sub> = <i>V</i><sub><i>j</i></sub>∖<span class="symbol">{</span><i>x</i><span class="symbol">}</span></span>, <span class="formula"><i>Y</i><sub><i>j</i> + 1</sub> = <i>Y</i><sub><i>j</i></sub></span>, <span class="formula"><span class="symbol">(</span><i>q</i><sub><i>j</i></sub>, ⊣<i>x</i>, <i>q</i><sub><i>j</i> + 1</sub><span class="symbol">)</span> ∈ <i>δ</i></span> (<span class="formula"><i>x</i></span> is removed from the set).
</li>

</ul>

</li>

</ul>

</li>

</ul>

</li>

</ul>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Definition">
Given a string with length <span class="formula"><span class="symbol">|</span><b>s</b><span class="symbol">|</span> = <i>n</i></span> and a vset-automaton <span class="formula"><i>A</i></span>, a run <span class="formula"><i>ρ</i> = <i>c</i><sub>0</sub>, ..., <i>c</i><sub><i>m</i></sub></span> of <span class="formula"><i>A</i></span> on <span class="formula"><b>s</b></span> is accepting if <span class="formula"><i>c</i><sub><i>m</i></sub> = <span class="symbol">(</span><i>q</i><sub><i>f</i></sub>, <span class="textrm">Ø</span>, <span class="textrm">Ø</span>, <i>n</i> + 1<span class="symbol">)</span></span>.
</div>
<div class="Unindented">
Given a string <span class="formula"><b>s</b></span> and a vset-automaton <span class="formula"><i>A</i></span>, <span class="formula"><span class="textrm">ARuns</span><span class="symbol">(</span><i>A</i>, <b>s</b><span class="symbol">)</span></span>and <span class="formula"><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span></span> are defined as for vstk-automata. The class of variable set automata is called <span class="formula"><span class="textrm">VA</span><sub><span class="textrm">set</span></sub></span>.<span class="formula"><i>y</i><sub>1</sub>⊢, …<i>y</i><sub><i>m</i></sub>⊢, </span>
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="fig:vset"> </a><div class="figure">
span class="align-center"<span class="environment"><span class="arrayrow">
<span class="arraycell align-l">
[shorten
</span>
<span class="arraycell align-l">
gt; = 1pt, nodedistance = 3cm, ongrid, auto]<span class="unknown">\node</span>[state, initial, accepting](q<sub>0</sub>);<span class="unknown">\path</span>[ − 
</span>
<span class="arraycell align-l">
gt;](q<sub>0</sub>)edge[loopabove]nodeΣ()edge[loopbelow]node[align = center]y<sub>1</sub>⊢, …y<sub>m</sub>⊢, <br>⊣y<sub>1</sub>, …⊣y<sub>m</sub>();
</span>

</span>
</span><div class="caption">
Figure 3.6 A vset-automaton <span class="formula"><i>B</i></span> with <span class="formula"><span class="symbol">⟦</span><i>B</i><span class="symbol">⟧</span> = Υ<sub><i>Y</i></sub></span>, for <span class="formula"><i>Y</i> = <span class="symbol">{</span><i>y</i><sub>1</sub>, …, <i>y</i><sub><i>m</i></sub><span class="symbol">}</span></span> (this image is taken from <span class="bibcites">[<a class="bibliocite" name="cite-5" href="#biblio-5"><span class="bib-index">5</span></a>]</span>).
</div>

</div>

</div>

</div>
<div class="Example">
Figure <a class="Reference" href="#fig:vset">3.6↑</a> shows a vset-automaton <span class="formula"><i>B</i></span>, with <span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><i>B</i><span class="symbol">)</span> = <i>Y</i></span>, where <span class="formula"><i>Y</i> = <span class="symbol">{</span><i>y</i><sub>1</sub>, …, <i>y</i><sub><i>m</i></sub><span class="symbol">}</span></span>. We have that <span class="formula"><span class="symbol">⟦</span><i>B</i><span class="symbol">⟧</span> = Υ<sub><i>Y</i></sub></span>. This shows that vset-automata can express spanners that regex formulas and vstk-automata cannot. (This example was adapted from <span class="bibcites">[<a class="bibliocite" name="cite-5" href="#biblio-5"><span class="bib-index">5</span></a>]</span>).
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.3.3">3.3.3</a> Algebras of Spanners<a class="Label" name="subsec:Algebras-of-Spanners"> </a>
</h3>
<div class="Unindented">
Besides mere span extraction, AQL offers the capability to combine, transform and filter extracted tuples by using a series of operators. Here, I introduce the relational operators for spanners, described in <span class="bibcites">[<a class="bibliocite" name="cite-5" href="#biblio-5"><span class="bib-index">5</span></a>]</span>, that are considered to capture the core relational operations of AQL. They are:
</div>
<ul>
<li>
<i>Union </i>(<span class="formula">∪</span>);
</li>
<li>
<i>Projection </i>(<span class="formula"><i>π</i></span>);
</li>
<li>
<i>Natural Join</i> (<span class="formula">⋈</span>);
</li>
<li>
<i>String Selection</i> (<span class="formula"><i>ς</i></span>).
</li>

</ul>
<div class="Unindented">
A finite set of spanner operators forms a <i>spanner algebra</i>. In the following, I look at the definitions of the listed spanner operators.
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-9"></a>Union
</h4>
<div class="Unindented">
Before giving the definition of the union operator, we need to introduce the concept of <i>union compatible spanners.</i>
</div>
<div class="Definition">
Given two document spanners <span class="formula"><i>P</i><sub>1</sub></span> and <span class="formula"><i>P</i><sub>2</sub></span>, they are union compatible if and only if <span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><i>P</i><sub>1</sub><span class="symbol">)</span> = <span class="textrm"> SVars</span><span class="symbol">(</span><i>P</i><sub>2</sub><span class="symbol">)</span></span>.
</div>
<div class="Unindented">
The definition of union of two spanners is as follows.
</div>
<div class="Definition">
Given two union compatible document spanners <span class="formula"><i>P</i><sub>1</sub></span> and <span class="formula"><i>P</i><sub>2</sub></span>, their union is the spanner denoted as <span class="formula"><i>P</i><sub>1</sub>∪<i>P</i><sub>2</sub></span>, for which we have that:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><i>P</i><sub>1</sub>∪<i>P</i><sub>2</sub><span class="symbol">)</span> = <span class="textrm"> SVars</span><span class="symbol">(</span><i>P</i><sub>1</sub><span class="symbol">)</span></span>;
</li>
<li>
given a string <span class="formula"><b>s</b></span>, <span class="formula"><span class="symbol">(</span><i>P</i><sub>1</sub>∪<i>P</i><sub>2</sub><span class="symbol">)</span><span class="symbol">(</span><b> s</b><span class="symbol">)</span> = <i>P</i><sub>1</sub><span class="symbol">(</span><b> s</b><span class="symbol">)</span>∪<i>P</i><sub>2</sub><span class="symbol">(</span><b> s</b><span class="symbol">)</span></span>.
</li>

</ul>

</li>

</ul>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-10"></a>Projection
</h4>
<div class="Definition">
Given a document spanner <span class="formula"><i>P</i></span> and a set of span variables <span class="formula"><i>Y</i> ⊆ <span class="textrm">SVars</span><span class="symbol">(</span><i>P</i><span class="symbol">)</span></span>, the projection of <span class="formula"><i>P</i></span> over <span class="formula"><i>Y</i></span> is the spanner denoted as <span class="formula"><i>π</i><sub><i>Y</i></sub><i>P</i></span>, satisfying <span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><i>π</i><sub><i>Y</i></sub><i>P</i><span class="symbol">)</span> = <i>Y</i></span>.
</div>
<div class="Unindented">
As the name and the definition suggest, the projection of a document spanner <span class="formula"><i>P</i></span> over a subset of its span variables <span class="formula"><i>Y</i></span> is obtained by reducing the domain of each of the spanner’s output <span class="formula"><b>s</b> − <span class="textrm">tuples</span></span> to <span class="formula"><i>Y</i></span>.
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-11"></a>Natural Join
</h4>
<div class="Definition">
Given two document spanners <span class="formula"><i>P</i><sub>1</sub></span> and <span class="formula"><i>P</i><sub>2</sub></span>, their natural join is the spanner denoted as <span class="formula"><i>P</i><sub>1</sub>⋈<i>P</i><sub>2</sub></span>, for which we have that:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><i>P</i><sub>1</sub>⋈<i>P</i><sub>2</sub><span class="symbol">)</span> = <span class="textrm"> SVars</span><span class="symbol">(</span><i>P</i><sub>1</sub><span class="symbol">)</span>∪<span class="textrm"> SVars</span><span class="symbol">(</span><i>P</i><sub>2</sub><span class="symbol">)</span></span>;
</li>
<li>
given a string <span class="formula"><b>s</b></span>, <span class="formula"><span class="symbol">(</span><i>P</i><sub>1</sub>⋈<i>P</i><sub>2</sub><span class="symbol">)</span><span class="symbol">(</span><b> s</b><span class="symbol">)</span></span> consists of all the <span class="formula"><b>s</b> − <span class="textrm">tuples</span></span> <span class="formula"><i>μ</i></span> agreeing with some <span class="formula"><i>μ</i><sub>1</sub> ∈ <i>P</i><sub>1</sub><span class="symbol">(</span><b> s</b><span class="symbol">)</span></span> and some <span class="formula"><i>μ</i><sub>2</sub> ∈ <i>P</i><sub>2</sub><span class="symbol">(</span><b> s</b><span class="symbol">)</span></span>. Note that this implies that <span class="formula"><i>μ</i><sub>1</sub>, <i>μ</i><sub>2</sub></span> agree on variables that are common to <span class="formula"><i>P</i><sub>1</sub>, <i>P</i><sub>2</sub></span>: <span class="formula">∀<i>x</i> ∈ <span class="textrm">SVars</span><span class="symbol">(</span><i>P</i><sub>1</sub><span class="symbol">)</span>∩<span class="textrm"> SVars</span><span class="symbol">(</span><i>P</i><sub>2</sub><span class="symbol">)</span></span>, <span class="formula"><i>μ</i><sub>1</sub><span class="symbol">(</span><i>x</i><span class="symbol">)</span> = <i>μ</i><sub>2</sub><span class="symbol">(</span><i>x</i><span class="symbol">)</span></span>. 
</li>

</ul>

</li>

</ul>
<div class="Example">
Consider again the regex formula <span class="formula"><i>γ</i></span> from Example <a class="Reference" href="#ex-rgx">6↑</a>. The reader can verify that <span class="formula"><i>γ</i></span> can be expressed as:
</div>
<div class="Example">
\SpecialChar ldots<div class="formula">
<a class="eqnumber" name="eq-3.5">(3.5) </a><span class="symbol">(</span>Σ<sup>∗</sup>⋅<i>x</i><span class="symbol">{</span><i>γ</i><sub><i>action</i></sub><span class="symbol">}</span>⋅Σ<sup>∗</sup><span class="symbol">)</span>⋈<span class="symbol">(</span>Σ<sup>∗</sup>⋅<i>y</i><span class="symbol">{</span><i>γ</i><sub><i>title</i></sub><span class="symbol">}</span>⋅Σ<sup>∗</sup><span class="symbol">)</span>⋈<span class="symbol">(</span>Σ<sup>∗</sup>⋅<i>z</i><span class="symbol">{</span><i>x</i><span class="symbol">{</span>Σ<sup> + </sup><span class="symbol">}</span>⋅Σ<sup> + </sup>⋅<i>y</i><span class="symbol">{</span>Σ<sup> + </sup><span class="symbol">}</span><span class="symbol">}</span>⋅Σ<sup>∗</sup><span class="symbol">)</span>
</div>
.
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-12"></a>String Selection
</h4>
<div class="Definition">
Given a document spanner <span class="formula"><i>P</i></span> and a k-ary string relation <span class="formula"><i>R</i></span>, the string selection operation according to <span class="formula"><i>R</i></span> is denoted as <span class="formula"><i>ς</i><sup><i>R</i></sup></span>, and is parametrized by <span class="formula"><i>x</i><sub>1</sub>, ..., <i>x</i><sub><i>k</i></sub> ∈ <span class="textrm">SVars</span><span class="symbol">(</span><i>P</i><span class="symbol">)</span></span>. We have that, given a string <span class="formula"><b>s</b></span> and a spanner <span class="formula"><i>P</i>’: = <i>ς</i><sub><i>x</i><sub>1</sub>, ..., <i>x</i><sub><i>k</i></sub></sub><sup><i>R</i></sup><i>P</i></span>, <span class="formula"><i>P</i>’<span class="symbol">(</span><b>s</b><span class="symbol">)</span></span> consists of all the <span class="formula"><b>s</b> − <span class="textrm">tuples</span></span> <span class="formula"><i>μ</i></span> such that <span class="formula"><span class="symbol">(</span><b>s</b><sub><i>μ</i><span class="symbol">(</span><i>x</i><sub>1</sub><span class="symbol">)</span></sub>, ..., <b> s</b><sub><i>μ</i><span class="symbol">(</span><i>x</i><sub><i>k</i></sub><span class="symbol">)</span></sub><span class="symbol">)</span> ∈ <i>R</i></span>.
</div>
<div class="Unindented">
In the remainder of this document, the only string selection operator I consider is <span class="formula"><i>ς</i><sub><i>x</i>, <i>y</i></sub><sup> = </sup></span> which, given a spanner <span class="formula"><i>P</i></span>, restricts <span class="formula"><i>P</i><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span> to those <span class="formula"><b>s</b> − <span class="textrm">tuples</span></span> that satisfy <span class="formula"><b>s</b><sub><i>μ</i><span class="symbol">(</span><i>x</i><span class="symbol">)</span></sub> = <b>s</b><sub><i>μ</i><span class="symbol">(</span><i>y</i><span class="symbol">)</span></sub></span>.
</div>
<div class="Indented">
<div class="defskip"> </div>
</div>
<div class="Indented">
I now introduce some additional notation. Given a generic class of spanner representations <span class="formula"><span class="textrm">SR</span></span>, the set of all the spannners that can be represented by <span class="formula"><span class="textrm">SR</span></span> is denoted as <span class="formula"><span class="symbol">⟦</span><span class="textrm">SR</span><span class="symbol">⟧</span></span>. Formally, we have that <span class="formula"><span class="symbol">⟦</span><span class="textrm">SR</span><span class="symbol">⟧</span> = <span class="symbol">{</span><span class="symbol">⟦</span><i>r</i><span class="symbol">⟧</span>∣<i>r</i> ∈ <span class="textrm">SR</span><span class="symbol">}</span></span>. Let <span class="formula"><i>O</i></span> be a spanner algebra. I denote by <span class="formula"><span class="textrm">SR</span><sup><i>O</i></sup></span> the closure of <span class="formula"><span class="textrm">SR</span></span> under <span class="formula"><i>O</i></span>, that is: the class of spanner represantations obtained by applying (compositions of) operators contained in <span class="formula"><i>O</i></span> to the represantations in <span class="formula"><span class="textrm">SR</span></span>. The corresponding set of spanners is referred to as <span class="formula"><span class="symbol">⟦</span><span class="textrm">SR</span><sup><i>O</i></sup><span class="symbol">⟧</span></span>. We are ready to start reasoning on the expressive power of the spanner representations that we saw. Please refer to <span class="bibcites">[<a class="bibliocite" name="cite-5" href="#biblio-5"><span class="bib-index">5</span></a>]</span> for the proofs of the mathematical statements in the remainder of this Chapter.
</div>
<div class="Proposition">
The following hold:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ol>
<li>
every document spanner represented in the classes <span class="formula"><span class="textrm">RGX</span></span> and <span class="formula"><span class="textrm">VA</span><sub><span class="textrm">stk</span></sub></span> is hierarchical, that is: <span class="formula"><span class="symbol">⟦</span><span class="textrm"><span class="textrm">RGX</span></span><span class="symbol">⟧</span>, <span class="symbol">⟦</span><span class="textrm"><span class="textrm">VA</span><sub><span class="textrm">stk</span></sub></span><span class="symbol">⟧</span> ⊆ <b>HS</b></span>;
</li>
<li>
there exist some spanners represented in <span class="formula"><span class="textrm">VA</span><sub><span class="textrm">set</span></sub></span> that are not hierarchical: <span class="formula"><span class="symbol">⟦</span><span class="textrm"><span class="textrm">VA</span><sub>set</sub></span><span class="symbol">⟧</span>⊈<b>HS</b></span>;
</li>
<li>
the operators <span class="formula">∪</span>, <span class="formula"><i>π</i></span>, <span class="formula"><i>ς</i><sup><i>R</i></sup></span> preserve the property of being hierarchical, while <span class="formula">⋈</span> does not, thus we have that:\begin_inset Separator latexpar\end_inset<ol>
<li>
given a class of spanner representations <span class="formula"><span class="textrm">SR</span></span>, <span class="formula"><span class="symbol">⟦</span><span class="textrm">SR</span><span class="symbol">⟧</span> ⊆ <b>HS</b> ⇒ <span class="symbol">⟦</span><span class="textrm">SR</span><sup><span class="symbol">{</span>∪, <i>π</i>, <i>ς</i><sup><i>R</i></sup><span class="symbol">}</span></sup><span class="symbol">⟧</span> ⊆ <b>HS</b>;</span>
</li>
<li>
there exist two hierarchical spanners <span class="formula"><i>P</i><sub>1</sub>, <i>P</i><sub>2</sub></span> such that <span class="formula"><i>P</i><sub>1</sub>⋈<i>P</i><sub>2</sub>∉<b> HS</b></span>.
</li>

</ol>

</li>

</ol>

</li>

</ul>
<div class="Unindented">
In the next Subsection, I discuss the class of <i>regular spanners</i>, which plays a central role in the construction of the class of spanners constituting the core of AQL.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.3.4">3.3.4</a> Regular Spanners
</h3>
<div class="Unindented">
A regular spanner is defined as follows.
</div>
<div class="Definition">
A spanner is regular if it can be defined by a vset-automaton.
</div>
<div class="Unindented">
Let us see how regular spanners are related to the other basic spanner classes. A preliminary result is that regex formulas and vstk-automata have the same expressive power.
</div>
<div class="Theorem">
<a class="Label" name=".rgx=vstk"> </a><span class="formula"><span class="symbol">⟦</span><span class="textrm"><span class="textrm">RGX</span></span><span class="symbol">⟧</span> = <span class="symbol">⟦</span><span class="textrm"><span class="textrm">VA</span><sub><span class="textrm">stk</span></sub></span><span class="symbol">⟧</span></span>.
</div>
<div class="Unindented">
It turns out that the spanners expressed by representations in <span class="formula"><span class="textrm"><span class="textrm">VA</span><sub><span class="textrm">stk</span></sub></span></span>(<span class="formula"><span class="textrm"><span class="textrm">RGX</span></span></span>) are exactly those that are both regular and hierarchical.
</div>
<div class="Theorem">
<span class="formula"><span class="symbol">⟦</span><span class="textrm"><span class="textrm">VA</span><sub><span class="textrm">stk</span></sub></span><span class="symbol">⟧</span> = <span class="symbol">⟦</span><span class="textrm"><span class="textrm">VA</span><sub><span class="textrm">set</span></sub></span><span class="symbol">⟧</span>∩<b>HS</b></span>.
</div>
<div class="Unindented">
For what concerns the algebraic operators I presented in Subsection <a class="Reference" href="#subsec:Algebras-of-Spanners">3.3.3↑</a>, it can be shown that union, projection and join don’t increase the expressive power of regular spanners.
</div>
<div class="Theorem">
<a class="Label" name=".setext=set"> </a><span class="formula"><span class="symbol">⟦</span><span class="textrm"><span class="textrm">VA</span><sub><span class="textrm">set</span></sub></span><sup><span class="symbol">{</span>∪, <i>π</i>, ⋈<span class="symbol">}</span></sup><span class="symbol">⟧</span> = <span class="symbol">⟦</span><span class="textrm"><span class="textrm">VA</span><sub><span class="textrm">set</span></sub></span><span class="symbol">⟧</span></span>.
</div>
<div class="Unindented">
On the other hand, applying the same operators to the spanner representations in <span class="formula"><span class="textrm"><span class="textrm">VA</span><sub><span class="textrm">stk</span></sub></span></span> results in a class equivalent to regular spanners.
</div>
<div class="Theorem">
<a class="Label" name=".stkext=set"> </a><span class="formula"><span class="symbol">⟦</span><span class="textrm"><span class="textrm">VA</span><sub><span class="textrm">stk</span></sub></span><sup><span class="symbol">{</span>∪, <i>π</i>, ⋈<span class="symbol">}</span></sup><span class="symbol">⟧</span> = <span class="symbol">⟦</span><span class="textrm"><span class="textrm">VA</span><sub><span class="textrm">set</span></sub></span><span class="symbol">⟧</span></span>.
</div>
<div class="Theorem">
<div class="defskip"> </div>
</div>
<div class="Unindented">
Let us now look at which string relations can be simulated by regular spanners, starting with the concept of <i>selectable string relation</i>.
</div>
<div class="Definition">
Given a string relation <span class="formula"><i>R</i></span> and a class of spanners <span class="formula"><i>C</i></span>, <span class="formula"><i>R</i></span> is selectable by <span class="formula"><i>C</i></span> if for every document spanner <span class="formula"><i>P</i> ∈ <i>C</i></span> and for every <span class="formula"><i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">x</span></span></i> = <i>x</i><sub>1</sub>, ..., <i>x</i><sub><i>k</i></sub></span>, <span class="formula"><i>x</i><sub><i>i</i></sub> ∈ <span class="textrm">SVars</span><span class="symbol">(</span><i>P</i><span class="symbol">)</span></span>, we have that <span class="formula"><i>ς</i><sub><i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">x</span></span></i></sub><sup><i>R</i></sup><i>P</i> ∈ <i>C</i></span>.
</div>
<div class="Unindented">
Next, I introduce the concept of <i>restricted universal spanner.</i>
</div>
<div class="Definition">
Given a string relation <span class="formula"><i>R</i></span> and a sequence of variables<span class="formula"><i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">x</span></span></i> = <i>x</i><sub>1</sub>, ..., <i>x</i><sub><i>k</i></sub></span> with their corrsesponding set <span class="formula"><i>X</i> = <span class="symbol">{</span><i>x</i><sub>1</sub>, ..., <i>x</i><sub><i>k</i></sub><span class="symbol">}</span></span>, the <span class="formula"><i>R</i> − <span class="textrm">restricted</span></span> universal spanner over <span class="formula"><i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">x</span></span></i></span> is <span class="formula">Υ<sub><i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">x</span></span></i></sub><sup><i>R</i></sup>: = <i>ς</i><sub><i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">x</span></span></i></sub><sup><i>R</i></sup>Υ<sub><i>X</i></sub></span>.
</div>
<div class="Unindented">
Selectability of a string relation <span class="formula"><i>R</i></span> by a class of spanners <span class="formula"><i>C</i></span> corresponds to the presence in <span class="formula"><i>C</i></span> of all the possible <span class="formula"><i>R</i> − <span class="textrm">restricted</span></span> universal spanners, under some conditions.
</div>
<div class="Proposition">
Given a string relation <span class="formula"><i>R</i></span> and a class of spanners <span class="formula"><i>C</i></span> containing all the possible universal spanners and closed under natural join, <span class="formula"><i>R</i></span> is selectable by <span class="formula"><i>C</i></span> if and only if, for every <span class="formula"><i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">x</span></span></i> = <i>x</i><sub>1</sub>, ..., <i>x</i><sub><i>k</i></sub> ∈ <span class="textrm">SVars</span><sup><i>k</i></sup></span>, <span class="formula">Υ<sub><i><span class="withsymbol"><span class="symbolover">⟶</span><span class="undersymbol">x</span></span></i></sub><sup><i>R</i></sup> ∈ <i>C</i></span>.
</div>
<div class="Unindented">
In the case of regular spanners, the class of string relations that they can select is exactly <span class="formula"><span class="textrm">REC</span></span>.
</div>
<div class="Theorem">
The class of string relations selectable by <span class="formula"><span class="symbol">⟦</span><span class="textrm"><span class="textrm">VA</span><sub><span class="textrm">set</span></sub></span><span class="symbol">⟧</span></span> is <span class="formula"><span class="textrm">REC</span></span>.
</div>
<div class="Unindented">
The relation &ldquo;<span class="formula"> = </span>&rdquo; is not in <span class="formula"><span class="textrm">REC</span></span>, thus it is not selectable by regular spanners, nonetheless it is important for selection predicates in AQL, which is why regular spanners don’t have enough expressive power to model its core. In the following Subsection, I describe the spanners that are identified in <span class="bibcites">[<a class="bibliocite" name="cite-5" href="#biblio-5"><span class="bib-index">5</span></a>]</span> as the core of AQL: <i>core spanners</i>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.3.5">3.3.5</a> Core Spanners
</h3>
<div class="Unindented">
An expression in the core of AQL belongs to <span class="formula"><span class="textrm">RGX</span><sup><span class="symbol">{</span>∪, <i>π</i>, ⋈, <i>ς</i><sup> = </sup><span class="symbol">}</span></sup></span>. Consequently, a core spanner is defined as follows.
</div>
<div class="Definition">
<a class="Label" name="core-def"> </a>A core spanner is a document spanner belonging to <span class="formula"><span class="symbol">⟦</span><span class="textrm">RGX</span><sup><span class="symbol">{</span>∪, <i>π</i>, ⋈, <i>ς</i><sup> = </sup><span class="symbol">}</span></sup><span class="symbol">⟧</span></span>.
</div>
<div class="Unindented">
Thanks to Theorems <a class="Reference" href="#.rgx=vstk">3.3.4↑</a>, <a class="Reference" href="#.setext=set">3.3.4↑</a> and <a class="Reference" href="#.stkext=set">3.3.4↑</a> we can easily state the next theorem. 
</div>
<div class="Theorem">
<a class="Label" name="RGX=SET"> </a><span class="formula"><span class="symbol">⟦</span><span class="textrm">RGX</span><sup><span class="symbol">{</span>∪, <i>π</i>, ⋈, <i>ς</i><sup> = </sup><span class="symbol">}</span></sup><span class="symbol">⟧</span> = <span class="symbol">⟦</span><span class="textrm"><span class="textrm">VA</span><sub><span class="textrm">stk</span></sub></span><sup><span class="symbol">{</span>∪, <i>π</i>, ⋈, <i>ς</i><sup> = </sup><span class="symbol">}</span></sup><span class="symbol">⟧</span> = <span class="symbol">⟦</span><span class="textrm"><span class="textrm">VA</span><sub><span class="textrm">set</span></sub></span><sup><span class="symbol">{</span>∪, <i>π</i>, ⋈, <i>ς</i><sup> = </sup><span class="symbol">}</span></sup><span class="symbol">⟧</span></span>. 
</div>
<div class="Unindented">
This shows that core spanners can be reduced to regular spanners extended with the algebra <span class="formula"><span class="symbol">{</span>∪, <i>π</i>, ⋈, <i>ς</i><sup> = </sup><span class="symbol">}</span></span>. But the following lemma tells us an algebra with fewer operators is also sufficient.
</div>
<div class="Lemma">
<span class="formula"><span class="symbol">⟦</span><span class="textrm"><span class="textrm">VA</span><sub><span class="textrm">set</span></sub></span><sup><span class="symbol">{</span>∪, <i>π</i>, ⋈, <i>ς</i><sup> = </sup><span class="symbol">}</span></sup><span class="symbol">⟧</span> = <span class="symbol">⟦</span><span class="textrm"><span class="textrm">VA</span><sub><span class="textrm">set</span></sub></span><sup><span class="symbol">{</span><i>π</i>, <i>ς</i><sup> = </sup><span class="symbol">}</span></sup><span class="symbol">⟧</span></span>.
</div>
<div class="Unindented">
Another lemma, known as the <i>core simplification lemma</i>, gives an even more simple way of representing core spanners.
</div>
<div class="Lemma">
<a class="Label" name="Core-simplif"> </a><span class="formula"><b>(Core Simplification Lemma)</b></span> Every core spanner can be defined by an expression of the form
</div>
<div class="Lemma">
<div class="formula">
<a class="eqnumber" name="eq-3.6">(3.6) </a><i>π</i><sub><i>V</i></sub><i>SA</i>
</div>

</div>
<div class="Lemma">
where:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>A</i></span> is a vset-automaton;
</li>
<li>
<span class="formula"><i>V</i> ⊆ <span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span>;
</li>
<li>
<span class="formula"><i>S</i></span> is a sequence of string selections <span class="formula"><i>ς</i><sub><i>x</i>, <i>y</i></sub><sup> = </sup></span>, for <span class="formula"><i>x</i>, <i>y</i> ∈ <span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span>.
</li>

</ul>

</li>

</ul>
<div class="Unindented">
For what concerns which string relations can be simulated by core spanners, the next definition presents three string relations of relevance.
</div>
<div class="Definition">
Given two strings <span class="formula"><b>s</b>, <b>t</b> ∈ <i>Σ</i><sup>∗</sup></span>:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><b>s</b>⊑<b>t</b></span> if <span class="formula"><b>s</b></span> is a (consecutive) substring of t (i.e. <span class="formula"><b>s</b> = <b>t</b><sub><span class="symbol">[</span><i>i</i>, <i>j</i><span class="symbol">⟩</span></sub></span>);
</li>
<li>
<span class="formula"><b>s</b>⊑<sub><span class="textrm">prf</span></sub><b>t</b></span> if <span class="formula"><b>s</b></span> is a prefix of t (i.e. <span class="formula"><b>s</b> = <b>t</b><sub><span class="symbol">[</span>1, <i>j</i><span class="symbol">⟩</span></sub></span>);
</li>
<li>
<span class="formula"><b>s</b>⊑<sub><span class="textrm">sfx</span></sub><b>t</b></span>if <span class="formula"><b>s</b></span> is a suffix of t (i.e. <span class="formula"><b>s</b> = <b>t</b><sub><span class="symbol">[</span>1, <span class="symbol">|</span><b> t</b><span class="symbol">|</span> + 1<span class="symbol">⟩</span></sub></span>).
</li>

</ul>

</li>

</ul>
<div class="Proposition">
All the string relations in <span class="formula"><span class="textrm">REC</span></span>, <span class="formula"><b>⊑</b></span>, <span class="formula">⊑<sub><span class="textrm">prf</span></sub></span> and <span class="formula">⊑<sub><span class="textrm">sfx</span></sub></span> are selectable by the core spanners.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.3.6">3.3.6</a> Difference
</h3>
<div class="Unindented">
The difference operator is defined as follows.
</div>
<div class="Definition">
Given two union compatible document spanners <span class="formula"><i>P</i><sub>1</sub></span> and <span class="formula"><i>P</i><sub>2</sub></span>, their difference is the spanner <span class="formula"><i>P</i><sub>1</sub>∖<i>P</i><sub>2</sub></span>, for which we have:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><i>P</i><sub>1</sub>∖<i>P</i><sub>2</sub><span class="symbol">)</span> = <span class="textrm"> SVars</span><span class="symbol">(</span><i>P</i><sub>1</sub><span class="symbol">)</span></span>;
</li>
<li>
given a string <span class="formula"><b>s</b></span>, <span class="formula"><span class="symbol">(</span><i>P</i><sub>1</sub>∖<i>P</i><sub>2</sub><span class="symbol">)</span><span class="symbol">(</span><b> s</b><span class="symbol">)</span> = <span class="symbol">(</span><i>P</i><sub>1</sub><span class="symbol">)</span>∖<span class="symbol">(</span><i>P</i><sub>2</sub><span class="symbol">)</span><span class="symbol">(</span><b> s</b><span class="symbol">)</span></span>.
</li>

</ul>

</li>

</ul>
<div class="Unindented">
It can be shown that regular spanners are closed under difference.
</div>
<div class="Theorem">
<a class="Label" name=".setdiff=set"> </a><span class="formula"><span class="symbol">⟦</span><span class="textrm"><span class="textrm">VA</span><sub><span class="textrm">set</span></sub></span><sup><span class="symbol">{</span>∖<span class="symbol">}</span></sup><span class="symbol">⟧</span> = <span class="symbol">⟦</span><span class="textrm"><span class="textrm">VA</span><sub><span class="textrm">set</span></sub></span><span class="symbol">⟧</span></span>.
</div>
<div class="Unindented">
Despite the result of of Theorem <a class="Reference" href="#.setdiff=set">3.3.6↑</a>, core spanners are not closed under difference, which is why this operator has not been considered so far.
</div>
<div class="Theorem">
<a class="Label" name=".last-stat"> </a><span class="formula"><span class="symbol">⟦</span><span class="textrm">RGX</span><sup><span class="symbol">{</span>∪, <i>π</i>, ⋈, <i>ς</i><sup> = </sup><span class="symbol">}</span></sup><span class="symbol">⟧</span> ⊊ <span class="symbol">⟦</span><span class="textrm">RGX</span><sup><span class="symbol">{</span>∪, <i>π</i>, ⋈, <i>ς</i><sup> = </sup>, ∖<span class="symbol">}</span></sup><span class="symbol">⟧</span></span>.
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-4">4</a> A Runtime System for AQL’s Core
</h1>
<div class="Unindented">
In this chapter I describe a new runtime system for AQL’s core fragments. It is based on a modified version of vset-automata, the <i>extended vset-automata (</i>or <i>eVset-automata).</i> In particular, the system works with a particular kind of eVset-automata: <i>well-behaved eVset-automata. </i>I start by defining eVset-automata, then I describe well-behaved eVset-automata and their properties, with particular attention to their ability to support the operations from the algebra presented in Subsection <a class="Reference" href="#subsec:Algebras-of-Spanners">3.3.3↑</a>. Subsequently, I review some interesting ways of running usual nondeterministic automata on a string, from which I took inspiration for my implementation. Finally I explain how the system works.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.1">4.1</a> Extended Vset-automata
</h2>
<div class="Unindented">
Before I define extended vset-automata formally, I introduce some basic concepts.
</div>
<div class="Definition">
Given a set <span class="formula"><i>X</i> ⊆ <span class="textrm">SVars</span></span>, we define:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><span class="textrm">SVOps</span><sup>⊢</sup><span class="symbol">(</span><i>X</i><span class="symbol">)</span> = <span class="symbol">{</span><i>x</i>⊢∣<i>x</i> ∈ <i>X</i><span class="symbol">}</span></span>;
</li>
<li>
<span class="formula"><span class="textrm">SVOps</span><sup>⊣</sup><span class="symbol">(</span><i>X</i><span class="symbol">)</span> = <span class="symbol">{</span>⊣<i>x</i>∣<i>x</i> ∈ <i>X</i><span class="symbol">}</span></span>;
</li>
<li>
<span class="formula"><span class="textrm">SVOps</span><span class="symbol">(</span><i>X</i><span class="symbol">)</span> = <span class="textrm">SVOps</span><sup>⊢</sup><span class="symbol">(</span><i>X</i><span class="symbol">)</span>∪<span class="textrm">SVOps</span><sup>⊣</sup><span class="symbol">(</span><i>X</i><span class="symbol">)</span></span>.
</li>

</ul>

</li>

</ul>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Indented">
I now define an extended vset-automaton.
</div>
<div class="Definition">
An extended <i>variable-set automaton</i> (or <i>eVset-automaton</i>) is a tuple <span class="formula"><span class="symbol">(</span><i>Q</i>, <i>q</i><sub>0</sub>, <i>q</i><sub><i>f</i></sub>, <i>δ</i><span class="symbol">)</span></span>, where:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>Q</i></span> is a finite set of states;
</li>
<li>
<span class="formula"><i>q</i><sub>0</sub> ∈ <i>Q</i></span> is the initial state;
</li>
<li>
<span class="formula"><i>q</i><sub><i>f</i></sub> ∈ <i>Q</i></span> is the accepting state;
</li>
<li>
<span class="formula"><i>δ</i> = <i>δ</i><sup><span class="textrm">char</span></sup>∪<i>δ</i><sup><span class="textrm">op</span></sup></span> is a finite transition relation consisting of triples, where:\begin_inset Separator latexpar\end_inset<ul>
<li>
<span class="formula"><i>δ</i><sup><span class="textrm">char</span></sup> = <span class="symbol">{</span><span class="symbol">(</span><i>q</i>, <i>σ</i>, <i>q</i>’<span class="symbol">)</span>∣<i>q</i>, <i>q</i>’ ∈ <i>Q</i>, <i>σ</i> ∈ <i>Σ</i><span class="symbol">}</span></span>, whose elments are called character transitions;
</li>
<li>
<span class="formula"><i>δ</i><sup><span class="textrm">op</span></sup> = <span class="symbol">{</span><span class="symbol">(</span><i>q</i>, <i>S</i>, <i>q</i>’<span class="symbol">)</span>∣<i>q</i>, <i>q</i>’ ∈ <i>Q</i>, <i>S</i> ⊆ <span class="textrm">SVOps<span class="symbol">(</span>SVars<span class="symbol">)</span></span><span class="symbol">}</span></span>, whose elements are called operation transitions .
</li>

</ul>

</li>

</ul>

</li>

</ul>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Indented">
In a transition<span class="formula"><span class="symbol">(</span><i>q</i>, <i>a</i>, <i>q</i>’<span class="symbol">)</span></span> with label <span class="formula"><i>a</i></span> from state <span class="formula"><i>q</i></span> to state <span class="formula"><i>q</i>’</span>, <span class="formula"><i>q</i></span> is called the <i>source state</i>, while <span class="formula"><i>q</i>’</span> is called the <i>destination state</i>. By a slight abuse of notation, I denote by <span class="formula"><span class="textrm">SVOps</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span> the set of variable operations appearing in the transitions of an eVset-automaton <span class="formula"><i>A</i></span>. <span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span> is defined as for a usual vset-automaton. I now define a configuration and, subsequently, a run of an eVset-automaton.
</div>
<div class="Definition">
Given a string <span class="formula"><b>s</b></span>, <span class="formula"><span class="symbol">|</span><b>s</b><span class="symbol">|</span> = <i>n</i></span>, and an eVset-automaton <span class="formula"><i>A</i> = <span class="symbol">(</span><i>Q</i>, <i>q</i><sub>0</sub>, <i>q</i><sub><i>f</i></sub>, <i>δ</i><span class="symbol">)</span></span>, a configuration of A is a tuple <span class="formula"><i>c</i> = <span class="symbol">(</span><i>q</i>, <i>V</i>, <i>Y</i>, <i>i</i><span class="symbol">)</span></span>, where:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>q</i> ∈ <i>Q</i></span> is the current state;
</li>
<li>
<span class="formula"><i>V</i> ⊆ <span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span> is the active variable set;
</li>
<li>
<span class="formula"><i>Y</i> ⊆ <span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span> is the set of available variables;
</li>
<li>
<span class="formula"><i>i</i></span> is an index belonging to <span class="formula"><span class="symbol">{</span>1, …, <i>n</i> + 1<span class="symbol">}</span></span>.
</li>

</ul>

</li>

</ul>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Definition">
<a class="Label" name="e-run"> </a>Given a string <span class="formula"><b>s</b> = <i>s</i><sub>1</sub>, …, <i>s</i><sub><i>n</i></sub></span> and an eVset-automaton <span class="formula"><i>A</i> = <span class="symbol">(</span><i>Q</i>, <i>q</i><sub>0</sub>, <i>q</i><sub><i>f</i></sub>, <i>δ</i><span class="symbol">)</span></span>, a run <span class="formula"><i>ρ</i></span> of <span class="formula"><i>A</i></span> on <span class="formula"><b>s</b></span> is a sequence <span class="formula"><i>c</i><sub>0</sub>, …, <i>c</i><sub><i>m</i></sub></span> of configurations, where:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>c</i><sub>0</sub> = <span class="symbol">(</span><i>q</i><sub>0</sub>, <span class="textrm"> Ø</span>, <span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span>, 1<span class="symbol">)</span></span>;
</li>
<li>
for <span class="formula"><i>j</i> = 0, …, <i>m</i> − 1</span> one of the following holds for <span class="formula"><i>c</i><sub><i>j</i></sub> = <span class="symbol">(</span><i>q</i><sub><i>j</i></sub>, <i>V</i><sub><i>j</i></sub>, <i>Y</i><sub><i>j</i></sub>, <i>i</i><sub><i>j</i></sub><span class="symbol">)</span></span> and <span class="formula"><i>c</i><sub><i>j</i> + 1</sub> = <span class="symbol">(</span><i>q</i><sub><i>j</i> + 1</sub>, <i>V</i><sub><i>j</i> + 1</sub>, <i>Y</i><sub><i>j</i> + 1</sub>, <i>i</i><sub><i>j</i> + 1</sub><span class="symbol">)</span></span>:\begin_inset Separator latexpar\end_inset<ul>
<li>
<span class="formula"><i>V</i><sub><i>j</i> + 1</sub> = <i>V</i><sub><i>j</i></sub></span>, <span class="formula"><i>Y</i><sub><i>j</i> + 1</sub> = <i>Y</i><sub><i>j</i></sub></span>, <span class="formula"><i>i</i><sub><i>j</i> + 1</sub> = <i>i</i><sub><i>j</i></sub> + 1</span> and <span class="formula"><span class="symbol">(</span><i>q</i><sub><i>j</i></sub>, <i>s</i><sub><i>j</i></sub><i>q</i><sub><i>j</i> + 1</sub><span class="symbol">)</span> ∈ <i>δ</i><sup><span class="textrm">char</span></sup></span>;
</li>
<li>
<span class="formula"><i>i</i><sub><i>j</i> + 1</sub> = <i>i</i><sub><i>j</i></sub></span>, and for some <span class="formula"><i>S</i> ⊆ <span class="textrm">SVOps</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span> we have :\begin_inset Separator latexpar\end_inset<ul>
<li>
for each <span class="formula"><i>x</i> ∈ <span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span>:\begin_inset Separator latexpar\end_inset<ul>
<li>
<span class="formula"><span class="symbol">{</span><i>x</i>⊢, ⊣<i>x</i><span class="symbol">}</span>∩<i>S</i> = <span class="symbol">{</span><i>x</i>⊢<span class="symbol">}</span></span> or <span class="formula"><span class="symbol">{</span><i>x</i>⊢, ⊣<i>x</i><span class="symbol">}</span>∩<i>S</i> = <span class="symbol">{</span><i>x</i>⊢, ⊣<i>x</i><span class="symbol">}</span></span> if and only if <span class="formula"><i>x</i> ∈ <i>Y</i><sub><i>j</i></sub></span>;
</li>
<li>
<span class="formula"><span class="symbol">{</span><i>x</i>⊢, ⊣<i>x</i><span class="symbol">}</span>∩<i>S</i> = <span class="symbol">{</span>⊣<i>x</i><span class="symbol">}</span></span> if and only if <span class="formula"><i>x</i> ∈ <i>V</i><sub><i>j</i></sub></span>;
</li>

</ul>

</li>
<li>
<span class="formula"><i>V</i><sub><i>j</i> + 1</sub> = <i>V</i><sub><i>j</i></sub>∪<span class="symbol">{</span><i>x</i>∣<i>x</i>⊢ ∈ <i>S</i><span class="symbol">}</span>∖<span class="symbol">{</span><i>x</i>∣⊣<i>x</i> ∈ <i>S</i><span class="symbol">}</span></span>;
</li>
<li>
<span class="formula"><i>Y</i><sub><i>j</i> + 1</sub> = <i>Y</i><sub><i>j</i></sub>∖<span class="symbol">{</span><i>x</i>∣<i>x</i>⊢ ∈ <i>S</i><span class="symbol">}</span></span>;
</li>
<li>
<span class="formula"><span class="symbol">(</span><i>q</i><sub><i>j</i></sub>, <i>S</i>, <i>q</i><sub><i>j</i> + 1</sub><span class="symbol">)</span> ∈ <i>δ</i><sup><span class="textrm">op</span></sup></span>.
</li>

</ul>

</li>

</ul>

</li>

</ul>

</li>

</ul>
<div class="Definition">
<span class="formula"><i>ρ</i></span> is accepting if <span class="formula"><i>c</i><sub><i>m</i></sub> = <span class="symbol">(</span><i>q</i><sub><i>f</i></sub>, <span class="textrm">Ø,</span><span class="textrm">Ø</span>, <i>n</i> + 1<span class="symbol">)</span></span>.
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Indented">
<span class="formula"><span class="textrm">ARuns</span><span class="symbol">(</span><i>A</i>, <b>s</b><span class="symbol">)</span></span> and <span class="formula"><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span></span>, for an eVset-automaton <span class="formula"><i>A</i></span> and a string <span class="formula"><b>s</b></span>, are defined in similar ways to those of usual vset-automata. This new kind vset-automata allows to perform an arbitrary number of variable operations in one transition. The operations in a transition are to be performed in a given order. The exact order isn’t very important, except for the fact that, in a valid run, the insertion and removal of a variable from the active variable set need to happen in the correct order (i.e. insertion first). 
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="fig:evset"> </a><div class="figure">
<span class="align-center"><span class="environment"><span class="arrayrow">
<span class="arraycell align-l">
[shorten
</span>
<span class="arraycell align-l">
gt; = 1pt, nodedistance = 3cm, ongrid, auto]<span class="unknown">\node</span>[state, initial](q<sub>0</sub>)q<sub>0</sub>;<span class="unknown">\node</span>[state](q<sub>1</sub>)[right = ofq<sub>0</sub>]q<sub>1</sub>;<span class="unknown">\node</span>[state](q<sub>2</sub>)[right = ofq<sub>1</sub>]q<sub>2</sub>;<span class="unknown">\node</span>[state, accepting](q<sub>3</sub>)[right = ofq<sub>2</sub>]q<sub>3</sub>;<span class="unknown">\path</span>[ − 
</span>
<span class="arraycell align-l">
gt;](q<sub>0</sub>)edgenode<span class="symbol">{</span>x⊢<span class="symbol">}</span>(q<sub>1</sub>)edge[loopabove]nodeΣ()(q<sub>1</sub>)edgenode<span class="symbol">{</span>y⊢<span class="symbol">}</span>(q<sub>2</sub>)edge[loopabove]nodea(q<sub>2</sub>)(q<sub>2</sub>)edgenode<span class="symbol">{</span>⊣x, ⊣y<span class="symbol">}</span>(q<sub>3</sub>)edge[loopabove]nodeb()(q<sub>3</sub>)edge[loopabove]nodeΣ();
</span>

</span>
</span></span><div class="caption">
Figure 4.1 An eVset-automaton <span class="formula"><i>A</i></span>.
</div>

</div>

</div>

</div>
<div class="Indented">
The reason for using eVset-automata instead of plain vset-automata will be clear in the next section. I now introduce some additional useful concepts, the most important of which being that of a <i>path</i> in an eVset-automaton.
</div>
<div class="Definition">
Given a transition <span class="formula"><i>t</i> ∈ <i>δ</i></span> in an eVset-automaton <span class="formula"><i>A</i></span>, and an ordering <span class="formula"><i>φ</i></span> on the elements of <span class="formula"><span class="textrm">SVOps</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span>, we define\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><span class="textrm">Ops</span><span class="symbol">(</span><i>t</i><span class="symbol">)</span></span>as either:\begin_inset Separator latexpar\end_inset<ul>
<li>
if <span class="formula"><i>t</i> = <span class="symbol">(</span><i>q</i>, <i>S</i>, <i>q</i>’<span class="symbol">)</span> ∈ <i>δ</i><sup><span class="textrm">op</span></sup></span>, the set <span class="formula"><i>S</i></span>;
</li>
<li>
if <span class="formula"><i>t</i> ∈ <i>δ</i><sup><span class="textrm">char</span></sup></span>, the empty set.
</li>

</ul>

</li>
<li>
<span class="formula"><span class="textrm">LOps</span><sub><i>φ</i></sub><span class="symbol">(</span><i>t</i><span class="symbol">)</span></span> as either:\begin_inset Separator latexpar\end_inset<ul>
<li>
if <span class="formula"><i>t</i> = <span class="symbol">(</span><i>q</i>, <i>S</i>, <i>q</i>’<span class="symbol">)</span> ∈ <i>δ</i><sup><span class="textrm">op</span></sup></span>, the list <span class="formula"><i>o</i><sub>1</sub>, …, <i>o</i><sub><span class="symbol">|</span><i>S</i><span class="symbol">|</span></sub></span> of operations belonging to <span class="formula"><i>S</i></span>, ordered according to <span class="formula"><i>φ</i></span>;
</li>
<li>
if <span class="formula"><i>t</i> ∈ <i>δ</i><sup><span class="textrm">char</span></sup></span>, the empty list.
</li>

</ul>

</li>

</ul>

</li>

</ul>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Definition">
Given an extended vset-automaton <span class="formula"><i>A</i> = <span class="symbol">(</span><i>Q</i>, <i>q</i><sub>0</sub>, <i>q</i><sub><i>f</i></sub>, <i>δ</i><span class="symbol">)</span></span> and a pair of states <span class="formula"><i>q</i>, <i>q</i>’ ∈ <i>Q</i></span>, a path <span class="formula"><i>p</i></span> between <span class="formula"><i>q</i></span> and <span class="formula"><i>q</i>’</span> in <span class="formula"><i>A</i></span> is a sequence of transitions <span class="formula"><i>t</i><sub>1</sub>, </span><span class="formula">…, <i>t</i><sub><i>n</i></sub> ∈ <i>δ</i></span>, such that:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
the source state of <span class="formula"><i>t</i><sub>1</sub></span> is <span class="formula"><i>q</i></span>;
</li>
<li>
the destination state of <span class="formula"><i>t</i><sub><i>n</i></sub></span> is <span class="formula"><i>q</i>’</span>;
</li>
<li>
for every pair <span class="formula"><i>t</i><sub><i>i</i></sub>, <i>t</i><sub><i>i</i> + 1</sub></span>, the destination state of <span class="formula"><i>t</i><sub><i>i</i></sub></span> equals the source state of <span class="formula"><i>t</i><sub><i>i</i> + 1</sub></span>.
</li>

</ul>

</li>

</ul>
<div class="Definition">
We also write <span class="formula"><i>p</i><sub><i>q</i></sub><sup><i>q</i>’</sup></span>. We refer to the set of paths in <span class="formula"><i>A</i></span> as <span class="formula"><span class="textrm">Paths</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span>.
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Indented">
A path in an eVset-automaton is closely related to a run, as formalized by the next definition.
</div>
<div class="Definition">
Given a string <span class="formula"><b>s</b></span>, an eVset-automaton <span class="formula"><i>A</i> = <span class="symbol">(</span><i>Q</i>, <i>q</i><sub>0</sub>, <i>q</i><sub><i>f</i></sub>, <i>δ</i><span class="symbol">)</span></span>, a run <span class="formula"><i>ρ</i> = <i>c</i><sub>0</sub>, </span><span class="formula">…, <i>c</i><sub><i>m</i></sub></span> of <span class="formula"><i>A</i></span> on <span class="formula"><b>s</b></span> and a path <span class="formula"><i>p</i> = <i>t</i><sub>0</sub>, …, <i>t</i><sub><i>m</i> − 1</sub></span> in <span class="formula"><i>A</i></span>, we say that <span class="formula"><i>p</i></span> supports <span class="formula"><i>ρ</i></span> if, for every pair <span class="formula"><i>c</i><sub><i>i</i></sub></span>, <span class="formula"><i>c</i><sub><i>i</i> + 1</sub></span> of configurations, <span class="formula"><i>c</i><sub><i>i</i> + 1</sub></span>is obtained from <span class="formula"><i>c</i><sub><i>i</i></sub></span> by applying <span class="formula"><i>t</i><sub><i>i</i></sub></span>, using the rules given in Definition <a class="Reference" href="#e-run">4.1↑</a>.
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Definition">
Given a path <span class="formula"><i>p</i> = <i>t</i><sub>1</sub>, …, <i>t</i><sub><i>n</i></sub></span> in an eVset-automaton <span class="formula"><i>A</i></span>, and considering an ordering <span class="formula"><i>φ</i></span> on the elements of <span class="formula"><span class="textrm">SVOps</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span>, we define\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
the set <span class="formula"><span class="textrm">Ops</span><span class="symbol">(</span><i>p</i><span class="symbol">)</span></span> as<div class="formula">
∪<sub><i>i</i> = 1</sub><sup><i>n</i></sup><span class="textrm">Ops</span><span class="symbol">(</span><i>t</i><sub><i>i</i></sub><span class="symbol">)</span>
</div>

</li>
<li>
the list <span class="formula"><span class="textrm">LOps</span><sub><i>φ</i></sub><span class="symbol">(</span><i>p</i><span class="symbol">)</span></span> as<div class="formula">
⊕<sub><i>i</i> = 1</sub><sup><i>n</i></sup><span class="textrm">LOps</span><sub><i>φ</i></sub><span class="symbol">(</span><i>t</i><sub><i>i</i></sub><span class="symbol">)</span>
</div>
where <span class="formula">⊕</span> is the usual list concatenation operator.
</li>

</ul>

</li>

</ul>
<div class="Definition">
If every transition in <span class="formula"><i>p</i></span> belongs to <span class="formula"><i>δ</i><sup><span class="textrm">op</span></sup></span>, we say that <span class="formula"><i>p</i></span> is an operation-only path.
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Indented">
From now on, without loss of generality, I consider a fixed order <span class="formula"><i>φ</i></span>, in which insertions come before deletions.
</div>
<div class="Indented">
<div class="defskip"> </div>
</div>
<div class="Indented">
As shown in the previous chapter, the class of vset-automata doesn’t get more expressive power when extended with the algebra<span class="formula"><span class="symbol">{</span>∪, <i>π</i>, ⋈<span class="symbol">}</span></span>. Hence, this class is a good candidate to be the base for a class of representations for the core spanners, as the Core Simplification Lemma suggests. In the following, I show that the same result holds for a subclass of extended vset-automata: <i>well-behaved eVset-automata</i>. Moreover, we will see that an AQL core fragment, as defined in <span class="bibcites">[<a class="bibliocite" name="cite-5" href="#biblio-5"><span class="bib-index">5</span></a>]</span>, can be converted into a well-behaved eVset-automaton. The runtime system implicitly assumes that any eVset-automaton it receives as input is well-behaved.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.2">4.2</a> Well-Behaved Extended Vset-Automata
</h2>
<div class="Unindented">
In order to be well-behaved, an eVset-automaton has to respect some constraints on its paths that are between its initial and accepting state. I call this kind of paths <i>complete paths.</i>
</div>
<div class="Definition">
Given an eVset-automaton <span class="formula"><i>A</i> = <span class="symbol">(</span><i>Q</i>, <i>q</i><sub>0</sub>, <i>q</i><sub><i>f</i></sub>, <i>δ</i><span class="symbol">)</span></span>, a path <span class="formula"><i>p</i> = <i>t</i><sub>1</sub>, …, <i>t</i><sub><i>n</i></sub></span> in <span class="formula"><i>A</i></span> is complete if it is between <span class="formula"><i>q</i><sub>0</sub></span> and <span class="formula"><i>q</i><sub><i>f</i></sub></span>, that is <span class="formula"><i>p</i> = <i>p</i><sub><i>q</i><sub>0</sub></sub><sup><i>q</i><sub><i>f</i></sub></sup></span>.
</div>
<div class="Unindented">
I now formally define a well-behaved eVset-automaton.
</div>
<div class="Definition">
<a class="Label" name="well-behaved"> </a>An eVset-automaton <span class="formula"><i>A</i></span> is well-behaved if, for every complete path <span class="formula"><i>p</i></span> in <span class="formula"><i>A</i></span> we have:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ol>
<li>
for every <span class="formula"><i>o</i> ∈ <span class="textrm">SVOps</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span>, <span class="formula"><i>o</i></span> appears exactly once in <span class="formula"><span class="textrm">LOps</span><span class="symbol">(</span><i>p</i><span class="symbol">)</span></span>;<a class="Label" name="enu:well-behaved-1,"> </a>
</li>
<li>
for every pair of operations <span class="formula"><i>x</i>⊢</span>,<span class="formula">⊣<i>x</i></span><span class="formula"> ∈ <span class="textrm">SVOps</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span>, <span class="formula"><i>x</i>⊢</span> appears before <span class="formula">⊣<i>x</i></span> in <span class="formula"><span class="textrm">LOps</span><span class="symbol">(</span><i>p</i><span class="symbol">)</span></span>.
</li>

</ol>

</li>

</ul>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Indented">
According to the definition, well-behaved eVset-automata guarantee that any of their complete paths will support a valid accepting run. Since states that cannot reach the final state, or that cannot be reached from the initial state, are not used in complete paths, we might want to consider only well-behaved eVset-automata where these states don’t exist.
</div>
<div class="Definition">
Given an eVset-automaton <span class="formula"><i>A</i></span>, <span class="formula"><i>A</i></span> is pruned if for every state <span class="formula"><i>q</i></span> in <span class="formula"><i>A</i></span>, there is a path from <span class="formula"><i>q</i><sub>0</sub></span> to <span class="formula"><i>q</i></span>, and a path from <span class="formula"><i>q</i></span> to <span class="formula"><i>q</i><sub><i>f</i></sub></span> in <span class="formula"><i>A</i></span>.
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Example">
The eVset automaton <span class="formula"><i>A</i></span> from Figure <a class="Reference" href="#fig:evset">4.1↑</a> and the eVset-automaton <span class="formula"><i>B</i></span> from Figure <a class="Reference" href="#evset-2">4.2↓</a> are well-behaved and pruned.
</div>
<div class="Unindented">
The next proposition tells us that the we can always prune a well-behaved eVset-automaton, obtaining a new eVset-automaton equivalent to the original.
</div>
<div class="Proposition">
Given a well-behaved eVset-automaton <span class="formula"><i>A</i></span>, there exists a pruned well-behaved eVset automaton <span class="formula"><i>A</i>’</span> such that <span class="formula"><span class="symbol">⟦</span><i>A</i>’<span class="symbol">⟧</span> = <span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span></span>. Moreover, <span class="formula"><i>A</i>’</span> can be produced in polynomial time.
</div>
<div class="Proof">
To obtain <span class="formula"><i>A</i>’</span>, it is sufficient to remove from <span class="formula"><i>A</i></span> those states from which we can’t reach the final state, those states that are unreachable from the initial state, and all the transitions that have them as source or destination states. To test each state for removal we can use, e. g., Dijkstra’s shortest path algorithm, which ensures <span class="formula"><i>A</i>’</span> can be found in polynomial time. Because of our construction, <span class="formula"><i>A</i>’</span> is well-behaved, as all its complete paths are also in <span class="formula"><i>A</i></span>. We now show that, for every string <span class="formula"><b>s</b>, </span> we have <span class="formula"><span class="symbol">⟦</span><i>A</i>’<span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span> = <span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span>. To see that <span class="formula"><span class="symbol">⟦</span><i>A</i>’<span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span> ⊆ <span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span>, we can notice that each run <span class="formula"><i>ρ</i>’</span> of <span class="formula"><i>A</i>’</span> on <span class="formula"><b>s</b></span> that is accepting can be supported only by a complete path <span class="formula"><i>p</i>’</span>, which is also in <span class="formula"><i>A</i></span> by construction. <span class="formula"><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span> ⊆ <span class="symbol">⟦</span><i>A</i>’<span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span> is true as well because we include in <span class="formula"><i>A</i>’</span> all the complete paths existing in <span class="formula"><i>A</i></span> so every run <span class="formula"><i>p</i></span> of <span class="formula"><i>A</i></span> on <span class="formula"><b>s</b></span> is also a run of <span class="formula"><i>A</i>’</span>.
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Indented">
If a well-behaved eVset-automaton is pruned, it automatically gets two other properties.
</div>
<div class="Corollary">
Given a pruned well-behaved eVset-automaton <span class="formula"><i>A</i></span>, for every path<span class="formula"><i>p</i></span> in <span class="formula"><i>A</i></span> <span class="formula"><span class="textrm">LOps</span><span class="symbol">(</span><i>p</i><span class="symbol">)</span></span> contains no duplicates.
</div>
<div class="Proof">
Since <span class="formula"><i>A</i></span> is pruned, <span class="formula"><i>p</i></span> is part of a complete path <span class="formula"><i>p</i>’</span>. But <span class="formula"><i>A</i></span> is also well-behaved, so <span class="formula"><span class="textrm">LOps</span><span class="symbol">(</span><i>p</i>’<span class="symbol">)</span></span> contains no duplicates, which implies that <span class="formula"><span class="textrm">LOps</span><span class="symbol">(</span><i>p</i><span class="symbol">)</span></span> has no duplicates either.
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Corollary">
<a class="Label" name="same-ops"> </a>Given a pruned well-behaved eVset-automaton <span class="formula"><i>A</i></span>, and two states <span class="formula"><i>q</i>, <i>q</i>’</span> in <span class="formula"><i>A</i></span>, for every pair of paths <span class="formula"><i>p</i>, <i>p</i>’</span> between <span class="formula"><i>q</i></span> and <span class="formula"><i>q</i>’</span> in <span class="formula"><i>A</i></span>, <span class="formula"><span class="textrm">Ops</span><span class="symbol">(</span><i>p</i><span class="symbol">)</span> = <span class="textrm">Ops</span><span class="symbol">(</span><i>p</i>’<span class="symbol">)</span></span>.
</div>
<div class="Proof">
Since <span class="formula"><i>A</i></span> is pruned, there surely exists a path <span class="formula"><i>p</i><sup>0</sup></span> between <span class="formula"><i>q</i><sub>0</sub></span> and <span class="formula"><i>q</i></span>. For the same reason, there exists a path <span class="formula"><i>p</i><sup><i>f</i></sup></span> between <span class="formula"><i>q</i>’</span> and <span class="formula"><i>q</i><sub><i>f</i></sub></span>. So <span class="formula"><i>q</i></span> and <span class="formula"><i>q</i>’</span> appear in two complete paths, which we may call <span class="formula"><i>p</i><sup>0</sup><i>pp</i><sup><i>f</i></sup></span> and <span class="formula"><i>p</i><sup>0</sup><i>p</i>’<i>p</i><sup><i>f</i></sup></span>, that differ only in the subpaths between <span class="formula"><i>q</i></span> and <span class="formula"><i>q</i>’</span>. If <span class="formula"><span class="textrm">Ops</span><span class="symbol">(</span><i>p</i><span class="symbol">)</span> ≠ <span class="textrm">Ops</span><span class="symbol">(</span><i>p</i>’<span class="symbol">)</span></span>, then one of <span class="formula"><i>p</i><sup>0</sup><i>pp</i><sup><i>f</i></sup></span> and <span class="formula"><i>p</i><sup>0</sup><i>p</i>’<i>p</i><sup><i>f</i></sup></span> wouldn’t satisfy the requirement <a class="Reference" href="#enu:well-behaved-1,">4.2↑</a> of <a class="Reference" href="#well-behaved">4.2↑</a>, making <span class="formula"><i>A</i></span> not well-behaved, a contraddiction.
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Indented">
<div class="defskip"> </div>
</div>
<div class="Indented">
In the following, I describe the constructions that I use in my system to support algebraic operations with well-behaved eVset-automata. The main advantage of these constructions is that they produce a well-behaved eVset-automaton whose size is <i>polynomial</i> in the size of the input automaton/a. Let us start with projection.
</div>
<div class="Indented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Theorem">
<a class="Label" name="ext-proj"> </a>Given a well-behaved eVset-automaton <span class="formula"><i>A</i></span>, the set <span class="formula"><i>X</i> = <span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span> and a set <span class="formula"><i>Y</i> ⊆ <i>X</i></span>, a well behaved eVset-automaton <span class="formula"><i>A</i>’</span> can be produced in linear time such that <span class="formula"><span class="symbol">⟦</span><i>A</i>’<span class="symbol">⟧</span> = <i>π</i><sub><i>Y</i></sub><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span></span>.
</div>
<div class="Proof">
Let us consider <span class="formula"><i>A</i> = <span class="symbol">(</span><i>Q</i>, <i>q</i><sub>0</sub>, <i>q</i><sub><i>f</i></sub>, <i>δ</i><span class="symbol">)</span></span>. We can take <span class="formula"><i>A</i>’ = <span class="symbol">(</span><i>Q</i>’, <i>q</i><sub>0</sub>’, <i>q</i><sub><i>f</i></sub>’, <i>δ</i>’<span class="symbol">)</span></span>, where:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>Q</i>’ = <i>Q</i></span>;
</li>
<li>
<span class="formula"><i>q</i><sub>0</sub>’ = <i>q</i><sub>0</sub></span>;
</li>
<li>
<span class="formula"><i>q</i><sub><i>f</i></sub>’ = <i>q</i><sub><i>f</i></sub></span>;
</li>
<li>
<span class="formula"><i>δ</i>’ = <span class="symbol">(</span><i>δ</i>∖<i>δ</i><sup><span class="textrm">unprojected</span></sup><span class="symbol">)</span>∪<i>δ</i><sup><span class="textrm">projected</span></sup></span>, where:\begin_inset Separator latexpar\end_inset<ul>
<li>
<span class="formula"><i>δ</i><sup><span class="textrm">unprojected</span></sup> = <span class="symbol">{</span><span class="symbol">(</span><i>q</i>, <i>S</i>, <i>q</i>’<span class="symbol">)</span> ∈ <i>δ</i>∣<i>S</i>∩<span class="textrm">SVOps</span><span class="symbol">(</span><i>X</i>∖<i>Y</i><span class="symbol">)</span> ≠ <span class="textrm">Ø</span><span class="symbol">}</span></span>;
</li>
<li>
<span class="formula"><i>δ</i><sup><span class="textrm">projected</span></sup> = <span class="symbol">{</span><span class="symbol">(</span><i>q</i>, <i>S</i>’, <i>q</i>’<span class="symbol">)</span>∣∃<span class="symbol">(</span><i>q</i>, <i>S</i>, <i>q</i>’<span class="symbol">)</span> ∈ <i>δ</i><sup><span class="textrm">unprojected</span></sup>:<i>S</i>’ = <i>S</i>∖<span class="textrm">SVOps</span><span class="symbol">(</span><i>X</i>∖<i>Y</i><span class="symbol">)</span><span class="symbol">}</span></span>.
</li>

</ul>

</li>

</ul>

</li>

</ul>
<div class="Proof">
This construction removes all the occurencies of variable operations concerning variables excluded from the projection from the transitions of <span class="formula"><i>A</i></span>. <span class="formula"><i>A</i>’</span> is still well-behaved, since we maintain the occurrencies of operations concerning the variables on which we project, that continue to appear exactly once on each path, and in the right order. Assuming the size of <span class="formula"><i>A</i></span>, that we may call <span class="formula"><i>n</i></span>, as the sum of the sizes of <span class="formula"><i>Q</i></span>, <span class="formula"><i>δ</i></span> and <span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span>, it is easy to verify that this construction can be carried out in <span class="formula"><i>O</i><span class="symbol">(</span><i>n</i><span class="symbol">)</span></span>. Let us show that <span class="formula"><span class="symbol">⟦</span><i>A</i>’<span class="symbol">⟧</span> = <i>π</i><sub><i>Y</i></sub><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span></span>. Notice that given a string <span class="formula"><b>s</b></span>, for each accepting run <span class="formula"><i>ρ</i></span> of <span class="formula"><i>A</i></span> on <span class="formula"><b>s</b></span>, producing an <span class="formula"><b>s</b></span>-tuple <span class="formula"><i>μ</i></span>, there is an accepting run <span class="formula"><i>ρ</i>’</span> of <span class="formula"><i>A</i>’</span> that produces an <span class="formula"><b>s</b></span>-tuple <span class="formula"><i>μ</i>’</span>, which assigns the same spans as <span class="formula"><i>μ</i></span> to the variables in common with <span class="formula"><i>μ</i>’</span>, which by construction belong to <span class="formula"><i>Y</i></span>. The path <span class="formula"><i>p</i>’</span> supporting <span class="formula"><i>ρ</i>’</span> is exactly the path obtained by modifying the path <span class="formula"><i>p</i></span>, that supports <span class="formula"><i>ρ</i></span>, by eliminating the operations on unprojected variables. This shows that <span class="formula"><i>π</i><sub><i>Y</i></sub><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span> ⊆ <span class="symbol">⟦</span><i>A</i>’<span class="symbol">⟧</span></span>. It must also be that <span class="formula"><span class="symbol">⟦</span><i>A</i>’<span class="symbol">⟧</span> ⊆ <i>π</i><sub><i>Y</i></sub><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span></span>, because no additional complete paths were added to <span class="formula"><i>A</i>’</span>.
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Indented">
A similar result holds for the union operation.
</div>
<div class="Indented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Theorem">
<a class="Label" name="ext-union"> </a>Given two well-behaved eVset-automata <span class="formula"><i>A</i></span> and <span class="formula"><i>B</i></span> that are union-compatible, a third well-behaved eVset-automaton <span class="formula"><i>C</i></span> can be produced in linear time such that <span class="formula"><span class="symbol">⟦</span><i>C</i><span class="symbol">⟧</span> = <span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span>∪<span class="symbol">⟦</span><i>B</i><span class="symbol">⟧</span></span>.
</div>
<div class="Proof">
Let us consider <span class="formula"><i>A</i></span> to be of the form <span class="formula"><span class="symbol">(</span><i>Q</i><sup><i>A</i></sup>, <i>q</i><sub>0</sub><sup><i>A</i></sup>, <i>q</i><sub><i>f</i></sub><sup><i>A</i></sup>, <i>δ</i><sup><i>A</i></sup><span class="symbol">)</span></span> and <span class="formula"><i>B</i></span> of the form <span class="formula"><span class="symbol">(</span><i>Q</i><sup><i>B</i></sup>, <i>q</i><sub>0</sub><sup><i>B</i></sup>, <i>q</i><sub><i>f</i></sub><sup><i>B</i></sup>, <i>δ</i><sup><i>B</i></sup><span class="symbol">)</span></span>. We can take <span class="formula"><i>C</i> = <span class="symbol">(</span><i>Q</i><sup><i>C</i></sup>, <i>q</i><sub>0</sub><sup><i>C</i></sup>, <i>q</i><sub><i>f</i></sub><sup><i>C</i></sup>, <i>δ</i><sup><i>C</i></sup><span class="symbol">)</span></span>, where:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>Q</i><sup><i>C</i></sup> = <i>Q</i><sup><i>A</i></sup>∪<i>Q</i><sup><i>B</i></sup>∪<span class="symbol">{</span><i>q</i><sub>0</sub><sup><i>C</i></sup>, <i>q</i><sub><i>f</i></sub><sup><i>C</i></sup><span class="symbol">}</span></span>;
</li>
<li>
<span class="formula"><i>δ</i><sup><i>C</i></sup> = <i>δ</i><sup><i>A</i></sup>∪<i>δ</i><sup><i>B</i></sup>∪<span class="symbol">{</span><span class="symbol">(</span><i>q</i><sub>0</sub><sup><i>C</i></sup>, <span class="textrm">Ø</span>, <i>q</i><sub>0</sub><sup><i>B</i></sup><span class="symbol">)</span>, <span class="symbol">(</span><i>q</i><sub><i>f</i></sub><sup><i>B</i></sup>, <span class="textrm">Ø</span>, <i>q</i><sub><i>f</i></sub><sup><i>C</i></sup><span class="symbol">)</span>, <span class="symbol">(</span><i>q</i><sub>0</sub><sup><i>C</i></sup>, <span class="textrm">Ø</span>, <i>q</i><sub>0</sub><sup><i>A</i></sup><span class="symbol">)</span>, <span class="symbol">(</span><i>q</i><sub><i>f</i></sub><sup><i>A</i></sup>, <span class="textrm">Ø</span>, <i>q</i><sub><i>f</i></sub><sup><i>C</i></sup><span class="symbol">)</span><span class="symbol">}</span></span>.
</li>

</ul>

</li>

</ul>
<div class="Proof">
In this construction, we allow to go from the initial state of <span class="formula"><i>C</i></span> to the initial state of either <span class="formula"><i>A</i></span> or <span class="formula"><i>B</i></span>, and to go from the accepting state of <span class="formula"><i>A</i></span> or that of <span class="formula"><i>B</i></span> to the one of <span class="formula"><i>C</i></span>, without any new variable operations. Thus, given a string <span class="formula"><b>s</b></span>, <span class="formula"><i>C</i></span> can span exactly the <span class="formula"><b>s</b> − </span>tuples contained in <span class="formula"><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span>∪<span class="symbol">⟦</span><i>B</i><span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span>. Regarding the complexity of the construction, the operations that we perform here are the union of the states sets and transition functions, with the addition of a fixed number of new transitions and states. Let us consider the size of the input as <span class="formula"><i>n</i> = <i>n</i><sub><i>A</i></sub> + <i>n</i><sub><i>B</i></sub> = <span class="symbol">|</span><i>Q</i><sup><i>A</i></sup><span class="symbol">|</span> + <span class="symbol">|</span><i>δ</i><sup><i>A</i></sup><span class="symbol">|</span> + <span class="symbol">|</span><span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span><span class="symbol">|</span> + <span class="symbol">|</span><i>Q</i><sup><i>B</i></sup><span class="symbol">|</span> + <span class="symbol">|</span><i>δ</i><sup><i>B</i></sup><span class="symbol">|</span> + <span class="symbol">|</span><span class="textrm">SVars</span><span class="symbol">(</span><i>B</i><span class="symbol">)</span><span class="symbol">|</span></span>. If we assume the costs of basic operations, as adding/deleting a state/transitions, to be constant, then obtaining <span class="formula"><i>Q</i><sup><i>C</i></sup></span> takes <span class="formula"><i>O</i><span class="symbol">(</span><span class="symbol">|</span><i>Q</i><sup><i>B</i></sup><span class="symbol">|</span><span class="symbol">)</span> = <i>O</i><span class="symbol">(</span><i>n</i><span class="symbol">)</span></span> time, and constructing <span class="formula"><i>δ</i><sup><i>C</i></sup></span> takes <span class="formula"><i>O</i><span class="symbol">(</span><span class="symbol">|</span><i>δ</i><sup><i>B</i></sup><span class="symbol">|</span><span class="symbol">)</span> = <i>O</i><span class="symbol">(</span><i>n</i><span class="symbol">)</span></span> time.
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Indented">
In order to show that we can obtain the natural join of two spanners, represented by well-behaved eVset-automata, so that the size of the correspondent resulting eVset-automaton is polynomial in the size of the input automata, we need a few more steps with respect to the previous cases. The construction that I present is conceptually very similar to that described in <span class="bibcites">[<a class="bibliocite" name="cite-5" href="#biblio-5"><span class="bib-index">5</span></a>]</span> for the natural join of plain vset-automata. That construction simulates running the input automata in parallel, making sure that operations on common variables are performed simultaneously. Unfortunately this doesn’t work in general, as the next example shows.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="evset-2"> </a><div class="figure">
<span class="align-center"><span class="environment"><span class="arrayrow">
<span class="arraycell align-l">
[shorten
</span>
<span class="arraycell align-l">
gt; = 1pt, nodedistance = 3cm, ongrid, auto]<span class="unknown">\node</span>[state, initial](q<sub>0</sub>)q<sub>0</sub>;<span class="unknown">\node</span>[state](q<sub>1</sub>)[right = ofq<sub>0</sub>]q<sub>1</sub>;<span class="unknown">\node</span>[state](q<sub>2</sub>)[right = ofq<sub>1</sub>]q<sub>2</sub>;<span class="unknown">\node</span>[state, accepting](q<sub>3</sub>)[right = ofq<sub>2</sub>]q<sub>3</sub>;<span class="unknown">\path</span>[ − 
</span>
<span class="arraycell align-l">
gt;](q<sub>0</sub>)edgenode<span class="symbol">{</span>y⊢<span class="symbol">}</span>(q<sub>1</sub>)edge[loopabove]nodeΣ()(q<sub>1</sub>)edgenode<span class="symbol">{</span>x⊢<span class="symbol">}</span>(q<sub>2</sub>)edge[loopabove]nodea(q<sub>2</sub>)(q<sub>2</sub>)edgenode<span class="symbol">{</span>⊣x, ⊣y<span class="symbol">}</span>(q<sub>3</sub>)edge[loopabove]nodeb()(q<sub>3</sub>)edge[loopabove]nodeΣ();
</span>

</span>
</span></span><div class="caption">
Figure 4.2 An eVset-automaton <span class="formula"><i>B</i></span>.
</div>

</div>

</div>

</div>
<div class="Example">
Consider the eVset-automaton <span class="formula"><i>A</i></span> from Figure <a class="Reference" href="#fig:evset">4.1↑</a>, the eVset-automaton <span class="formula"><i>B</i></span> from Figure <a class="Reference" href="#evset-2">4.2↑</a> and the string <span class="formula"><b>s</b> = </span>’b’. <span class="formula"><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span> contains the <span class="formula"><b>s</b></span>-tuple <span class="formula"><i>μ</i></span> such that <span class="formula"><i>μ</i><span class="symbol">(</span><i>x</i><span class="symbol">)</span> = <span class="symbol">[</span>0, 0<span class="symbol">⟩</span></span> and <span class="formula"><i>μ</i><span class="symbol">(</span><i>y</i><span class="symbol">)</span> = <span class="symbol">[</span>0, 1<span class="symbol">⟩</span></span>. We also have that <span class="formula"><i>μ</i> ∈ <span class="symbol">⟦</span><i>B</i><span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span>. If we attempt to run <span class="formula"><i>A</i></span> and <span class="formula"><i>B</i></span> in parallel on <span class="formula"><b>s</b></span>, we won’t be able to span <span class="formula"><i>μ</i></span> because the two automata disagree on the order of the operations <span class="formula"><i>x</i>⊢</span> and <span class="formula"><i>y</i>⊢</span>. Thus, we don’t get <span class="formula"><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span>⋈<span class="symbol">⟦</span><i>B</i><span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span> as a result of the execution.
</div>
<div class="Unindented">
For the construction to work, the input automata must be modified in some way. In my system, I convert them into a particular form of eVset-automata, that I call <i>operation-closed</i>. The resulting automata have generally bigger size of the originals, but still they allow to keep the size of the result of the join construction to be polynomial in the size of the input. The definition of an operation-closed eVset-automaton follows.
</div>
<div class="Definition">
Given a eVset-automaton <span class="formula"><i>A</i></span>, <span class="formula"><i>A</i></span> is operation-closed if, for every pair of states <span class="formula"><i>q</i>, <i>q</i>’</span> in <span class="formula"><i>A</i></span>, whenever there exists an operation-only path <span class="formula"><i>p</i></span>=<span class="formula"><i>t</i><sub>1</sub>, …, <i>t</i><sub><i>n</i></sub></span> between <span class="formula"><i>q</i></span> and <span class="formula"><i>q</i>’</span>, then there exists a transition in <span class="formula"><i>A</i></span> of the form <span class="formula"><span class="symbol">(</span><i>q</i>, ∪<sub><i>i</i> = 1</sub><sup><i>n</i></sup><span class="textrm">Ops</span><span class="symbol">(</span><i>t</i><sub><i>i</i></sub><span class="symbol">)</span>, <i>q</i>’<span class="symbol">)</span></span>.
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Indented">
As the next proposition states, given a well-behaved eVset-automaton, we can always find an equivalent operation-closed well-behaved eVset-automaton, whose size is polynomial in the size of the original. This ensures the applicability of the join construction.
</div>
<div class="Proposition">
<a class="Label" name="well-b-to-op-clos"> </a>Given a well-behaved eVset-automaton <span class="formula"><i>A</i></span>, there exists an operation-closed well-behaved eVset-automaton <span class="formula"><i>A</i>’</span> such that <span class="formula"><span class="symbol">⟦</span><i>A</i>’<span class="symbol">⟧</span> = <span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span></span>. Moreover, the size of <span class="formula"><i>A</i>’</span> is cubic in the size of <span class="formula"><i>A</i></span>.
</div>
<div class="Proof">
Let us consider <span class="formula"><i>A</i></span> to be of the form <span class="formula"><span class="symbol">(</span><i>Q</i>, <i>q</i><sub>0</sub>, <i>q</i><sub><i>f</i></sub>, <i>δ</i><span class="symbol">)</span></span>. Without loss of generality, we can assume that <span class="formula"><i>A</i></span> is pruned. Then we can take <span class="formula"><i>A</i>’ = <span class="symbol">(</span><i>Q</i>’, <i>q</i><sub>0</sub>’, <i>q</i><sub><i>f</i></sub>’, <i>δ</i>’<span class="symbol">)</span></span>, where:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>Q</i>’ = <i>Q</i></span>;
</li>
<li>
<span class="formula"><i>q</i><sub>0</sub>’ = <i>q</i><sub>0</sub></span>;
</li>
<li>
<span class="formula"><i>q</i><sub><i>f</i></sub>’ = <i>q</i><sub><i>f</i></sub></span>;
</li>
<li>
<span class="formula"><i>δ</i>’ = <i>δ</i>∪<span class="symbol">{</span><span class="symbol">(</span><i>q</i>, ∪<sub><i>i</i> = 1</sub><sup><i>n</i></sup><span class="textrm">Ops</span><span class="symbol">(</span><i>t</i><sub><i>i</i></sub><span class="symbol">)</span>, <i>q</i>’<span class="symbol">)</span>∣∃<i>p</i> = <i>t</i><sub>1</sub>, …, <i>t</i><sub><i>n</i></sub> ∈ <span class="textrm">Paths</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span>:<i>p</i> = <i>p</i><sub><i>q</i></sub><sup><i>q</i>’</sup><span class="textrm">, <span class="ensuremath">p</span>is operation-only</span><span class="symbol">}</span></span>.
</li>

</ul>

</li>

</ul>
<div class="Proof">
This construction does nothing but including in <span class="formula"><i>A</i>’</span> the transitions that are missing in <span class="formula"><i>A</i></span> to be operation-closed . We now show that, for every string <span class="formula"><b>s</b> ∈ <i>Σ</i><sup>∗</sup></span>, <span class="formula"><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span>’<span class="symbol">(</span><b>s</b><span class="symbol">)</span> = <span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span>. To see that <span class="formula"><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span>’<span class="symbol">(</span><b>s</b><span class="symbol">)</span> ⊆ <span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span>, consider an accepting run <span class="formula"><i>ρ</i>’</span> of <span class="formula"><i>A</i>’</span> on <span class="formula"><b>s</b></span>, that returns an <span class="formula"><b>s</b></span>-tuple <span class="formula"><i>μ</i></span>. This run is supported by a complete path <span class="formula"><i>p</i>’</span> in <span class="formula"><i>A</i>’</span>. We can always find a complete path <span class="formula"><i>p</i></span> in <span class="formula"><i>A</i></span> that supports a run <span class="formula"><i>ρ</i></span> of <span class="formula"><i>A</i></span> on <span class="formula"><b>s</b></span>, which returns <span class="formula"><i>μ</i></span> as well. To obtain <span class="formula"><i>p</i></span>, we substitute every operations transition <span class="formula"><i>t</i></span> in <span class="formula"><i>p</i>’</span> that doesn’t belong to <span class="formula"><i>δ</i></span> with a operation-only path <span class="formula"><i>p</i>’’</span> in <span class="formula"><i>A</i></span> such that <span class="formula"><span class="textrm">LOps</span><span class="symbol">(</span><i>p</i>’’<span class="symbol">)</span> = <span class="textrm">LOps</span><span class="symbol">(</span><i>t</i><span class="symbol">)</span></span> and <span class="formula"><i>p</i>’’</span> is between the source and destination states of <span class="formula"><i>t</i></span>. This is always possible by construction of <span class="formula"><i>A</i>’</span>. It is easy to verify that the run <span class="formula"><i>ρ</i></span> of <span class="formula"><i>A</i></span> on <span class="formula"><b>s</b></span>, supported by <span class="formula"><i>p</i></span>, returns indeed <span class="formula"><i>μ</i></span>. <span class="formula"><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span> ⊆ <span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span>’<span class="symbol">(</span><b>s</b><span class="symbol">)</span></span> is also true, because we include all the transitions belonging to <span class="formula"><i>δ</i></span> in <span class="formula"><i>δ</i>’</span>. The fact that the size of <span class="formula"><i>A</i>’</span> is cubic in the size of <span class="formula"><i>A</i></span> follows from the fact that we add <span class="formula"><i>O</i><span class="symbol">(</span><span class="symbol">|</span><i>Q</i><sup>2</sup><span class="symbol">|</span><span class="symbol">)</span></span> new transitions of size <span class="formula"><i>O</i><span class="symbol">(</span><span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span><span class="symbol">)</span></span> to <span class="formula"><i>δ</i></span> to form <span class="formula"><i>δ</i>’</span>.
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Indented">
This construction is the reason why extended vset-automata were used for the runtime system instead of plain vset-automata. When we construct an operation-closed automaton, starting from an automaton that does not have this property, the size of the resulting transition function is likely to explode (although it will stay polynomial in the size of the original automaton). The ability of performing multiple variable operations in a single transition allows for a more compact representation, that is also easier to manipulate. I now present a product construction that simulates running two operation-closed well-behaved eVset-automata in parallel. Notice that we need the input automata to be operation-closed, in order for the construction to give correct results.
</div>
<div class="Definition">
Given two well-behaved operation-closed eVset-automata <span class="formula"><i>A</i> = <span class="symbol">(</span><i>Q</i><sub><i>A</i></sub>, <i>q</i><sub><i>A</i></sub><sup>0</sup>, <i>q</i><sub><i>A</i></sub><sup><i>f</i></sup>, <i>δ</i><sub><i>A</i></sub><span class="symbol">)</span></span> and <span class="formula"><i>B</i> = <span class="symbol">(</span><i>Q</i><sub><i>B</i></sub>, <i>q</i><sub><i>B</i></sub><sup>0</sup>, <i>q</i><sub><i>B</i></sub><sup><i>f</i></sup>, <i>δ</i><sub><i>B</i></sub><span class="symbol">)</span></span>, their product is a eVset-automaton <span class="formula"><i>C</i> = <span class="symbol">(</span><i>Q</i>, <i>q</i><sup>0</sup>, <i>q</i><sup><i>f</i></sup>, <i>δ</i><span class="symbol">)</span></span>, where:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>Q</i> = <i>Q</i><sub><i>A</i></sub> × <i>Q</i><sub><i>B</i></sub></span>;
</li>
<li>
<span class="formula"><i>q</i><sup>0</sup> = <span class="symbol">⟨</span><i>q</i><sub><i>A</i></sub><sup>0</sup>, <i>q</i><sub><i>B</i></sub><sup>0</sup><span class="symbol">⟩</span></span>;
</li>
<li>
<span class="formula"><i>q</i><sup><i>f</i></sup> = <span class="symbol">⟨</span><i>q</i><sub><i>A</i></sub><sup><i>f</i></sup>, <i>q</i><sub><i>B</i></sub><sup><i>f</i></sup><span class="symbol">⟩</span></span>;
</li>
<li>
<span class="formula"><i>δ</i></span> has the following transitions:\begin_inset Separator latexpar\end_inset<ul>
<li>
<span class="formula"><span class="symbol">(</span><span class="symbol">⟨</span><i>q</i><sub><i>A</i></sub>, <i>q</i><sub><i>B</i></sub><span class="symbol">⟩</span>, <i>σ</i>, <span class="symbol">⟨</span><i>q</i>’<sub><i>A</i></sub>, <i>q</i>’<sub><i>B</i></sub><span class="symbol">⟩</span><span class="symbol">)</span></span> whenever <span class="formula"><i>σ</i> ∈ <i>Σ</i></span>, <span class="formula"><span class="symbol">(</span><i>q</i><sub><i>A</i></sub>, <i>σ</i>, <i>q</i>’<sub><i>A</i></sub><span class="symbol">)</span> ∈ <i>δ</i><sub><i>A</i></sub></span> and <span class="formula"><span class="symbol">(</span><i>q</i><sub><i>B</i></sub>, <i>σ</i>, <i>q</i>’<sub><i>B</i></sub><span class="symbol">)</span> ∈ <i>δ</i><sub><i>B</i></sub></span>;
</li>
<li>
<span class="formula"><span class="symbol">(</span><span class="symbol">⟨</span><i>q</i><sub><i>A</i></sub>, <i>q</i><sub><i>B</i></sub><span class="symbol">⟩</span>, <i>S</i><sub><i>A</i></sub>∪<i>S</i><sub><i>B</i></sub>, <span class="symbol">⟨</span><i>q</i>’<sub><i>A</i></sub>, <i>q</i>’<sub><i>B</i></sub><span class="symbol">⟩</span><span class="symbol">)</span></span> whenever <span class="formula"><span class="symbol">(</span><i>q</i><sub><i>A</i></sub>, <i>S</i><sub><i>A</i></sub>, <i>q</i>’<sub><i>A</i></sub><span class="symbol">)</span> ∈ <i>δ</i><sub><i>A</i></sub></span>, <span class="formula"><span class="symbol">(</span><i>q</i><sub><i>B</i></sub>, <i>S</i><sub><i>B</i></sub>, <i>q</i>’<sub><i>B</i></sub><span class="symbol">)</span> ∈ <i>δ</i><sub><i>B</i></sub></span> and <span class="formula"><span class="symbol">(</span><span class="textrm">SVOps</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span>∩<span class="textrm">SVOps</span><span class="symbol">(</span><i>B</i><span class="symbol">)</span><span class="symbol">)</span>∩<i>S</i><sub><i>A</i></sub> = <span class="symbol">(</span><span class="textrm">SVOps</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span>∩<span class="textrm">SVOps</span><span class="symbol">(</span><i>B</i><span class="symbol">)</span><span class="symbol">)</span>∩<i>S</i><sub><i>B</i></sub></span>;
</li>
<li>
<span class="formula"><span class="symbol">(</span><span class="symbol">⟨</span><i>q</i><sub><i>A</i></sub>, <i>q</i><sub><i>B</i></sub><span class="symbol">⟩</span>, <i>S</i><sub><i>A</i></sub>, <span class="symbol">⟨</span><i>q</i>’<sub><i>A</i></sub>, <i>q</i><sub><i>B</i></sub><span class="symbol">⟩</span><span class="symbol">)</span></span> whenever <span class="formula"><span class="symbol">(</span><i>q</i><sub><i>A</i></sub>, <i>S</i><sub><i>A</i></sub>, <i>q</i>’<sub><i>A</i></sub><span class="symbol">)</span> ∈ <i>δ</i><sub><i>A</i></sub></span> and <span class="formula"><span class="symbol">(</span><span class="textrm">SVOps</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span>∩<span class="textrm">SVOps</span><span class="symbol">(</span><i>B</i><span class="symbol">)</span><span class="symbol">)</span>∩<i>S</i><sub><i>A</i></sub> = <span class="textrm">Ø</span></span>;
</li>
<li>
<span class="formula"><span class="symbol">(</span><span class="symbol">⟨</span><i>q</i><sub><i>A</i></sub>, <i>q</i><sub><i>B</i></sub><span class="symbol">⟩</span>, <i>S</i><sub><i>B</i></sub>, <span class="symbol">⟨</span><i>q</i><sub><i>A</i></sub>, <i>q</i>’<sub><i>B</i></sub><span class="symbol">⟩</span><span class="symbol">)</span></span> whenever <span class="formula"><span class="symbol">(</span><i>q</i><sub><i>B</i></sub>, <i>S</i><sub><i>B</i></sub>, <i>q</i>’<sub><i>B</i></sub><span class="symbol">)</span> ∈ <i>δ</i><sub><i>B</i></sub></span> and <span class="formula"><span class="symbol">(</span><span class="textrm">SVOps</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span>∩<span class="textrm">SVOps</span><span class="symbol">(</span><i>B</i><span class="symbol">)</span><span class="symbol">)</span>∩<i>S</i><sub><i>B</i></sub> = <span class="textrm">Ø</span></span>.
</li>

</ul>

</li>

</ul>

</li>

</ul>
<div class="Definition">
We may write <span class="formula"><i>C</i> = <i>A</i> × <i>B</i></span>.
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Indented">
We can now state the following theorem.
</div>
<div class="Theorem">
<a class="Label" name="ext-join"> </a>Given two well-behaved eVset-automata <span class="formula"><i>A</i></span> and <span class="formula"><i>B</i></span>, and given an eVset-automaton <span class="formula"><i>C</i></span> such that <span class="formula"><i>C</i> = <i>A</i> × <i>B</i></span>, then <span class="formula"><span class="symbol">⟦</span><i>C</i><span class="symbol">⟧</span> = <span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span>⋈<span class="symbol">⟦</span><i>B</i><span class="symbol">⟧</span></span>. Moreover, the size of <span class="formula"><i>C</i></span> is polynomial in the size of <span class="formula"><i>A</i></span> and <span class="formula"><i>B</i></span>.
</div>
<div class="Proof">
This proof is similar to the proof for the analogue construction for plain vset-automata in <span class="bibcites">[<a class="bibliocite" name="cite-5" href="#biblio-5"><span class="bib-index">5</span></a>]</span>. Without loss of generality, we can assume that <span class="formula"><i>A</i></span> and <span class="formula"><i>B</i></span> are operation closed. If this was not the case, we could always obtain equivalent automata that are operation closed, in polynomial time, because of Proposition <a class="Reference" href="#well-b-to-op-clos">4.2↑</a>. To show that <span class="formula"><span class="symbol">⟦</span><i>C</i><span class="symbol">⟧</span> ⊆ <span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span>⋈<span class="symbol">⟦</span><i>B</i><span class="symbol">⟧</span></span>, we can decompose a run of <span class="formula"><i>C</i></span> on a string <span class="formula"><b>s</b></span> into two consistent runs of <span class="formula"><i>ρ</i><sub><i>A</i></sub></span> of <span class="formula"><i>A</i></span> and <span class="formula"><i>ρ</i><sub><i>B</i></sub></span> of <span class="formula"><i>B</i></span>. Two runs <span class="formula"><i>ρ</i></span>, <span class="formula"><i>ρ</i>’</span>, with supporting paths <span class="formula"><i>p</i></span> and <span class="formula"><i>p</i>’</span> respectively, are consistent with each other if, for every pair of operations <span class="formula"><i>o</i>, <i>o</i>’</span> belonging both to <span class="formula"><span class="textrm">Ops</span><span class="symbol">(</span><i>p</i><span class="symbol">)</span></span> and <span class="formula"><span class="textrm">Ops</span><span class="symbol">(</span><i>p</i>’<span class="symbol">)</span></span>, <span class="formula"><i>o</i></span> appears before <span class="formula"><i>o</i>’</span> in <span class="formula"><span class="textrm">LOps</span><span class="symbol">(</span><i>p</i><span class="symbol">)</span></span> if and only if the same holds in <span class="formula"><span class="textrm">LOps</span><span class="symbol">(</span><i>p</i>’<span class="symbol">)</span></span>. Since a run of <span class="formula"><i>C</i></span> represents two parallel runs of <span class="formula"><i>A</i></span> and <span class="formula"><i>B</i></span> by construction, the decomposition aims to isolate the two individual runs of <span class="formula"><i>A</i></span> and <span class="formula"><i>B</i></span>. The details of this decomposition are not difficult to figure out, and are omitted. To show that <span class="formula"><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span>⋈<span class="symbol">⟦</span><i>B</i><span class="symbol">⟧</span> ⊆ <span class="symbol">⟦</span><i>C</i><span class="symbol">⟧</span></span>, consider a string <span class="formula"><b>s</b></span>, a <span class="formula"><b>s</b></span>-tuple <span class="formula"><i>μ</i><sub><i>A</i></sub> ∈ <span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span> and a <span class="formula"><b>s</b></span>-tuple <span class="formula"><i>μ</i><sub><i>B</i></sub> ∈ <span class="symbol">⟦</span><i>B</i><span class="symbol">⟧</span><span class="symbol">(</span><b>s</b><span class="symbol">)</span></span> that assigns the same spans as <span class="formula"><i>μ</i><sub><i>A</i></sub></span> to the variables they have in common. Given the <span class="formula"><b>s</b></span>-tuple <span class="formula"><i>μ</i></span> that yelds all the variable assignments of <span class="formula"><i>μ</i><sub><i>A</i></sub></span> and <span class="formula"><i>μ</i><sub><i>B</i></sub></span>, we need to find a run <span class="formula"><i>ρ</i></span> of <span class="formula"><i>C</i></span> on <span class="formula"><b>s</b></span> that returns <span class="formula"><i>μ</i></span>. Let us call <span class="formula"><i>ρ</i><sub><i>A</i></sub> ∈ <span class="textrm">ARuns</span><span class="symbol">(</span><i>A</i>, <b>s</b><span class="symbol">)</span></span> and <span class="formula"><i>ρ</i><sub><i>B</i></sub> ∈ <span class="textrm">ARuns</span><span class="symbol">(</span><i>B</i>, <b>s</b><span class="symbol">)</span></span> the runs that return <span class="formula"><i>μ</i><sub><i>A</i></sub></span> and <span class="formula"><i>μ</i><sub><i>B</i></sub></span>, respectively. We can obtain <span class="formula"><i>ρ</i></span> by combining <span class="formula"><i>ρ</i><sub><i>A</i></sub></span> and <span class="formula"><i>ρ</i><sub><i>B</i></sub></span>. For this construction to work, <span class="formula"><i>ρ</i><sub><i>A</i></sub></span> and <span class="formula"><i>ρ</i><sub><i>B</i></sub></span> need to be consistent on the order of the variable operations they perform. Since <span class="formula"><i>A</i></span> and <span class="formula"><i>B</i></span> are well-behaved and operation-closed, <span class="formula"><i>ρ</i><sub><i>A</i></sub></span> and <span class="formula"><i>ρ</i><sub><i>B</i></sub></span> can always be selected so that they are consistent.
</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Indented">
Now, let us reason on the relative expressive power of eVset-automata with respect to plain vset-automata. Actually, they are equivalent, as the following lemmas show.
</div>
<div class="Lemma">
<a class="Label" name="eVset-to-plain"> </a>Given an eVset-automaton <span class="formula"><i>A</i> = <span class="symbol">(</span><i>Q</i>, <i>q</i><sub>0</sub>, <i>q</i><sub><i>f</i></sub>, <i>δ</i><span class="symbol">)</span></span>, <span class="formula"><i>A</i></span> can be converted into a vset-automaton <span class="formula"><i>A</i>’</span>, such that <span class="formula"><span class="symbol">⟦</span><i>A</i>’<span class="symbol">⟧</span> = <span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span></span>, in polynomial time, and in a well-behavedness preserving manner<span class="FootOuter"><span class="SupFootMarker"> [A] </span><span class="HoverFoot"><span class="SupFootMarker"> [A] </span>Note that I didn’t define well-behavedness in the case of a plain vset-automaton. Nonetheless, the idea underlying the definition for extended vset-automata remains unchanged and the actual definition for a standard vset-automaton isn’t difficult to figure out.</span></span>.
</div>
<div class="Proof">
Without loss of generality, we consider an ordering of the symbols in <span class="formula"><span class="textrm">SVOps</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span> of the following form:<div class="formula">
<i>x</i>⊢, …, <i>y</i>⊢, <i>x</i>⊣, …, <i>y</i>⊣
</div>
 In this ordering, all insertion operations come before the deletion operations. Let us define <span class="formula"><i>o</i>≺<i>o</i>’</span>, with <span class="formula"><i>o</i>, <i>o</i>’ ∈ <span class="textrm">SVOps</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span>, if <span class="formula"><i>o</i></span> comes before <span class="formula"><i>o</i>’</span> (<i>not</i> if they are equal) in the chosen ordering. Consider <span class="formula"><i>A</i>’ = </span><span class="formula"><span class="symbol">(</span><i>Q</i>’, <i>q</i><sub>0</sub>’, <i>q</i><sub><i>f</i></sub>’, <i>δ</i>’<span class="symbol">)</span></span>, with <span class="formula"><span class="textrm">SVars</span><span class="symbol">(</span><i>A</i>’<span class="symbol">)</span> = <span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span>, whose components are defined as follows:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>Q</i>’ = <i>Q</i>∪<i>Q</i><sup><span class="textrm">ops</span></sup>∪<i>Q</i><sup><span class="textrm">Ø</span></sup></span>, where:\begin_inset Separator latexpar\end_inset<ul>
<li>
<span class="formula"><i>Q</i><sup><span class="textrm">ops</span></sup> = <span class="symbol">{</span><i>q</i><sub><i>q</i>’, <i>o</i>, <i>q</i>’’</sub>∣∃<span class="symbol">(</span><i>q</i>’, <i>S</i>, <i>q</i>’’<span class="symbol">)</span> ∈ <i>δ</i>:<i>o</i> ∈ <i>S</i><span class="symbol">}</span></span>;
</li>
<li>
<span class="formula"><i>Q</i><sup><span class="textrm">Ø</span></sup> = <span class="symbol">{</span><i>q</i><sub><span class="textrm">q',Ø,q''</span></sub>∣∃<span class="symbol">(</span><i>q</i>’, <span class="textrm">Ø</span>, <i>q</i>’’<span class="symbol">)</span> ∈ <i>δ</i><span class="symbol">}</span></span>;
</li>

</ul>

</li>
<li>
<span class="formula"><i>q</i><sub>0</sub>’ = <i>q</i><sub>0</sub>;</span>
</li>
<li>
<span class="formula"><i>q</i><sub><i>f</i></sub>’ = <i>q</i><sub><i>f</i></sub></span>;
</li>
<li>
<span class="formula"><i>δ</i>’ = <span class="symbol">(</span><i>δ</i>∖<i>δ</i><sup><i>S</i></sup><span class="symbol">)</span>∪<i>δ</i><sup><span class="textrm">ops</span></sup>∪<i>δ</i><sup><span class="textrm">Ø</span></sup>∪<i>δ</i><sup><i>ε</i></sup></span>, where:\begin_inset Separator latexpar\end_inset<ul>
<li>
<span class="formula"><i>δ</i><sup><i>S</i></sup> = <span class="symbol">{</span><span class="symbol">(</span><i>q</i>, <i>S</i>, <i>q</i>’<span class="symbol">)</span> ∈ <i>δ</i><span class="symbol">}</span>;</span>
</li>
<li>
<span class="formula"><i>δ</i><sup><span class="textrm">ops</span></sup> = <span class="symbol">{</span><span class="symbol">(</span><i>q</i><sub><i>q</i>’, <i>o</i>, <i>q</i>’’</sub>, <i>o</i>, <i>q</i><sub><i>q</i>’, <i>o</i>’, <i>q</i>’’</sub><span class="symbol">)</span>∣∃<span class="symbol">(</span><i>q</i>’, <i>S</i>, <i>q</i>’’<span class="symbol">)</span> ∈ <i>δ</i>:<span class="symbol">(</span><i>o</i>, <i>o</i>’<i>ϵ</i><i>S</i>∧<i>o</i>≺<i>o</i>’∧∀<i>o</i>’’ ∈ <i>S</i>:<i>o</i>⊀<i>o</i>’’⊀<i>o</i>’<span class="symbol">)</span><span class="symbol">}</span>∪<span class="symbol">{</span><span class="symbol">(</span><i>q</i><sub><i>q</i>’, <i>o</i>, <i>q</i>’’</sub>, <i>o</i>, <i>q</i>’’<span class="symbol">)</span>∣∃<span class="symbol">(</span><i>q</i>’, <i>S</i>, <i>q</i>’’<span class="symbol">)</span> ∈ <i>δ</i>:<span class="symbol">(</span><i>o</i><i>ϵ</i><i>S</i>∧∀<i>o</i>’ ∈ <i>S</i>:<i>o</i>⊀<i>o</i>’<span class="symbol">)</span><span class="symbol">}</span></span>;
</li>
<li>
<span class="formula"><i>δ</i><sup><span class="textrm">Ø</span></sup> = <span class="symbol">{</span><span class="symbol">(</span><i>q</i><sub><span class="textrm">q',Ø,q''</span></sub>, <i>ε</i>, <i>q</i>’’<span class="symbol">)</span>∣∃<span class="symbol">(</span><i>q</i>’, <span class="textrm">Ø</span>, <i>q</i>’’<span class="symbol">)</span> ∈ <i>δ</i><span class="symbol">}</span>;</span>
</li>
<li>
<span class="formula"><i>δ</i><sup><i>ε</i></sup> = <span class="symbol">{</span><span class="symbol">(</span><i>q</i>, <i>ε</i>, <i>q</i>’<span class="symbol">)</span>∣<span class="symbol">(</span>∃<span class="symbol">(</span><i>q</i>’, <i>o</i>, <i>q</i>’’<span class="symbol">)</span> ∈ <i>δ</i><sup><span class="textrm">ops</span></sup>:∀<span class="symbol">(</span><i>q</i>’, <i>o</i>’, <i>q</i>’’<span class="symbol">)</span> ∈ <i>δ</i><sup><span class="textrm">ops</span></sup>:<i>o</i>’⊀<i>o</i><span class="symbol">)</span>∨<span class="symbol">(</span>∃<span class="symbol">(</span><i>q</i>’, <i>ε</i>, <i>q</i>’’<span class="symbol">)</span> ∈ <i>δ</i><sup><span class="textrm">Ø</span></sup><span class="symbol">)</span><span class="symbol">}</span></span>.
</li>

</ul>

</li>

</ul>

</li>

</ul>
<div class="Proof">
This construction expands the transitions of <span class="formula"><i>A</i></span> that are labeled with a set of variable operations into a sequence of transitions performing one operation at a time, taking care of putting the insertion operations before the deletion ones. This construction clearly preserves well-behavedness, because each complete path <span class="formula"><i>p</i>’</span> in <span class="formula"><i>A</i>’</span> is obtained from a path <span class="formula"><i>p</i></span> in <span class="formula"><i>A</i></span>, preserving the original operations of <span class="formula"><i>p</i></span> and ensuring a correct order of their appearence (if <span class="formula"><i>A</i></span> is well-behaved). Each sequence starts with an <span class="formula"><i>ε</i></span>-transition. This is not necessary in principle, but it allows to reduce the complexity of the formulation. The construction also substitutes transitions labeled with the empty set with ordinary <span class="formula"><i>ε</i> − </span>transitions. To prove equivalence between <span class="formula"><i>A</i></span> and <span class="formula"><i>A</i>’</span> it is sufficient to notice that for every string <span class="formula"><b>s</b></span>, every run belonging to<span class="formula"><span class="textrm">ARuns</span><span class="symbol">(</span><i>A</i>, <b>s</b><span class="symbol">)</span></span> can be put in correspondence with a run belonging to <span class="formula"><span class="textrm">ARuns</span><span class="symbol">(</span><i>A</i>’, <b>s</b><span class="symbol">)</span></span>, and viceversa. Indeed, if we start from <span class="formula"><i>ρ</i> ∈ <span class="textrm">ARuns</span><span class="symbol">(</span><i>A</i>, <b>s</b><span class="symbol">)</span></span> we can obtain a run <span class="formula"><span class="textrm">ρ' ∈ ARuns</span><span class="symbol">(</span><i>A</i>’, <b>s</b><span class="symbol">)</span></span> that spans the same <span class="formula"><b>s</b></span>-tuple <span class="formula"><i>μ</i></span>. It is sufficient to expand configuration pairs in <span class="formula"><i>ρ</i></span> whose current states are linked in <span class="formula"><i>A</i></span> by a transition <span class="formula"><i>t</i></span>, which we expand in <span class="formula"><i>A</i>’</span>, with a series of configurations that let us perform the set of variable operations in <span class="formula"><i>t</i></span> one at a time. This is always possible by construction of <span class="formula"><i>A</i>’</span>. If we start from <span class="formula"><span class="textrm">ρ' ∈ ARuns</span><span class="symbol">(</span><i>A</i>’, <b>s</b><span class="symbol">)</span></span>, we can obtain an equivalent run <span class="formula"><i>ρ</i> ∈ <span class="textrm">ARuns</span><span class="symbol">(</span><i>A</i>, <b>s</b><span class="symbol">)</span></span> in the opposite way, by compressing consecutive configurations. The details are omitted.
</div>
<div class="Proof">
It remains to show that the construction of <span class="formula"><i>A</i>’</span> can be carried in polynomial time. Let us refer to the size of <span class="formula"><i>A</i></span> as <span class="formula"><i>n</i></span>. We consider <span class="formula"><i>n</i> = <span class="symbol">|</span><i>Q</i><span class="symbol">|</span> + <span class="symbol">|</span><i>δ</i><span class="symbol">|</span> + <span class="symbol">|</span><span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span><span class="symbol">|</span></span>. With the usual assumptions, adding a new transition, removing a state and removing a transition take constant time. Thus, expanding a single transition of <span class="formula"><i>A</i></span> takes <span class="formula"><i>O</i><span class="symbol">(</span><span class="symbol">|</span><span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span><span class="symbol">|</span><span class="symbol">)</span> = <i>O</i><span class="symbol">(</span><i>n</i><span class="symbol">)</span></span> time. Expanding every transition that is needed will then take <span class="formula"><i>O</i><span class="symbol">(</span><span class="symbol">|</span><span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span><span class="symbol">|</span>⋅<span class="symbol">|</span><i>δ</i><span class="symbol">|</span><span class="symbol">)</span> = <i>O</i><span class="symbol">(</span><i>n</i><sup>2</sup><span class="symbol">)</span></span> time.
</div>
<div class="Unindented">
The opposite direction is also true.
</div>
<div class="Lemma">
Given a vset-automaton <span class="formula"><i>A</i> = <span class="symbol">(</span><i>Q</i>, <i>q</i><sub>0</sub>, <i>q</i><sub><i>f</i></sub>, <i>δ</i><span class="symbol">)</span></span>, an eVset-automaton <span class="formula"><i>A</i>’</span> can be found such that <span class="formula"><span class="symbol">⟦</span><i>A</i>’<span class="symbol">⟧</span> = <span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span></span>, in polynomial time, and in a well-behavedness preserving manner.
</div>
<div class="Proof">
In this case it is sufficient to replace every transition <span class="formula"><i>t</i></span> performing a variable operation <span class="formula"><i>o</i></span> in <span class="formula"><i>A</i></span> with an operations transition <span class="formula"><i>t</i>’</span> in <span class="formula"><i>A</i>’</span> such that <span class="formula"><span class="textrm">Ops</span><span class="symbol">(</span><i>t</i>’<span class="symbol">)</span> = <span class="symbol">{</span><i>o</i><span class="symbol">}</span></span> and <span class="formula"><span class="textrm">LOps</span><span class="symbol">(</span><i>t</i>’<span class="symbol">)</span> = <i>o</i></span> . <span class="formula"><i>ε</i></span>-transitions can be replaced by operations transitions with an empty set. With the usual assumptions, this construction can be obtained in linear time. It is easy to verify equivalence, and that well-behavedness is preserved, thus the details are omitted.
</div>
<div class="Unindented">
These results are interesting. In particular, Lemma <a class="Reference" href="#eVset-to-plain">4.2↑</a> ensures that any well-behaved eVset-automaton, equipped with the string equality selection operator, can indeed represent an AQL core fragment. What about the inverse? In order for the runtime system to have full applicability, we need to prove that an AQL core fragment can be represented by a well-behaved eVset automaton, extended with string equality selection. According to Definition <a class="Reference" href="#core-def">3.3.5↑</a>, an AQL core fragment is a set of regex formulas combined by using the operators described in Subsection <a class="Reference" href="#subsec:Algebras-of-Spanners">3.3.3↑</a>. To achieve our goal, the first step is to prove that a regex formula can always be converted into a well-behaved eVset-automaton.
</div>
<div class="Theorem">
<a class="Label" name="regex-to-well"> </a>Given a regex formula <span class="formula"><i>γ</i></span>, a well-behaved eVset-automaton <span class="formula"><i>A</i></span> can be found, in polynomial time, such that <span class="formula"><span class="symbol">⟦</span><i>A</i><span class="symbol">⟧</span> = <span class="symbol">⟦</span><i>γ</i><span class="symbol">⟧</span></span>.
</div>
<div class="Unindented">
Let us call the class of well-behaved eVset-automata <span class="formula"><span class="textrm">VA</span><sub><span class="textrm">WESet</span></sub></span>. By combining Theorems <a class="Reference" href="#regex-to-well">4.2↑</a>, <a class="Reference" href="#ext-union">4.2↑</a> and <a class="Reference" href="#ext-join">4.2↑</a> and Lemma <a class="Reference" href="#eVset-to-plain">4.2↑</a>, we can state the following theorem.
</div>
<div class="Theorem">
<span class="formula"><span class="symbol">⟦</span><span class="textrm">RGX</span><sup><span class="symbol">{</span>∪, <i>π</i>, ⋈, <i>ς</i><sup> = </sup><span class="symbol">}</span></sup><span class="symbol">⟧</span> = <span class="symbol">⟦</span><span class="textrm">VA</span><sub><span class="textrm">WESet</span></sub><sup><span class="symbol">{</span>∪, <i>π</i>, ⋈, <i>ς</i><sup> = </sup><span class="symbol">}</span></sup><span class="symbol">⟧</span> = <span class="symbol">⟦</span><span class="textrm">VA</span><sub><span class="textrm">WESet</span></sub><sup><span class="symbol">{</span><i>π</i>, <i>ς</i><sup> = </sup><span class="symbol">}</span></sup><span class="symbol">⟧</span></span>.
</div>
<div class="Proof">
Theorem <a class="Reference" href="#regex-to-well">4.2↑</a> tells us that <span class="formula"><span class="symbol">⟦</span><span class="textrm">RGX</span><span class="symbol">⟧</span> ⊆ <span class="symbol">⟦</span><span class="textrm">VA</span><sub><span class="textrm">WESet</span></sub><span class="symbol">⟧</span></span>. Thus we can state that
</div>
<div class="Proof">
<div class="formula">
<a class="eqnumber" name="eq-4.1">(4.1) </a><span class="symbol">⟦</span><span class="textrm">RGX</span><sup><span class="symbol">{</span>∪, <i>π</i>, ⋈, <i>ς</i><sup> = </sup><span class="symbol">}</span></sup><span class="symbol">⟧</span> ⊆ <span class="symbol">⟦</span><span class="textrm">VA</span><sub><span class="textrm">WESet</span></sub><sup><span class="symbol">{</span>∪, <i>π</i>, ⋈, <i>ς</i><sup> = </sup><span class="symbol">}</span></sup><span class="symbol">⟧</span>
</div>

</div>
<div class="Proof">
Moreover, Lemma <a class="Reference" href="#eVset-to-plain">4.2↑</a> and Theorem <a class="Reference" href="#RGX=SET">3.3.5↑</a> imply that
</div>
<div class="Proof">
<div class="formula">
<a class="eqnumber" name="eq-4.2">(4.2) </a><span class="symbol">⟦</span><span class="textrm">VA</span><sub><span class="textrm">WESet</span></sub><sup><span class="symbol">{</span>∪, <i>π</i>, ⋈, <i>ς</i><sup> = </sup><span class="symbol">}</span></sup><span class="symbol">⟧</span> ⊆ <span class="symbol">⟦</span><span class="textrm">VA</span><sub><span class="textrm">set</span></sub><sup><span class="symbol">{</span>∪, <i>π</i>, ⋈, <i>ς</i><sup> = </sup><span class="symbol">}</span></sup><span class="symbol">⟧</span> = <span class="symbol">⟦</span><span class="textrm">RGX</span><sup><span class="symbol">{</span>∪, <i>π</i>, ⋈, <i>ς</i><sup> = </sup><span class="symbol">}</span></sup><span class="symbol">⟧</span>
</div>

</div>
<div class="Proof">
Finally, Theorems <a class="Reference" href="#ext-union">4.2↑</a> and <a class="Reference" href="#ext-join">4.2↑</a> justify the right-hand equality in the statement of this theorem.
</div>
<div class="Unindented">
We can also formulate a modified version of the Core Simplification Lemma (Lemma <a class="Reference" href="#Core-simplif">3.3.5↑</a>). The proof is the same as that of the original lemma, which can be found in <span class="bibcites">[<a class="bibliocite" name="cite-5" href="#biblio-5"><span class="bib-index">5</span></a>]</span>, and is omitted here.
</div>
<div class="Lemma">
Every core spanner can be defined by an expression of the form
</div>
<div class="Lemma">
<div class="formula">
<a class="eqnumber" name="eq-4.3">(4.3) </a><i>π</i><sub><i>V</i></sub><i>SA</i>
</div>

</div>
<div class="Lemma">
where:\begin_inset Separator latexpar\end_inset
</div>
<ul>
<li class="nested">
<ul>
<li>
<span class="formula"><i>A</i></span> is a well-behaved eVset-automaton;
</li>
<li>
<span class="formula"><i>V</i> ⊆ <span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span>;
</li>
<li>
<span class="formula"><i>S</i></span> is a sequence of string selections <span class="formula"><i>ς</i><sub><i>x</i>, <i>y</i></sub><sup> = </sup></span>, for <span class="formula"><i>x</i>, <i>y</i> ∈ <span class="textrm">SVars</span><span class="symbol">(</span><i>A</i><span class="symbol">)</span></span>.
</li>

</ul>

</li>

</ul>
<h2 class="Section">
<a class="toc" name="toc-Section-4.3">4.3</a> Methods for NFA execution
</h2>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.3.1">4.3.1</a> The Thompson Approach
</h3>
<div class="Unindented">
Given a regular expression <span class="formula"><i>r</i></span>, its corresponding NFA <span class="formula"><i>A</i></span> and a string <span class="formula"><b>s</b></span>, the Thompson algorithm will try all the feasible runs of <span class="formula"><i>A</i></span> on <span class="formula"><b>s</b></span> at the same time. More precisely, when the string pointer is on a given character, there is a set of current states, each representing the advancement in a feasible run. The set of outgoing transitions for each state is examined. All <span class="formula"><i>ε</i></span>-transitions are fired iteratively and, subsequently, any transition labeled with the character corresponding to the one pointed by the string pointer is fired. This produces a new set of states and the execution continues as descibed. <span class="formula"><b>s</b></span> is matched by <span class="formula"><i>A</i></span> if, at the end of the execution, all the symbols of <span class="formula"><b>s</b></span> have been consumed and at least one state in the current state set is an accepting state. It can be shown that the time complexity of this approach is <span class="formula"><i>O</i><span class="symbol">(</span><i>mn</i><span class="symbol">)</span></span>, where <span class="formula"><i>m</i></span> is the size of <span class="formula"><i>r</i></span>. 
</div>
<div class="Indented">
Usually, we accept <i>partial matchings,</i> meaning that we don’t require to reach the end of a string to produce a matching, instead we only require that one state set, among those obtained during the execution, contains the final state. This is useful for implementing <i>unanchored matchings. </i>Partial matchings pose the problem of ambiguous matches. This is why concrete algorithms implement a policy to discriminate among multiple possible matchings (e.g. greedy leftmost). For more information on the Thompson approach, see <span class="bibcites">[<a class="bibliocite" name="cite-26" href="#biblio-26">26</a>]</span>.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="Figure-4.3"> </a><div class="multifigure">
span class="align-center"<span class="float">
<div class="figure">
<span class="align-center"><span class="environment"><span class="arrayrow">
<span class="arraycell align-l">
[shorten
</span>
<span class="arraycell align-l">
gt; = 1pt, nodedistance = 3cm, ongrid, auto]<span class="unknown">\node</span>[state, initial](q<sub>0</sub>)q<sub>0</sub>;<span class="unknown">\node</span>[state](q<sub>1</sub>)[aboveright = ofq<sub>0</sub>]q<sub>1</sub>;<span class="unknown">\node</span>[state](q<sub>2</sub>)[belowright = ofq<sub>0</sub>]q<sub>2</sub>;<span class="unknown">\node</span>[state, accepting](q<sub>3</sub>)[belowright = ofq<sub>1</sub>]q<sub>3</sub>;<span class="unknown">\path</span>[ − 
</span>
<span class="arraycell align-l">
gt;](q<sub>0</sub>)edgenodea(q<sub>1</sub>)edgenode[swap]ε(q<sub>2</sub>)(q<sub>1</sub>)edge[bendleft]nodea(q<sub>3</sub>)edge[bendright]nodeb(q<sub>3</sub>)edge[loopabove]nodea()(q<sub>2</sub>)edgenode[swap]c(q<sub>3</sub>)edge[loopbelow]nodea()(q<sub>3</sub>)edge[loopright]nodea();
</span>

</span>
</span></span><a class="Label" name="thompson-aut"> </a><div class="caption">
(a) An <span class="formula"><i>ε</i></span>-NFA <span class="formula"><i>A</i></span>.
</div>

</div>

</span>
<div class="defskip"> </div><span class="float">
<div class="figure">
<span class="align-center"><span class="environment"><span class="arrayrow">
<span class="arraycell align-l">
[nodedistance = 2.5cm, auto]<span class="unknown">\node</span>(one)[align = left]<u>a</u>aab<br><span class="symbol">{</span>q<sub>0</sub><span class="symbol">}</span>;<span class="unknown">\node</span>(two)[rightof = one, align = left]a<u>a</u>ab<br><span class="symbol">{</span>q<sub>1</sub>, q<sub>2</sub><span class="symbol">}</span>;<span class="unknown">\node</span>(three)[rightof = two, align = left]aa<u>a</u>b<br><span class="symbol">{</span>q<sub>1</sub>, q<sub>2</sub>, q<sub>3</sub><span class="symbol">}</span>;<span class="unknown">\node</span>(four)[rightof = three, align = left]aaa<u>b</u><br><span class="symbol">{</span>q<sub>1</sub>, q<sub>2</sub>, q<sub>3</sub><span class="symbol">}</span>;<span class="unknown">\node</span>(five)[rightof = four, align = left]aaab<u></u><br><span class="symbol">{</span>q<sub>3</sub><span class="symbol">}</span>;<span class="unknown">\path</span>[ − 
</span>
<span class="arraycell align-l">
gt;](one)edgenode(two);<span class="unknown">\path</span>[ − 
</span>
<span class="arraycell align-l">
gt;](two)edgenode(three);<span class="unknown">\path</span>[ − 
</span>
<span class="arraycell align-l">
gt;](three)edgenode(four);<span class="unknown">\path</span>[ − 
</span>
<span class="arraycell align-l">
gt;](four)edgenode(five);
</span>

</span>
</span></span><a class="Label" name="thompson-exec"> </a><div class="caption">
(b) The execution of <span class="formula"><i>A</i></span> on ’aaab’ according to the Thompson approach.
</div>

</div>

</span>
<div class="caption">
Figure 4.3 Example of the Thompson algorithm.
</div>

</div>

</div>

</div>
<div class="Example">
The automaton <span class="formula"><i>A</i></span> of Figure <a class="Reference" href="#thompson-aut">a↑</a> matches the string <span class="formula"><b>s</b> = </span>’aaab’. Figure <a class="Reference" href="#thompson-exec">b↑</a> illustrates the execution of <span class="formula"><i>A</i></span> on <span class="formula"><b>s</b></span>. Notice how runs that end up in the same state are naturally merged. For instance, if we are in <span class="formula"><i>q</i><sub>1</sub></span> and we read an <span class="formula"><i>a</i></span> we can go to <span class="formula"><i>q</i><sub>3</sub></span>, but we can also read an <span class="formula"><i>a</i></span> while in <span class="formula"><i>q</i><sub>3</sub></span>, remaining in that state. Nonetheless, in the cases where both <span class="formula"><i>q</i><sub>1</sub></span> and <span class="formula"><i>q</i><sub>3</sub></span> are in the current state set, <span class="formula"><i>q</i><sub>3</sub></span> appears only once in the next. This is because the two originally distinct runs are now equivalent. This lets the algorithm keep a reduced list of current states, and justifies the runtime complexity presented.
</div>
<div class="Unindented">
One interesting implementation of the Thompson algorithm views an NFA as a program that can be executed by a virtual machine on a string. This method is described in <span class="bibcites">[<a class="bibliocite" name="cite-3" href="#biblio-3"><span class="bib-index">3</span></a>]</span>. 
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-13"></a>The Virtual Machine Implementation
</h4>
<div class="Unindented">
In this implementation, a NFA (or a regex) is converted into a program, written in a simple assembly language with few instructions. The basic instructions are character match (CHAR), string match (MATCH), and control flow instructions (SPLIT and JUMP). A virtual machine is provided, which treats each concurrent run on a string <span class="formula"><b>s</b></span> as a conceptual thread. The virtual machine advances all the threads in lockstep, in the spirit of the Thompson approach. Actual implementations can enforce a policy for ambiguous matches. Different threads that reach the same instruction in a program are merged. 
</div>
<div class="Indented">
The main advantage of this method is that it is easy to enrich the assembly language with new instructions, in order to support new features. To execute new instructions, modyifing the virtual machine is required. For instance, capturing groups can be implemented by equipping each thread with an array of saved pointers that are grouped by two: the first element would point to the beginning of a span of text and the second one would point to its end. Then, a SAVE instruction could be added, that would make the virtual machine record the current position in the input into the pointer specified by the instruction.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="Figure-4.4"> </a><div class="multifigure">
span class="align-center"<span class="float">
<div class="figure">
<span class="environment"><span class="arrayrow">
<span class="arraycell align-l">
<span class="unknown">\matrix</span>[ampersandreplacement = &amp;]<span class="unknown">\node</span>0;&amp;<span class="unknown">\node</span>CHARa;<br><span class="unknown">\node</span>1;&amp;<span class="unknown">\node</span>SPLIT0, 2;<br><span class="unknown">\node</span>2;&amp;<span class="unknown">\node</span>SPLIT3, 5;<br><span class="unknown">\node</span>3;&amp;<span class="unknown">\node</span>CHARb;<br><span class="unknown">\node</span>4;&amp;<span class="unknown">\node</span>JUMP2;<br><span class="unknown">\node</span>5;&amp;<span class="unknown">\node</span>MATCH;<br><span class="unknown">\node</span>;&amp;<span class="unknown">\node</span>;<br><span class="unknown">\node</span>;&amp;<span class="unknown">\node</span>;<br><span class="unknown">\node</span>;&amp;<span class="unknown">\node</span>;<br>;
</span>

</span>
</span><a class="Label" name="prog"> </a><div class="caption">
(a) A program for the regex <span class="formula"><i>a</i><sup> + </sup><i>b</i><sup>∗</sup></span>.
</div>

</div>

</span>
<span class="float">
<div class="figure">
<span class="environment"><span class="arrayrow">
<span class="arraycell align-l">
<span class="unknown">\matrix</span>[ampersandreplacement = &amp;]<span class="unknown">\node</span>0;&amp;<span class="unknown">\node</span>SAVE0;<br><span class="unknown">\node</span>1;&amp;<span class="unknown">\node</span>CHARa;<br><span class="unknown">\node</span>2;&amp;<span class="unknown">\node</span>SPLIT1, 3;<br><span class="unknown">\node</span>3;&amp;<span class="unknown">\node</span>SAVE1;<br><span class="unknown">\node</span>4;&amp;<span class="unknown">\node</span>SAVE2;<br><span class="unknown">\node</span>5;&amp;<span class="unknown">\node</span>SPLIT6, 8;<br><span class="unknown">\node</span>6;&amp;<span class="unknown">\node</span>CHARb;<br><span class="unknown">\node</span>7;&amp;<span class="unknown">\node</span>JUMP5;<br><span class="unknown">\node</span>8;&amp;<span class="unknown">\node</span>SAVE3;<br><span class="unknown">\node</span>9;&amp;<span class="unknown">\node</span>MATCH;<br>;
</span>

</span>
</span><a class="Label" name="prog-capt"> </a><div class="caption">
(b) A program for the regex <span class="formula"><span class="symbol">(</span><i>a</i><sup> + </sup><span class="symbol">)</span><span class="symbol">(</span><i>b</i><sup>∗</sup><span class="symbol">)</span></span>.
</div>

</div>

</span>
<div class="caption">
Figure 4.4 Example programs.
</div>

</div>

</div>

</div>
<div class="Example">
The program shown in Figure <a class="Reference" href="#prog">a↑</a> can be used to match the regular expression <span class="formula"><i>a</i><sup> + </sup><i>b</i><sup>*</sup></span>. SPLIT instructions explictly divide a thread into two, telling each of the generated threads which position in the program to reach. The program in Figure <a class="Reference" href="#prog-capt">b↑</a> matches the same expression as the one in Figure <a class="Reference" href="#prog">a↑</a>, but it retains the substrings matching the subexpressions between parentheses too.
</div>
<div class="Example">
<div class="float">
<a class="Label" name="Figure-4.5"> </a><div class="figure">
<span class="align-center"><span class="environment"><span class="arrayrow">
<span class="arraycell align-l">
<span class="unknown">\matrix</span>[ampersandreplacement = &amp;]<span class="unknown">\node</span>0;&amp;<span class="unknown">\node</span>SPLIT1, 8;<br><span class="unknown">\node</span>1;&amp;<span class="unknown">\node</span>CHARa;<br><span class="unknown">\node</span>2;&amp;<span class="unknown">\node</span>SPLIT1, 3;<br><span class="unknown">\node</span>3;&amp;<span class="unknown">\node</span>SPLIT4, 6;<br><span class="unknown">\node</span>4;&amp;<span class="unknown">\node</span>CHARa;<br><span class="unknown">\node</span>5;&amp;<span class="unknown">\node</span>JUMP7;<br><span class="unknown">\node</span>6;&amp;<span class="unknown">\node</span>CHARb;<br><span class="unknown">\node</span>7;&amp;<span class="unknown">\node</span>JUMP12;<br><span class="unknown">\node</span>8;&amp;<span class="unknown">\node</span>SPLIT9, 11;<br><span class="unknown">\node</span>9;&amp;<span class="unknown">\node</span>CHARa;<br><span class="unknown">\node</span>10;&amp;<span class="unknown">\node</span>JUMP8;<br><span class="unknown">\node</span>11;&amp;<span class="unknown">\node</span>CHARc;<br><span class="unknown">\node</span>12;&amp;<span class="unknown">\node</span>SPLIT13, 15;<br><span class="unknown">\node</span>13;&amp;<span class="unknown">\node</span>CHARa;<br><span class="unknown">\node</span>14;&amp;<span class="unknown">\node</span>JUMP12;<br><span class="unknown">\node</span>15;&amp;<span class="unknown">\node</span>MATCHS;<br>;
</span>

</span>
</span></span><a class="Label" name="prog-aut"> </a><div class="caption">
Figure 4.5 A program for the automaton <span class="formula"><i>A</i></span> of Figure <a class="Reference" href="#thompson-aut">a↑</a>.
</div>

</div>

</div>

</div>
<div class="Unindented">
\begin_inset Separator parbreak\end_inset
</div>
<div class="Example">
The program shown in Figure <a class="Reference" href="#prog-aut">4.5↑</a> corresponds to the automaton <span class="formula"><i>A</i></span> of Figure <a class="Reference" href="#thompson-aut">a↑</a>. Notice how the <span class="formula"><i>ε</i></span>-transition between <span class="formula"><i>q</i><sub>0</sub></span> and <span class="formula"><i>q</i><sub>2</sub></span> is automatically omitted from the program. Blocks of SPLIT instructions correspond to multiple outgoing transitions from a state. JUMP instructions are used to merge execution branches. 
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.3.2">4.3.2</a> Ordered Binary Decision Diagrams
</h3>
<div class="Unindented">
Ordered Binary Decision Diagrams (OBDDs) are tree-like structures, that can be used to efficiently represent, manipulate and evaluate boolean formulas. One of their advantages is that first order logic quantifiers can be easily supported by performing a series of operations that change the structure of an OBDD opportunely. In <span class="bibcites">[<a class="bibliocite" name="cite-10" href="#biblio-10"><span class="bib-index">10</span></a>]</span>, it is shown how to encode NFAs as OBDDs, with support for submatch extraction. Then, a procedure for evaluating a string by using an OBDD representation of a NFA is described.
</div>
<div class="Indented">
Given a regular expression <span class="formula"><i>r</i></span> of size <span class="formula"><i>m</i></span> and a string of size <span class="formula"><i>n</i></span>, the runtime cost of this approach is shown to be between <span class="formula"><i>O</i><span class="symbol">(</span><i>m</i><span class="symbol">)</span></span> and <span class="formula"><i>O</i><span class="symbol">(</span><i>mn</i><span class="symbol">)</span></span>. The authors of <span class="bibcites">[<a class="bibliocite" name="cite-10" href="#biblio-10"><span class="bib-index">10</span></a>]</span> suggest that this approach performs best when matching patterns are combined togheter.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.3.3">4.3.3</a> Kleenex
</h3>
<div class="Unindented">
A <i>transducer</i> is a kind of finite state machine whose main difference with an NFA is that it has an <i>output tape</i>. Thus, the transition function of a transducer is enriched with <i>output actions.</i> Output actions can be used to write to the output tape, thus providing a way to support submatch extraction.
</div>
<div class="Indented">
In <span class="bibcites">[<a class="bibliocite" name="cite-6" href="#biblio-6"><span class="bib-index">6</span></a>]</span>, the Kleenex language is presented. It can be used to specify context free grammars, representing regular expressions with capturing groups. A Kleenex program is converted to a transducer, which is in turn decomposed into an <i>oracle machine</i> and an <i>action machine</i>. The oracle machine traverses an input string trying to match it (according to a disambiguation policy), while the action machine performs the ouput actions. 
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.4">4.4</a> Implementation
</h2>
<div class="Unindented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-5">5</a> <span lang="en">Conclusions</span>
</h1>
<h2 class="Section">
<a class="toc" name="toc-Section-5.1">5.1</a> <span lang="en">Discussion</span>
</h2>
<div class="Unindented">
<span lang="en">blabla</span>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-5.2">5.2</a> <span lang="en">Future Works</span>
</h2>
<div class="Unindented">
<span lang="en">blabla</span>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-5.3">5.3</a> <span lang="en">Promising Directions</span>
</h2>
<div class="Unindented">
<span lang="en">blabla</span>
</div>
<div class="Indented">
<span lang="en"><h1 class="biblio">
References
</h1>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-1"><span class="bib-index">1</span></a>] </span> <span class="bib-authors">Russ Cox</span>: <i><span class="bib-title">Regular Expression Matching Can Be Simple And Fast (but is slow in Java, Perl, PHP, Python, Ruby, ..)</span></i>. <span class="bib-year">2007</span>. URL <a href="https://swtch.com/~rsc/regexp/regexp1.html"><span class="bib-url">https://swtch.com/~rsc/regexp/regexp1.html</span></a>.
</p>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-2"><span class="bib-index">2</span></a>] </span> <span class="bib-authors">Russ Cox</span>: <i><span class="bib-title">Regular Expression Matching in the Wild</span></i>. <span class="bib-year">2010</span>. URL <a href="https://swtch.com/~rsc/regexp/regexp3.html"><span class="bib-url">https://swtch.com/~rsc/regexp/regexp3.html</span></a>.
</p>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-3"><span class="bib-index">3</span></a>] </span> <span class="bib-authors">Russ Cox</span>: <i><span class="bib-title">Regular Expression Matching: the Virtual Machine Approach</span></i>. <span class="bib-year">2009</span>. URL <a href="https://swtch.com/~rsc/regexp/regexp2.html"><span class="bib-url">https://swtch.com/~rsc/regexp/regexp2.html</span></a>.
</p>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-4"><span class="bib-index">4</span></a>] </span> <span class="bib-authors">F. Reiss, S. Raghavan, R. Krishnamurthy, H. Zhu, S. Vaithyanathan</span>: “<span class="bib-title">An Algebraic Approach to Rule-Based Information Extraction</span>”, <i><span class="bib-booktitle">2008 IEEE 24th International Conference on Data Engineering</span></i>, pp. <span class="bib-pages">933-942</span>, <span class="bib-year">2008</span>.
</p>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-5"><span class="bib-index">5</span></a>] </span> <span class="bib-authors">Ronald Fagin, Benny Kimelfeld, Frederick Reiss, Stijn Vansummeren</span>: “<span class="bib-title">Document Spanners: A Formal Approach to Information Extraction</span>”, <i><span class="bib-journal">J. ACM</span></i>, pp. <span class="bib-pages">12:1—12:51</span>, <span class="bib-year">2015</span>. URL <a href="http://doi.acm.org/10.1145/2699442"><span class="bib-url">http://doi.acm.org/10.1145/2699442</span></a>.
</p>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-6"><span class="bib-index">6</span></a>] </span> <span class="bib-authors">Bjørn Bugge Grathwohl, Fritz Henglein, Ulrik Terp Rasmussen, Kristoffer Aalund Søholm, Sebastian Paaske Tørholm</span>: “<span class="bib-title">Kleenex: Compiling Nondeterministic Transducers to Deterministic Streaming Transducers</span>”, <i><span class="bib-journal">SIGPLAN Not.</span></i>, pp. <span class="bib-pages">284—297</span>, <span class="bib-year">2016</span>. URL <a href="http://doi.acm.org/10.1145/2914770.2837647"><span class="bib-url">http://doi.acm.org/10.1145/2914770.2837647</span></a>.
</p>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-7"><span class="bib-index">7</span></a>] </span> <span class="bib-authors">Rajasekar Krishnamurthy, Yunyao Li, Sriram Raghavan, Frederick Reiss, Shivakumar Vaithyanathan, Huaiyu Zhu</span>: “<span class="bib-title">SystemT: A System for Declarative Information Extraction</span>”, <i><span class="bib-journal">SIGMOD Rec.</span></i>, pp. <span class="bib-pages">7—13</span>, <span class="bib-year">2009</span>. URL <a href="http://doi.acm.org/10.1145/1519103.1519105"><span class="bib-url">http://doi.acm.org/10.1145/1519103.1519105</span></a>.
</p>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-8"><span class="bib-index">8</span></a>] </span> <span class="bib-authors">Sunita Sarawagi</span>: “<span class="bib-title">Information Extraction</span>”, <i><span class="bib-journal">Found. Trends databases</span></i>, pp. <span class="bib-pages">261—377</span>, <span class="bib-year">2008</span>. URL <a href="http://dx.doi.org/10.1561/1900000003"><span class="bib-url">http://dx.doi.org/10.1561/1900000003</span></a>.
</p>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-9"><span class="bib-index">9</span></a>] </span> <span class="bib-authors">Warren Shen, AnHai Doan, Jeffrey F. Naughton, Raghu Ramakrishnan</span>: “<span class="bib-title">Declarative Information Extraction Using Datalog with Embedded Extraction Predicates</span>”, <i><span class="bib-booktitle">Proceedings of the 33rd International Conference on Very Large Data Bases</span></i>, pp. <span class="bib-pages">1033—1044</span>, <span class="bib-year">2007</span>. URL <a href="http://dl.acm.org/citation.cfm?id=1325851.1325968"><span class="bib-url">http://dl.acm.org/citation.cfm?id=1325851.1325968</span></a>.
</p>
<p class="biblio">
<span class="entry">[<a class="biblioentry" name="biblio-10"><span class="bib-index">10</span></a>] </span> <span class="bib-authors">Liu Yang, Pratyusa Manadhata, William Horne, Prasad Rao, Vinod Ganapathy</span>: “<span class="bib-title">Fast Submatch Extraction Using OBDDs</span>”, <i><span class="bib-booktitle">Proceedings of the Eighth ACM/IEEE Symposium on Architectures for Networking and Communications Systems</span></i>, pp. <span class="bib-pages">163—174</span>, <span class="bib-year">2012</span>. URL <a href="http://doi.acm.org/10.1145/2396556.2396594"><span class="bib-url">http://doi.acm.org/10.1145/2396556.2396594</span></a>.
</p>
</span>
</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Appendix-A">A</a> Do we need an Appendix?
</h1>
<div class="Unindented">
<span lang="en">maybe...</span>
</div>
<div class="Indented">
<a class="toc" name="Index"></a><h1 class="index">Index</h1><p class="printindex">
<a class="printindex" name="index-example"></a>example: <a class="IndexArrow" href="#entry-example-0">↑</a>
</p>
 
</div>

</div>
</body>
</html>
